<!DOCTYPE html>
<html lang=en>
<head>
	<!-- hexo-inject:begin --><!-- hexo-inject:end --><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css">
	<link rel="stylesheet" type="text/css" href="css/comment.css">    
    <meta charset="utf-8">
    
    <title>Storm组件和拓扑结构 | Tankcat</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    

    

    
        <link rel="shortcut icon" href="/css/images/favicon.ico" />
    
	
    <link rel="stylesheet" href="/vendor/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/vendor/open-sans/styles.css">
    <link rel="stylesheet" href="/vendor/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">
	<link rel="stylesheet" href="/css/tagclouds.css">
	<link rel="stylesheet" href="/css/font-awesome.css">
    <script src="/vendor/jquery/2.1.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/vendor/lightgallery/css/lightgallery.min.css">
    
    
    
    
    


	<script src="//cdn.bootcss.com/jquery/2.1.0/jquery.min.js" type="text/javascript"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
        
    <header id="header" style="padding-top:15px">
    <div id="header-main" class="header-inner">
			
			 <div class="outer">

				<a href="/" id="logo">
					<i class="logo"></i>
	
				</a>
				<nav id="main-nav">
					
						<a class="main-nav-link" href="/index.html">Home</a>
					
						<a class="main-nav-link" href="/archives">Archive</a>
					
						<a class="main-nav-link" href="/categories">Category</a>
					
						<a class="main-nav-link" href="/tags">Tag</a>
					
						<a class="main-nav-link" href="/about">About</a>
					
						<a class="main-nav-link" href="/favorite">Photos</a>
					
				</nav>
			</div> 
	</div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/index.html">Home</a></td>
                
                    <td><a class="main-nav-link" href="/archives">Archive</a></td>
                
                    <td><a class="main-nav-link" href="/categories">Category</a></td>
                
                    <td><a class="main-nav-link" href="/tags">Tag</a></td>
                
                    <td><a class="main-nav-link" href="/about">About</a></td>
                
                    <td><a class="main-nav-link" href="/favorite">Photos</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search" />
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>




			
        <div class="outer">
			<aside id="profile">
					<div class="profile-inner">
					</div>
			</aside>
			
					<section id="main"><article id="post-storm component" class="article article-type-post" itemscope itemprop="blogPost">
    
	<div class="article-inner" style="border-radius:1.5px; box-shadow: 10px 10px 5px #ccc;">
        
            
	
		<img src="http://7xwggp.com1.z0.glb.clouddn.com/storm-flow.png" class="article-banner" />
	



        
        
            <header class="article-header">
				
					<center>
    
        <h1 class="article-title" itemprop="name">
            Storm组件和拓扑结构
        </h1>
    

					 
						<div class="article-meta">
							
    <div class="article-date">    
        <a href="/2016/07/16/storm component/">
            <time datetime="2016-07-16T02:06:31.000Z" itemprop="datePublished">2016-07-16</time>
        </a>
    </div>

							<!--
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/源码分析/">源码分析</a>
		&nbsp;&nbsp;
		
			<span class="article-tag">
				<i class="fa fa-tag"></i>
				<a class="tag-link" href="/tags/Storm/">Storm</a>
			</span>
		
    </div>
-->
							<!--
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Storm/">Storm</a>
    </div>
-->
						</div>
					
					
					
						<span class="article-meta">
							
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/源码分析/">源码分析</a>
		&nbsp;&nbsp;
		
			<span class="article-tag">
				<i class="fa fa-tag"></i>
				<a class="tag-link" href="/tags/Storm/">Storm</a>
			</span>
		
    </div>

							
						</span>
						
					
					
					</center>
				
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
			
				<br/>
				 <blockquote style="font-size:120%;line-height:1.5em;color:#083a4e">
					本文以自顶向下的方式介绍Storm的拓扑结构和组件，具体参照《Storm源码分析》。
				 </blockquote>
			  
            <h1 id="Storm简介"><a href="#Storm简介" class="headerlink" title="Storm简介"></a>Storm简介</h1><p>　Storm是Twitter开源的一个类似Hadoop的实时数据处理框架，它原来是由BackType开发，后被Twitter收购，将Storm作为Twitter的实时数据分析系统。<br><a id="more"></a></p>
<h1 id="Storm总体结构"><a href="#Storm总体结构" class="headerlink" title="Storm总体结构"></a>Storm总体结构</h1><p>  Storm的术语比较多，本文涉及的有Spout，Bolt，Stream，Tuple，Stream Grouping，Topology。下面简单介绍一下。</p>
<ul>
<li>Tuple：包含了一个或者多个键值对的列表。默认情况下，元组tuple中的域可以是整型(integer)等基本类型对象。也可以通过定义可序列化(<strong>实现Serializable接口</strong>)的对象来实现自定义的元组类型。</li>
<li>Stream：Storm中最核心的概念，在分布式环境下并行创建、处理的元祖Tuple序列。在声明数据流的时候要给定一个有效的id，若不显示指定，则系统默认会给数据流定义一个名为”default”的id。</li>
<li>Spout：消息生产者，是数据流的数据来源，充当一个采集器的角色，连接到外部的数据源，并将数据转化为一个个tuple。</li>
<li>Bolt：消息处理者，封装了数据处理逻辑，将一个或者多个数据流作为输入，对数据实施运算后，选择性地输出一个或者多个数据流。几种典型的功能有数据过滤、连接、聚合和数据库读写等。</li>
<li>Stream Grouping：定义了消息分发策略，即定义了一个数据流中的tuple如何分发给topology中的不同bolt的任务实例。</li>
<li>Topology：用于封装一个实时计算应用程序的逻辑，类似于Hadoop中的Job。由Stream Grouping连接起来的Spout和Bolt的有向无环图，处理的是源源不断的消息流。</li>
</ul>
<h1 id="Storm编程基础"><a href="#Storm编程基础" class="headerlink" title="Storm编程基础"></a>Storm编程基础</h1><p>  Storm的源码共分为三层，分为如下：</p>
<ol>
<li>Storm最上层的所有接口均是用Java定义的。</li>
<li>上层绝大多数接口的逻辑是用Clojure实现的。</li>
<li>最底层的数据结构是用Thrift定义的。Thrift是Apache下面的跨语言框架，它可以基于Thrift定义文件产生不同语言的代码，有关详细内容可以参考<a href="http://thrift.apache.org/" target="_blank" rel="noopener">thrift</a>。</li>
</ol>
<p>本文主要就上层Java接口介绍Storm的拓扑和组件结构。</p>
<h2 id="拓扑Topology"><a href="#拓扑Topology" class="headerlink" title="拓扑Topology"></a>拓扑Topology</h2><p>  首先，从最外层开始，举一个如何创建topology的例子。代码中的对象下面会一一介绍。<span id="builder"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TopologyBuilder builder = <span class="keyword">new</span> TopologyBuilder();</span><br><span class="line">builder.setSpout(<span class="string">"spout1"</span>, <span class="keyword">new</span> Spout1(), <span class="number">1</span>);</span><br><span class="line">builder.setSpout(<span class="string">"spout2"</span>, <span class="keyword">new</span> Spout2(), <span class="number">5</span>);</span><br><span class="line">builder.setBolt(<span class="string">"bolt"</span>, <span class="keyword">new</span> Bolt1(), <span class="number">3</span>)</span><br><span class="line">        .directGrouping(<span class="string">"spout1"</span>, <span class="string">"stream1"</span>)</span><br><span class="line">        .shuffleGrouping(<span class="string">"spout2"</span>);</span><br><span class="line">Config conf = <span class="keyword">new</span> Config();</span><br><span class="line">conf.setDebug(<span class="keyword">true</span>);</span><br><span class="line">StormSubmitter.submitTopology(<span class="string">"my-topology"</span>, conf, builder.createTopology());</span><br></pre></td></tr></table></figure></span></p>
<p></p>
<h3 id="TopologyBuilder"><a href="#TopologyBuilder" class="headerlink" title="TopologyBuilder"></a>TopologyBuilder</h3><p>第一行代码定义了一个TopologyBuilder对象。TopologyBuilder是一个工具类，用于构造topology。Topology最底层实际上是Thrift的一个数据结构，分为一下2个部分：</p>
<ol>
<li><p>StormTopology<br>定义了Topology的组成，包括Spout和Bolt，每个Spout或者Bolt都有全局唯一的id。目前为止，StateSpoutSpec还没有在设计代码中用到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct StormTopology&#123;</span><br><span class="line">    1: required map&lt;string, SpoutSpec&gt; spouts;</span><br><span class="line">    2: required map&lt;string, Bolt&gt; bolts;</span><br><span class="line">    3: required map&lt;string, StateSpoutSpec&gt; state_spouts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>TopologySummary<br>定义了用户提交的Topology的基本情况，例如该topology分布在几个工作进程上，使用了多少个线程，有多少个任务实例。这些数据主要供Nimbus使用，以返回UI请求的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct TopologySummary&#123;</span><br><span class="line">    1: required string id;</span><br><span class="line">    2: required string name;</span><br><span class="line">    3: required i32 num_tasks;</span><br><span class="line">    4: required i32 num_executors;</span><br><span class="line">    5: required i32 num_workers;</span><br><span class="line">    6: required i32 uptime_secs;</span><br><span class="line">    7: required string status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>由于Topology在Thrift中过于描述化的特性不便于直接使用，所以TopologyBuilder进行了上层的封装，提供了更加方便的构建方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopologyBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, IRichBolt&gt; _bolts = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, IRichSpout&gt; _spouts = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, ComponentCommon&gt; _commons = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, StateSpoutSpec&gt; _stateSpouts = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    ... </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> StormTopology <span class="title">createTopology</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         Map&lt;String, Bolt&gt; boltSpecs = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">         Map&lt;String, SpoutSpec&gt; spoutSpecs = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">         maybeAddCheckpointSpout();</span><br><span class="line">         <span class="keyword">for</span>(String boltId: _bolts.keySet()) &#123;</span><br><span class="line">             IRichBolt bolt = _bolts.get(boltId);</span><br><span class="line">             bolt = maybeAddCheckpointTupleForwarder(bolt);</span><br><span class="line">             ComponentCommon common = getComponentCommon(boltId, bolt);</span><br><span class="line">             boltSpecs.put(boltId, <span class="keyword">new</span> Bolt(ComponentObject.serialized_java(Utils.javaSerialize(bolt)), common));   </span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">for</span>(String spoutId: _spouts.keySet()) &#123;</span><br><span class="line">             IRichSpout spout = _spouts.get(spoutId);</span><br><span class="line">             ComponentCommon common = getComponentCommon(spoutId, spout);</span><br><span class="line">             spoutSpecs.put(spoutId, <span class="keyword">new</span> SpoutSpec(ComponentObject.serialized_java(Utils.javaSerialize(spout)), common));</span><br><span class="line">         &#125;</span><br><span class="line">    </span><br><span class="line">         StormTopology stormTopology = <span class="keyword">new</span> StormTopology(spoutSpecs, boltSpecs,<span class="keyword">new</span> HashMap&lt;String, StateSpoutSpec&gt;());</span><br><span class="line">         stormTopology.set_worker_hooks(_workerHooks);</span><br><span class="line">         <span class="keyword">return</span> stormTopology;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> BoltDeclarer <span class="title">setBolt</span><span class="params">(String id, IRichBolt bolt, Number parallelism_hint)</span></span>&#123;</span><br><span class="line">         validateUnusedId(id);</span><br><span class="line">         initCommon(id, bolt, parallelism_hint);</span><br><span class="line">         _bolts.put(id, bolt);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> BoltGetter(id);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> BoltDeclarer <span class="title">setBolt</span><span class="params">(String id, IRichBolt bolt)</span></span>&#123;</span><br><span class="line">         <span class="keyword">return</span> setBolt(id, bolt, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> BoltDeclarer <span class="title">setBolt</span><span class="params">(String id, IBasicBolt bolt)</span></span>&#123;</span><br><span class="line">         <span class="keyword">return</span> setBolt(id, bolt, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> BoltDeclarer <span class="title">setBolt</span><span class="params">(String id, IBasicBolt bolt, Number parallelism_hint)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> setBolt(id, <span class="keyword">new</span> BasicBoltExecutor(bolt), parallelism_hint);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> SpoutDeclarer <span class="title">setSpout</span><span class="params">(String id, IRichSpout spout, Number parallelism_hint)</span> </span>&#123;</span><br><span class="line">         validateUnusedId(id);</span><br><span class="line">         initCommon(id, spout, parallelism_hint);</span><br><span class="line">         _spouts.put(id, spout);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> SpoutGetter(id);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> SpoutDeclarer <span class="title">setSpout</span><span class="params">(String id, IRichSpout spout)</span></span>&#123;</span><br><span class="line">         <span class="keyword">return</span> setSpout(id, spout, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validateUnusedId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(_bolts.containsKey(id)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Bolt has already been declared for id "</span> + id);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(_spouts.containsKey(id)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Spout has already been declared for id "</span> + id);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(_stateSpouts.containsKey(id)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"State spout has already been declared for id "</span> + id);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">private</span> ComponentCommon <span class="title">getComponentCommon</span><span class="params">(String id, IComponent component)</span> </span>&#123;</span><br><span class="line">          ComponentCommon ret = <span class="keyword">new</span> ComponentCommon(_commons.get(id));</span><br><span class="line">          OutputFieldsGetter getter = <span class="keyword">new</span> OutputFieldsGetter();</span><br><span class="line">          component.declareOutputFields(getter);</span><br><span class="line">          ret.set_streams(getter.getFieldsDeclaration());</span><br><span class="line">          <span class="keyword">return</span> ret;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initCommon</span><span class="params">(String id, IComponent component, Number parallelism)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">          ComponentCommon common = <span class="keyword">new</span> ComponentCommon();</span><br><span class="line">          common.set_inputs(<span class="keyword">new</span> HashMap&lt;GlobalStreamId, Grouping&gt;());</span><br><span class="line">          <span class="keyword">if</span>(parallelism!=<span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">int</span> dop = parallelism.intValue();</span><br><span class="line">              <span class="keyword">if</span>(dop &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Parallelism must be positive."</span>);</span><br><span class="line">              &#125;</span><br><span class="line">              common.set_parallelism_hint(dop);</span><br><span class="line">          &#125;</span><br><span class="line">          Map conf = component.getComponentConfiguration();</span><br><span class="line">          <span class="keyword">if</span>(conf!=<span class="keyword">null</span>) common.set_json_conf(JSONValue.toJSONString(conf));</span><br><span class="line">          _commons.put(id, common);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     ...</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>成员变量<code>_bolts</code>包含了所有的Bolt对象，<code>_spouts</code>包含了所有的spout对象，它们的类型分别是IRichBolt和IRichSpout类型，关于组件的接口下文会慢慢介绍。</p>
<ol>
<li><p>spout的thrift底层结构为SpoutSpec，包含了两个成员，一个是实现消息生产者具体逻辑的spout_object对象，另一个是用来描述其输入输出的common对象，具体定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct SpoutSpec&#123;</span><br><span class="line">    1: required ComponentObject spout_object;</span><br><span class="line">    2: required ComponentCommon common;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>bolt的thrift底层结构为Bolt，结构与SpoutSpec是一致的，这里不再阐述。</p>
</li>
</ol>
</li>
<li><p><code>_commons</code>包含了所有的Bolt和Spout对象，它在Thrift中的数据结构是ComponentCommon:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct ComponentCommon&#123;</span><br><span class="line">    1: required map&lt;GlobalStreamId, Grouping&gt; inputs;</span><br><span class="line">    2: required map&lt;string, StreamInfo&gt; streams;</span><br><span class="line">    3: optimal i32 parallelism_hint;</span><br><span class="line">    4: optimal string json_conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>ComponentCommon是用来表示Topology的基础组件对象,<code>inputs</code>表示该组件将从哪些GlobalStreamId以何种方式接收数据，其中GlobalStreamId是某个组件上定义的一条流，数据结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct GlobalStreamId&#123;</span><br><span class="line">    1: required string componentId;</span><br><span class="line">    2: required string streamId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GlobalStreamId有两个域，componentId表示该流属于哪一个组件，streamId是流的标识。不同组件之间可以使用相同的streamId。分组方式Grouping决定了组件所发送的消息将以何种方式发送到接收端,Grouping被定义为union类型，即表示节点之间只能采取一种分组方式，其结构定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">union Grouping&#123;</span><br><span class="line">    1: list&lt;string&gt; fields //若为空，则采取global grouping的分组方式;</span><br><span class="line">    2: NullStruct shuffle; //随机分组</span><br><span class="line">    3: NullStruct all; //全分组，即广播</span><br><span class="line">    4: NullStruct none; //无分组，全部发送到同一个任务实例上</span><br><span class="line">    5: NullStruct direct; //直接分组，直接发送到指定的任务实例上</span><br><span class="line">    6: JavaObject custom_object;</span><br><span class="line">    7: binary custom_serialized;</span><br><span class="line">    8: NullStruct local_or_shuffle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ComponentCommon中的<code>streams</code>指定了该组件需要输出的流，它给定了streamId以及StreamInfo。StreamInfo中定义了输出流的字段名列表以及该流的消息分组是否是直接分组方式，其结构定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct StreamInfo&#123;</span><br><span class="line">    1: required list&lt;string&gt; output_fields;</span><br><span class="line">    2: required bool direct;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ComponentCommon中的<code>parallelism_hint</code>表示组件的并行度，即有多少个线程，这些线程可分布在不同的进程空间或者机器中，默认值是１。</p>
</li>
<li>ComponentCommon中的<code>json_conf</code>保存了与该组件相关的一些设置。</li>
</ol>
</li>
<li><p>第29~46行定义了<code>setBolt()</code>方法以及其重载。该方法主要功能是定义topology中的bolt对象，并指定其并行度。该方法在运行的过程中首先会通过方法<code>validateUnusedId()</code>检测输入的组件ID是否是唯一的，其次调用<code>initCommon()</code>方法为该组件构建一个ComponentCommon对象，并且只初始化其并行度和配置信息，配置信息被序列化成JSON的形式。<code>setBolt()</code>最后会返回一个<code>BoltGetter</code>对象，将利用其为bolt对象添加输入流信息。关于这个对象后文再具体介绍。</p>
</li>
<li>第50~59行定义了<code>setSpout()</code>方法以及其重载。该方法类似于<code>setBolt()</code>方法，也会产生ComponentCommon对象。</li>
<li>第63~73行定义了<code>validateUnusedId()</code>方法，用于检测输入的组件Id是否是唯一的，若不是则抛出异常。</li>
<li>第75~81行定义了<code>getComponentCommon()</code>方法，该方法是在<code>createTopology()</code>创建拓扑的时候被调用的，设置了组件的输出流信息。</li>
<li>第83~96行定义了<code>initCommon()</code>方法，主要是对ComponentCommon对象进行初始化，设置并行度和配置信息。</li>
<li>最后一个也是最为重要的，第8~27行定义了<code>createTopology()</code>方法，根据输入的Bolt和Spout对象创建Topology对象。从第16行和第21行可以看出，在创建拓扑的过程中，Bolt和Spout均为对象序列化后得到的字节数组。</li>
</ol>
<h2 id="组件Components"><a href="#组件Components" class="headerlink" title="组件Components"></a>组件Components</h2><h3 id="Bolt接口"><a href="#Bolt接口" class="headerlink" title="Bolt接口"></a>Bolt接口</h3><p>再回头看<a href="#builder">创建topology的简单示例</a>，第4行设置bolt的方法中构建了一个类<code>Bolt1</code>的对象实例。该类是一个自定义的Bolt类，可以是实现了Storm定义的Bolt接口，主要有IBolt，IRichBolt，IBasicBolt和IBatchBolt，它们之间的关系如下图所示：<br><img src="http://7xwggp.com1.z0.glb.clouddn.com/Bolt.jpg" alt="Bolt接口的关系图"></p>
<h4 id="IComponent接口"><a href="#IComponent接口" class="headerlink" title="IComponent接口"></a>IComponent接口</h4><p>IComponent是通用的组件接口，所有的Bolt和Spout都会实现这个接口，其代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IComponent</span> <span class="keyword">extends</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer declarer)</span></span>;</span><br><span class="line">    <span class="function">Map&lt;String, Object&gt; <span class="title">getComponentConfiguration</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中，<code>declareOutputFields()</code>的参数为OutputFieldsDeclarer接口，定义了拓扑中每个组件的输出字段声明，每个组件都需要它来指定输出到哪些流、声明输出的字段列表以及指出输出流是否是直接流，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OutputFieldsDeclarer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delcare</span><span class="params">(Fields fields)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delcare</span><span class="params">(<span class="keyword">boolean</span> direct, Fields fields)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delcareStream</span><span class="params">(String streamId,Fields fields)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareStream</span><span class="params">(String streamId,<span class="keyword">boolean</span> direct,Fields fields)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中，第5~6行没有明确指定输出流的id，默认使用的是storm的default流。所有的方法中都有一个<code>Fields</code>对象参数，该类用于存储消息的字段名列表，比如一条学生个人信息的scheme为(“stu_name”,”stu_number”,”stu_age”,”stu_sex”)，其所需参数是字段名集合。对于同一条消息，在构建Fields对象时会为其所有的字段建立索引。它的代码定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fields</span> <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">String</span>&gt;,<span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; _fields;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Integer&gt; _index = <span class="keyword">new</span> HashMap&lt;String,Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Fields</span><span class="params">(String... fields)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Arrays.asList(fields));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Fields</span><span class="params">(List&lt;String&gt; fields)</span></span>&#123;</span><br><span class="line">        _fields= <span class="keyword">new</span> ArrayList&lt;String&gt;(fields.size());</span><br><span class="line">        <span class="keyword">for</span>(String field:fields)&#123;</span><br><span class="line">            <span class="keyword">if</span>(_fields.contains(field))&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">"duplicate field '%s'"</span>, field));</span><br><span class="line">            &#125;</span><br><span class="line">            _fields.add(field);</span><br><span class="line">        &#125;</span><br><span class="line">        index();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">index</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;_fields.size();i++)&#123;</span><br><span class="line">            _index.put(_fields.get(i),i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Fields实现了<code>Iterable&lt;String&gt;</code>接口，表明Fields可以遍历存储的字段名列表；也实现了<code>Serializable</code>接口，表明Fields可以被序列化。第2~3行定义了一个保存所有字段名的列表以及一个保存了从字段名到它在字段名列表中位置的映射表。第5~7行的构造函数接收一个可变参数fields，将其转换为列表好调用第9~19行定义的构造函数。第9~19行定义的构造函数首先会检查传入的字段名列表中是否存在重复的字段名，并保存该字段名列表，最后调用<code>index()</code>方法为该字段名列表建立索引。</p>
<h5 id="IBolt接口"><a href="#IBolt接口" class="headerlink" title="IBolt接口"></a>IBolt接口</h5><p>Bolt是Storm中的基础运行单位，当接收到一条数据时可以不立刻对其进行处理，可以先保存后处理。其生命周期如下：</p>
<blockquote>
<ol>
<li>创建提交Topology时创建IBolt实例并进行序列化操作(见<code>createTopology()</code>)；</li>
<li>将序列化的Bolt组件发送给集群中的主节点；</li>
<li>主节点启动工作进程，并在进程中反序列化Bolt组件；</li>
<li>在开始执行任务之前，先调用Bolt的<code>prepare()</code>回调方法进行初始化，然后再具体处理接收的数据。</li>
</ol>
</blockquote>
<p>IBolt的具体代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBolt</span> <span class="keyword">extends</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">(Map stormConf, TopologyContext context, OutputCollector collector)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple input)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>在实现Bolt的过程中，用户可以编写其构造函数，然而<strong>构造函数并不会被实际调用</strong>，因为在提交Topology时，系统会调用Topology的构造函数，并将产生的对象序列化成字节数组。每一个节点上的Bolt都是通过反序列化的方式得到的，这可能导致某些成员没有被正确的初始化，因此用户应该将复杂对象的初始化放在<code>prepare()</code>回调方法中。第三个参数是一个<code>OutputCollector</code>类对象，它是Bolt的输出收集器，Bolt处理好的消息都是通过输出收集器发送出去的，不同类型的输出收集器也不同，这里先讲一下IRichBolt的输出收集器，它实现了<code>IOutputCollector</code>接口，是一个代理类。<span id="iCollector">IOutputCollector接口如下：</span>。<code>emit()</code>方法用来向外发送数据，它的返回值是该消息所发送目标的TaskId集合，其输入参数分布是消息将被输出的流Id，输出的消息标记(通常代表该条消息从哪些消息产生的)以及要输出的消息。<code>emitDirect()</code>与<code>emit()</code>类似，主要区别在于它发送的消息只有指定的任务实例才能接收。这个方法要求streamId对应的流必须被定义为直接流。如果下游节点没有接收到该消息，那么此类消息其实并没有真正发送。<code>fail()</code>和<code>ack()</code>用来表示消息是否被真正处理。OutputCollector是IOutputCollector的默认实现类，它实际上是一个代理，包含一个真正工作的IOutputCollector实例，这个对象是在Clojure中定义的。OutputCollector中提供了许多重载方法供用户使用，具体定义可参照<a href="http://storm.apache.org/releases/0.9.6/javadocs/index.html" target="_blank" rel="noopener">OutputCollector</a>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IOutputCollector</span> <span class="keyword">extends</span> <span class="title">IErrorReporter</span></span>&#123;</span><br><span class="line">    <span class="function">List&lt;Integer&gt; <span class="title">emit</span><span class="params">(String streamId,Collection&lt;Tuple&gt; anchors,List&lt;Object&gt; tuple)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">emitDirect</span><span class="params">(<span class="keyword">int</span> taskId,String streamId,Collection&lt;Tuple&gt; anchors,List&lt;Object&gt; tuple)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ack</span><span class="params">(Tuple input)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fail</span><span class="params">(Tuple input)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对象在被销毁时，将调用<code>cleanup()</code>回调方法，但是Storm并不保证该方法一定被执行，只有当在本地模式下运行时杀死topology该方法才保证一定能被执行。</p>
</li>
<li><code>execute()</code>方法实现对输入消息的处理。其参数是一个<code>Tuple</code>实例。<code>Tuple</code>是Storm中的主要数据结构，在发送接收消息的过程中，每一条消息实际上都是一个Tuple对象。其接口代码如下：第5~14行的方法用于获取由参数i指定的字段位置的值，如果用户知道该字段对应的类型，就可以调用对应类型的获取方法获取字段的值。第15~24行与之类似，不过这里的方法是根据字段名获取相应的值。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITuple</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fieldIndex</span><span class="params">(String field)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String field)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getInteger</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getLong</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">getBoolean</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Short <span class="title">getShort</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Byte <span class="title">getByte</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">getDouble</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Float <span class="title">getFloat</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getBinary(<span class="keyword">int</span> i);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getValueByField</span><span class="params">(String field)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStringByField</span><span class="params">(String field)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getIntegerByField</span><span class="params">(String field)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getLongByField</span><span class="params">(String field)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">getBooleanByField</span><span class="params">(String field)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Short <span class="title">getShortByField</span><span class="params">(String field)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Byte <span class="title">getByteByField</span><span class="params">(String field)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">getDoubleByField</span><span class="params">(String field)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Float <span class="title">getFloatByField</span><span class="params">(String field)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getBinaryByField(String field);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Fields <span class="title">getFields</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">select</span><span class="params">(Fields selector)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">getValues</span><span class="params">()</span></span>;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> GlobalStreamId <span class="title">getSourceGlobalStreamId</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSourceComponent</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSourceTask</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSourceStreamId</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageId <span class="title">getMessageId</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="IRichBolt接口"><a href="#IRichBolt接口" class="headerlink" title="IRichBolt接口"></a>IRichBolt接口</h4><p>IRichBolt同时实现了IComponent和IBolt接口，其含义是一个具有Bolt功能的组件。在实际使用中，IRichBolt是实现Topology组件的主要接口，其定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IRichBolt</span> <span class="keyword">extends</span> <span class="title">IBolt</span>,<span class="title">IComponent</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="IBasicBolt接口"><a href="#IBasicBolt接口" class="headerlink" title="IBasicBolt接口"></a>IBasicBolt接口</h4><p>IBasicBolt接口的定义与IBolt基本一致，具体实现要求也与IBolt相同，主要区别为一下两点：</p>
<ul>
<li>它的输出收集器使用的是BasicOutputCollector，并且该参数被放在了execute方法中而不是prepare中；</li>
<li>它实现了IComponent接口，表明它可以用来定义Topology组件。<br>首先我们来看一下BasicOutputCollector,它是Storm提供的<code>IBasicOutputCollector</code>接口的默认实现。我们看一下该接口的定义。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBasicOutputCollector</span></span>&#123;</span><br><span class="line">    <span class="function">List&lt;Integer&gt; <span class="title">emit</span><span class="params">(String streamId,List&lt;Object&gt; tuple)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">emitDirect</span><span class="params">(<span class="keyword">int</span> taskId,String streamId,List&lt;Object&gt; tuple)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reportError</span><span class="params">(Throwable t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>对比<a href="#iCollector">IOutputCollector</a>可以看出两者的区别：</p>
<ul>
<li>IBasicOutputCollector中没有ack和fail方法；</li>
<li>IBasicOutputCollector的emit和emitDirect方法中没有anchor参数。<br>这样设计的原因是如果使用了IBasicBolt，Storm框架会自动帮用户进行Ack、Fail和Anchor操作，用户自己不需要关心这一点。所以为了确保这种机制能正常运行，避免用户在使用时出错，Storm提供了简化版的IBasicOutputCollector。BasicOutputCollector收集器实际上是OutputCollector的封装类，其中包含了一个OutputCollector类型的成员变量，实际上所有的消息最终都将由这个OutputCollector进行处理。</li>
</ul>
<p>再回到IBasicBolt，之所以设计这个接口上文已有解释，Storm框架本身帮用户处理了所发出消息的Ack、Fail和Anchor操作，是由执行器<code>BasicBoltExecutor</code>实现的。该类实现了IRichBolt接口，同时还包含了一个IBasicBolt成员变量用于调用的转发，它是基于装饰模式的，定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicBoltExecutor</span> <span class="keyword">implements</span> <span class="title">IRichBolt</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(BasicBoltExecutor.class);</span><br><span class="line">    <span class="keyword">private</span> IBasicBolt _bolt;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> BasicOutputCollector _collector;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasicBoltExecutor</span><span class="params">(IBasicBolt bolt)</span> </span>&#123;</span><br><span class="line">        _bolt = bolt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer declarer)</span> </span>&#123;</span><br><span class="line">        _bolt.declareOutputFields(declarer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(Map stormConf, TopologyContext context, OutputCollector collector)</span> </span>&#123;</span><br><span class="line">        _bolt.prepare(stormConf, context);</span><br><span class="line">        _collector = <span class="keyword">new</span> BasicOutputCollector(collector);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple input)</span> </span>&#123;</span><br><span class="line">        _collector.setContext(input);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            _bolt.execute(input, _collector);</span><br><span class="line">            _collector.getOutputter().ack(input);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(FailedException e) &#123;</span><br><span class="line">            <span class="keyword">if</span>(e <span class="keyword">instanceof</span> ReportedFailedException) &#123;</span><br><span class="line">                _collector.reportError(e);</span><br><span class="line">            &#125;</span><br><span class="line">            _collector.getOutputter().fail(input);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        _bolt.cleanup();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getComponentConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _bolt.getComponentConfiguration();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第3行定义了成员变量_bolt，实现了IBasicBolt接口；第17行设置执行器运行的上下文，它表示经execute方法发送出去的消息都是由输出消息产生的，即输出消息都将标记为输入消息所衍生出来的消息，这是使用IBasicBolt消息跟踪的重要环节。第20行对输入的消息进行Ack操作。这一步意味着基于当前输入消息的处理以及衍生消息的发送已经完成，此时可以对该消息进行Ack操作了。<br>用户实现了IBasicBolt接口的Bolt对象之后，在构建Topology时，Storm会调用<a href="#builder">TopologyBuilder</a>的<code>setBolt</code>方法设置该Bolt对象。<code>setBolt</code>方法会用<code>BasicBoltExecutor</code>封装用户的实现类，这是Storm自动帮用户完成的，而且它还会调用可接收<code>IRichBolt</code>参数的重载方法完成Bolt对象的设置。这也解释了<code>BasicBoltExecutor</code>需要实现IRichBolt接口的原因。</p>
<h4 id="IBatchBolt接口"><a href="#IBatchBolt接口" class="headerlink" title="IBatchBolt接口"></a>IBatchBolt接口</h4><p>区别与IBasicBolt接口，IBatchBolt主要用于Storm中的批处理。Storm的事务Topology以及Trident主要是基于IBatchBolt的。相比前面的IBolt、IRichBolt、IBasicBolt，IBatchBolt中多了一个<code>finishBatch()</code>方法，它在一个批处理结束时被调用。此外，IBatchBolt还去除了<code>cleanup()</code>方法，其接口定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBatchBolt</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Serializable</span>,<span class="title">IComponent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">(Map conf, TopologyContext context, BatchOutputCollector collector, T id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple input)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">finishBatch</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>prepare()</code>方法用来初始化一个Batch，最后一个参数是通用类型T，它可以用作该Batch的唯一标识。在目前的Storm实现中，每个事务都会对应一个Batch，而每个Batch的数据都会由一个新创建的IBatchBolt对象进行处理，当一个Batch被成功处理后，该Batch对应的IBatchBolt对象将被销毁，因此用户不能通过IBatchBolt对象自身存储需要在多个Batch之间进行共享的数据。第二个参数是IBatchBolt的输出收集器<code>BatchOutputCollector</code>,其代码定义如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BatchOutputCollector</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">emit</span><span class="params">(List&lt;Object&gt; tuple)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">emit</span><span class="params">(String streamId, List&lt;Object&gt; tuple)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">emitDirect</span><span class="params">(<span class="keyword">int</span> taskId, List&lt;Object&gt; tuple)</span></span>&#123;</span><br><span class="line">        emitDirect(taskId, Utils.DEFAULT_STREAM_ID,tuple);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">emitDirect</span><span class="params">(<span class="keyword">int</span> taskId, String streamId, List&lt;Object&gt; tuple)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">reportError</span><span class="params">(Throwable error)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>同IBasicOutputCollector类似，不需要自己去处理Ack、Fail和Anchor这3项操作。Storm提供了BatchOutputCollector的默认实现类<code>BatchOutputCollectorImpl</code>,该类是一个代理类，内部封装了OutputCollector变量，所有的方法都通过调用OutputCollector方法来实现。</p>
<ul>
<li><code>finishBatch()</code>方法仅当这批消息被完全处理之后才会被调用。</li>
</ul>
<p>与IBasicBolt类似，使用IBatchBolt也不需要关心何时该对收到的信息进行Ack等操作，Storm框架内部通过<code>BatchBoltExecutor</code>自动帮我们实现了这些功能。<code>BatchBoltExecutor</code>也实现了IRichBolt接口，它会为每个Batch创建与之对应的BatchBolt对象。同时还实现了<code>FinishedCallBack</code>和<code>TimeoutCallback</code>接口。BatchBoltExecutor的代码实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BatchBoltExecutor</span> <span class="keyword">implements</span> <span class="title">IRichBolt</span>, <span class="title">FinishedCallback</span>,<span class="title">TimeoutCallback</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Logger LOG = LoggerFactory.getLogger(BatchBoltExecutor.class);</span><br><span class="line">    <span class="keyword">byte</span>[] _boltSet;</span><br><span class="line">    Map&lt;Object, IBatchBolt&gt; _openTransactions;</span><br><span class="line">    Map _conf;</span><br><span class="line">    TopologyContext _context;</span><br><span class="line">    BatchOutputCollector _collector;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BatchBoltExecutor</span><span class="params">(IBatchBolt bolt)</span></span>&#123;</span><br><span class="line">        _boltSet= Utils.serialize(bolt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(Map conf, TopologyContext context, OutputCollector collector)</span></span>&#123;</span><br><span class="line">        _conf=conf;</span><br><span class="line">        _context=context;</span><br><span class="line">        _collector= <span class="keyword">new</span> BatchOutputCollectorImpl(collector);</span><br><span class="line">        _openTransactions= <span class="keyword">new</span> HashMap&lt;Object, IBatchBolt&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple input)</span></span>&#123;</span><br><span class="line">        Object id = input.getValue(<span class="number">0</span>);</span><br><span class="line">        IBatchBolt bolt = getBatchBolt(id);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            bolt.execute(input);</span><br><span class="line">            _collector.ack(input);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(FailedException e)&#123;</span><br><span class="line">            LOG.error(<span class="string">"Failed to process tuple in batch"</span>,e);</span><br><span class="line">            _collector.fail(input);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finishedId</span><span class="params">(Object id)</span></span>&#123;</span><br><span class="line">        IBatchBolt bolt = getBatchBolt(id);</span><br><span class="line">        _openTransactions.remove(id);</span><br><span class="line">        bolt.finishBatch();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timeoutId</span><span class="params">(Object id)</span></span>&#123;</span><br><span class="line">        _openTransactions.remove(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer declarer)</span></span>&#123;</span><br><span class="line">        newTransactionalBolt().declareOutputFields(declarer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getComponentConfiguration</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> newTransactionalBolt().getComponentConfiguration();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> IBatchBolt <span class="title">getBatchBolt</span><span class="params">(Object id)</span></span>&#123;</span><br><span class="line">         IBatchBolt bolt = _openTransactions.get(id);</span><br><span class="line">         <span class="keyword">if</span>(bolt == <span class="keyword">null</span>)&#123;</span><br><span class="line">            bolt = <span class="keyword">new</span> newTransactionalBolt();</span><br><span class="line">            bolt.prepare(_conf,_context,_collector,id);</span><br><span class="line">            _openTransactions.put(id,bolt);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> bolt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> IBatchBolt <span class="title">newTransactionalBolt</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (IBatchBolt)Utils.deserialize(_boltSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第3行是内含的BatchBolt对象的序列化字节数组。第17~27行实现了<code>execute()</code>方法，它规定输入消息的第一列用于标识Batch的id。第29~33行实现了FinishedCallback接口，这里调用<code>finishBatch()</code>方法清理BatchBolt对象。可以看出，BatchBolt对象在不同的Batch之间是不重复使用的。第34~36行实现了TimeoutCallback接口,仅仅将缓存的BatchBolt删除，这对于清理不再使用的BatchBolt对象是很关键的。第52~54行通过反序列化生成一个IBatchBolt对象。Storm通过反序列化对象的方式来弥补不断创建IBatchBolt对象所带来的负担。</p>
<h3 id="Spout接口"><a href="#Spout接口" class="headerlink" title="Spout接口"></a>Spout接口</h3><p>Storm中与spout相关的接口主要是<code>ISpout</code>和<code>IRichSpout</code>，下图描述了它们之间的关系：<br><img src="http://7xwggp.com1.z0.glb.clouddn.com/Spout.jpg" alt="Spout接口关系图"></p>
<h4 id="ISpout接口"><a href="#ISpout接口" class="headerlink" title="ISpout接口"></a>ISpout接口</h4><p>接口ISpout定义了Spout应该实现的功能集合:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ISpout</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">(Map conf, TopologyContext context, SpoutOutputCollector collector)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">activate</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deactivate</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextTuple</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ack</span><span class="params">(Object msgId)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fail</span><span class="params">(Object msgId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>关于各个函数的功能，源代码中的注释部分已经给出了详细的描述，这里不再赘述。其中，<code>nextTuple()</code>由于和<code>ack()</code>、<code>nextTuple()</code>是在一个线程被调用的，如果nextTuple阻塞的话，其他方法也将被阻塞。因此，该方法必须是非阻塞的，任何Spout都将使用nextTuple来发送信息。</li>
<li>ISpout的fail和ack方法仅仅给出了发送消息时所对应的MessageId,而没有具体给出消息内容，表明如果要实现消息重传的话，用户需要自己来维护哪些已经发送的消息。</li>
<li>当Spout被设置为活跃或者不活跃时，会分别调用<code>activate()</code>和<code>deactivate()</code>方法将状态通知给用户代码。这样当Spout处于非活跃的状态时，nextTuple不会被调用。</li>
<li><code>open()</code>方法的第3个参数是Spout的输出收集器<code>SpoutOutputCollector</code>，Storm只定义了一个Spout的输出收集器接口<code>ISpoutOutputCollector</code>，<code>SpoutOutputCollector</code>是它的默认实现类。首先看一下<code>ISpoutOutputCollector</code>的代码定义：<code>emit()</code>方法用来向外发送数据，它的返回值是该消息所有发送目标的任务实例集合。<code>emitDirect()</code>方法的输入列表与<code>emit()</code>类似，主要区别在于使用前者时，只有由参数taskId所指定的任务实例才能接收到这条消息。<code>SpoutOutputCollector</code>类实际上是一个代理类，本身也封装了一个<code>ISpoutOutputCollector</code>对象，所有的操作实际上都是通过该对象来实现的。除此之外，它还提供了一些重载方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ISpoutOutputCollector</span> <span class="keyword">extends</span> <span class="title">IErrorReporter</span></span>&#123;</span><br><span class="line">    <span class="function">List&lt;Integer&gt; <span class="title">emit</span><span class="params">(String streamId, List&lt;Object&gt; tuple, Object messageId)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">emitDirect</span><span class="params">(<span class="keyword">int</span> taskId, String streamId, List&lt;Object&gt; tuple, Object messageId)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getPendingCount</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="IRich接口"><a href="#IRich接口" class="headerlink" title="IRich接口"></a>IRich接口</h4><p>IRichSpout需要同时实现IComponent和ISpout接口，因此它是一个具有Spout功能的组件，其定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IRichSpout</span> <span class="keyword">extends</span> <span class="title">ISpout</span>,<span class="title">IComponent</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

			
			
		<br>
		
		
		
<div class="copyright">
  <p><span>Title:</span><a href="/2016/07/16/storm component/">Storm组件和拓扑结构</a></p>
  <p><span>Author:</span><a href="/" title="visit Tankcat 's personal blog">Tankcat</a></p>
  <p><span>Release Date:</span>2016-07-16  10:06</p>
  <p><span>Update Date:</span>2016-09-16  11:38</p>
  <p>
    <span>Original Link:</span><a href="/2016/07/16/storm component/" title="Storm组件和拓扑结构">http://tankcat2.com/2016/07/16/storm component/</a>
    <span class="btn" data-clipboard-text="Master Copy: http://tankcat2.com/2016/07/16/storm component/　　Author: Tankcat" title="copy the article link">
        <i class="fa fa-clipboard"></i>
    </span>
  </p>
 <p><span>License Agreement:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="Mainland China (CC BY-NC-SA 3.0 CN)">"Signature-Non Commercial-Share Alike 3.0"</a>.
 <br>
 <br>
 <span>Please retain the original link and author if reprinting.
 </span>
 </p>
  <script src="/js/clipboard.min.js"></script>
  <script> var clipboard = new Clipboard('.btn'); </script>
</div>
<style type="text/css">
  .copyright p .btn {
    margin-left: 1em;
  }
  .copyright:hover p .btn::after {
    content: "Copy"
  }
  .copyright p .btn:hover {
      color: gray;
      cursor: pointer;
    };
</style>

<br>
<br>
		<style type="text/css">
		  .center {
			  text-align: center;
		  }
		  .hidden {
			  display: none;
		  }
		.donate_bar a.btn_donate{
		  display: inline-block;
		  width: 82px;
		  height: 82px;
		  background: url("http://7xsl28.com1.z0.glb.clouddn.com/btn_reward.gif") no-repeat;
		  _background: url("http://7xsl28.com1.z0.glb.clouddn.com/btn_reward.gif") no-repeat;
		  -webkit-transition: background 0s;
		  -moz-transition: background 0s;
		  -o-transition: background 0s;
		  -ms-transition: background 0s;
		  transition: background 0s;
		}

		.donate_bar a.btn_donate:hover{ background-position: 0px -82px;}
		.donate_bar .donate_txt {
		  display: block;
		  color: #9d9d9d;
		  font: 14px/2 "Microsoft Yahei";
		}
		.bold{ font-weight: bold; }
	  </style>
	  
	  
	  
	  <div id="donate_module">
		<div id="donate_board" class="donate_bar center">
		打赏 | Buy me a coffee<br/><br/>
		<a id="btn_donate" class="btn_donate" target="_self" href="javascript:;" title="Donate 打赏" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}"></a>
		  
		
		</div>
		
		<div id="QR" style="display: none;">
			<br>
		  <br>
		
		<a href="http://7xwggp.com1.z0.glb.clouddn.com/wechatdonate.jpg" title="用微信扫一扫哦~" class="fancybox" rel="article0">
		  <img src="http://7xwggp.com1.z0.glb.clouddn.com/wechatdonate.jpg" title="微信打赏 Colin" height="250px" width="250px"/>
		</a>
		<br>
		<center>
		<span class="donate_txt">
		  If you enjoy the blog, please feel free to donate~Thx for your support.
		</span>
	</center>
	  </div>
	  <br>
	   
	  </div>
		
				
			
        </div>
		
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://tankcat2.com/2016/07/16/storm component/" data-id="cjahscxsw001piwkxcafsl297" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=' + encodedUrl + '" class="fa fa-qq article-share-qzone" target="_blank" title="Qzone"></a>',
                            '<a href="http://service.weibo.com/share/share.php?url=' + encodedUrl + '" class="fa fa-weibo article-share-weibo" target="_blank" title="Weibo"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://tankcat2.com/2016/07/16/storm component/#comments" class="article-comment-link disqus-comment-count" data-disqus-url="http://tankcat2.com/2016/07/16/storm component/">Comments</a>
    

        </footer>
		
    </div>
    
        
<nav id="article-nav">
    
        <a href="/2016/07/18/lein/" id="article-nav-newer" class="article-nav-link-wrap">
            <strong class="article-nav-caption">Newer</strong>
            <div class="article-nav-title">
                
                    Leiningen安装
                
            </div>
        </a>
    
    
</nav>


    
</article>




	
    
    <section id="comments" style="border-radius:1.5px; box-shadow: 10px 10px 5px #ccc;">
    
        
<div id="container"></div>
<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
var gitment = new Gitment({
  owner: 'tankcat',
  repo: 'tankcat.github.io',
  oauth: {
    client_id: '60fb85b01453b027d1f5',
    client_secret: '4d0e75031ae53e76418d288b34897a8718481fd2',
  },
})
gitment.render('comments')
</script>

    
    </section>


</section>
			
			
			
        </div>

			<div style="height:10px;pistion:absolute;bottom:0"></div>
<footer id="footer" >
    <div class="outer">
		<div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
        <div id="footer-info" class="inner">
            &copy; 2017 <i class="fa fa-heart blink-slow"></i> Tankcat<br>
            Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme by <a href="http://github.com/ppoffice">PPOffice</a>
        </div>
		
    </div>
</footer>
			
    
<div id="container"></div>
<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
var gitment = new Gitment({
  owner: 'tankcat',
  repo: 'tankcat.github.io',
  oauth: {
    client_id: '60fb85b01453b027d1f5',
    client_secret: '4d0e75031ae53e76418d288b34897a8718481fd2',
  },
})
gitment.render('comments')
</script>



    
        <script src="/vendor/lightgallery/js/lightgallery.min.js"></script>
        <script src="/vendor/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/vendor/lightgallery/js/lg-pager.min.js"></script>
        <script src="/vendor/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/vendor/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/vendor/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/vendor/lightgallery/js/lg-hash.min.js"></script>
        <script src="/vendor/lightgallery/js/lg-share.min.js"></script>
        <script src="/vendor/lightgallery/js/lg-video.min.js"></script>
    
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

	
    </div><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>

</html>