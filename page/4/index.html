<!DOCTYPE html><html lang="en"><head><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css"><meta charset="utf-8"><title>Tankcat</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><link rel="shortcut icon" href="/css/images/favicon.ico"><link rel="stylesheet" href="/vendor/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/vendor/open-sans/styles.css"><link rel="stylesheet" href="/vendor/source-code-pro/styles.css"><link rel="stylesheet" href="/css/comment.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/tagclouds.css"><link rel="stylesheet" href="/css/font-awesome.css"><script src="/vendor/jquery/2.1.3/jquery.min.js"></script><link rel="stylesheet" href="/vendor/lightgallery/css/lightgallery.min.css"><script src="//cdn.bootcss.com/jquery/2.1.0/jquery.min.js" type="text/javascript"></script><script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script><script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script><script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></head><body><div id="containerr"><header id="header" style="padding-top:15px"><div id="header-main" class="header-inner"><div class="outer"><a href="/" id="logo"><i class="logo"></i></a><nav id="main-nav"> <a class="main-nav-link" href="/index.html">Home</a> <a class="main-nav-link" href="/archives">Archive</a> <a class="main-nav-link" href="/categories">Category</a> <a class="main-nav-link" href="/tags">Tag</a> <a class="main-nav-link" href="/about">About</a> <a class="main-nav-link" href="/favorite">Photos</a></nav></div></div><div id="main-nav-mobile" class="header-sub header-inner"><table class="menu outer"><tr><td><a class="main-nav-link" href="/index.html">Home</a></td><td><a class="main-nav-link" href="/archives">Archive</a></td><td><a class="main-nav-link" href="/categories">Category</a></td><td><a class="main-nav-link" href="/tags">Tag</a></td><td><a class="main-nav-link" href="/about">About</a></td><td><a class="main-nav-link" href="/favorite">Photos</a></td><td><div class="search-form"> <input type="text" class="ins-search-input search-form-input" placeholder="Search"></div></td></tr></table></div></header><div class="outer"><aside id="profile"><div class="profile-inner"></div></aside><section id="main"><article id="post-daofeng" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-inner" style="border-radius:1.5px;box-shadow:10px 10px 5px #ccc"> <a href="/2017/04/20/daofeng/" itemprop="url"><img src="http://7xwggp.com1.z0.glb.clouddn.com/daofeng.png" class="article-banner"></a><header class="article-header"><center><h1 itemprop="name"> <a class="article-title" href="/2017/04/20/daofeng/">&lt;刀锋&gt;观后感</a></h1><div class="article-meta"><div class="article-date"> <a href="/2017/04/20/daofeng/"><time datetime="2017-04-20T12:11:31.000Z" itemprop="datePublished">2017-04-20</time></a></div></div></center></header><div class="article-entry" itemprop="articleBody"><p></p><p>先摘抄一段刀锋里面我很喜欢的一段话，“For men and women are not only themselves; they are also the region in which they were born, the city apartment or the farm in which they learnt to walk, the games they played as children, the tales they overheard, the food they ate, the schools they attended, the sports they followed, the poets they read and the God they believed in. It is all these things that have made them what they are, and these are the things that you can’t come to know by hearsay, you can only know them if you have lived them. You can only know them if you are them.”</p><p>“因为人不论男男女女，都不仅仅是他们自身；他们也是自己出生的乡土，学步的农场或城市公寓，儿时玩的游戏，私下听来的山海经，吃的饭食，上的学校，关心的运动，吟哦的诗章，和信仰的上帝。这一切东西把他们造成现在这样，而这些东西都不是道听途说就可以了解的，你非得和那些人生活过。要了解这些，你就得是这些。 ”</p><p>无论中英文，都是一流的文字，解释了各种文化之间的冲突，以及冲突误解的永恒性。</p><p>很少有外国作品上让我读得这么舒服，这完全归功于周旭良老师的翻译功底，整本书翻译地非常好，读起来如沐春风。书写得很平淡，但每个角色都很有意思，拉里最为迷人。很奇怪，刚开始看的时候我脑子里对拉里的想象，居然是血战钢锯岭里的戴斯蒙特，这里也仅是人物形象。拉里一直追寻的答案，等同于追求终极真理，而这个问题最终都会归结到理性与精神的绝对满足。真的很难以想象，拉里这样的人，现实中又有多少，他们的生活又是怎样的？这种绝对的内心的泰然平和，我生生世世估计也做不到吧。<br></p><p class="article-more-link"> <a href="/2017/04/20/daofeng/#more">Read More</a></p><div class="article-tag"><i class="fa fa-tag"></i> <a class="tag-link" href="/tags/刀锋/">刀锋</a>, <a class="tag-link" href="/tags/毛姆/">毛姆</a></div><p></p></div></div></article><article id="post-historyUSA" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-inner" style="border-radius:1.5px;box-shadow:10px 10px 5px #ccc"> <a href="/2017/04/16/historyUSA/" itemprop="url"><img src="http://7xwggp.com1.z0.glb.clouddn.com/meiguo.png" class="article-banner"></a><header class="article-header"><center><h1 itemprop="name"> <a class="article-title" href="/2017/04/16/historyUSA/">&lt;简明美国史&gt;观后感</a></h1><div class="article-meta"><div class="article-date"> <a href="/2017/04/16/historyUSA/"><time datetime="2017-04-16T12:11:31.000Z" itemprop="datePublished">2017-04-16</time></a></div></div></center></header><div class="article-entry" itemprop="articleBody"><p></p><p>相对于厚重的、教科书式的历史文献，这是一本薄薄的，轻松的普及读本，没有平板数据，没有经济图表，却把把美国历史的端倪，黑暗，辉煌，血腥，光明清晰地勾勒出来。</p><p>有人说陈勤老师的这本美国史写得实在是太简太浅显，但是对我这种历史水平只停留在高中课本上的”史盲“来说，基本上是够了，从脉络上了解美国自1620年《五月花号公约》至2016年奥巴马最后的执政之间所发生的重大历史事件，这其中涵盖了美国从英属殖民地开始，到1776年《独立宣言》宣告独立，到1860年林肯领导南北战争，再到一战、二战、冷战，以及至今美国发生的种种。读完全书的第一感受是，陈勤老师应当是亲美派的，书中给我描述的美国是一个有趣、鲜活、有人味的美国，虽然对历史变革中发生的流血事件只是轻描淡写地带过，但还是能些许体会到”世界何尝不简单，历史从来不温柔“这一面。读完一遍脑海中对美国的历史线还是稍有混乱，有时间自己再整理整理。</p><p></p><p class="article-more-link"> <a href="/2017/04/16/historyUSA/#more">Read More</a></p><div class="article-tag"><i class="fa fa-tag"></i> <a class="tag-link" href="/tags/历史/">历史</a></div><p></p></div></div></article><article id="post-kafka_quickstart" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-inner" style="border-radius:1.5px;box-shadow:10px 10px 5px #ccc"> <a href="/2017/02/27/kafka_quickstart/" itemprop="url"><img src="http://7xwggp.com1.z0.glb.clouddn.com/kafka_diagram.png" class="article-banner"></a><header class="article-header"><center><h1 itemprop="name"> <a class="article-title" href="/2017/02/27/kafka_quickstart/">Kafka快速入门</a></h1><div class="article-meta"><div class="article-date"> <a href="/2017/02/27/kafka_quickstart/"><time datetime="2017-02-27T12:11:31.000Z" itemprop="datePublished">2017-02-27</time></a></div></div></center></header><div class="article-entry" itemprop="articleBody"><p></p><p>翻译自kafka documentation的quick start 部分。</p><ol><li><p>下载Zookeeper</p><p>我使用的是<a href="http://mirrors.hust.edu.cn/apache/zookeeper/zookeeper-3.4.6/zookeeper-3.4.6.tar.gz" target="_blank" rel="noopener">zookeeper-3.4.6</a>版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -xvzf zookeeper-3.4.6.tgz</span><br><span class="line">cd zookeeper-3.4.6/conf</span><br></pre></td></tr></table></figure><p>将<code>zoo_example.cfg</code>改名为<code>zoo.cfg</code>，并在<code>/etc/profile</code>中设置环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line">export ZK_HOME=/home/admin/zookeeper-3.4.6</span><br><span class="line">export PATH=$PATH:$ZK_HOME/bin:$ZK_HOME/conf</span><br></pre></td></tr></table></figure></li><li><p>下载Kafka</p><p>我使用的是<a href="https://www.apache.org/dyn/closer.cgi?path=/kafka/0.10.2.1/kafka_2.10-0.10.2.1.tgz" target="_blank" rel="noopener">kafka_2.10-0.10.2.1</a>版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -xvzf kafka_2.10-0.10.2.1</span><br><span class="line">cd kafka_2.10-0.10.2.1/config</span><br></pre></td></tr></table></figure><p>接下来进行参数配置：<code>server.properties</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vim server.properties</span><br><span class="line">...</span><br><span class="line"><span class="meta">#</span> 修改broker.id,全局唯一</span><br><span class="line"><span class="meta">#</span> 修改zookeeper.connect，形式为host:port，多个数据项用逗号分隔</span><br><span class="line">zookeeper.connect=192.168.115:2181</span><br><span class="line"><span class="meta">#</span> 设置话题的删除,默认值为false</span><br><span class="line">delete.topic.enable=true</span><br><span class="line"><span class="meta">#</span> 设置数据日志路径</span><br><span class="line">log.dirs=/home/admin/kafka_2.10-0.10.2.1/kafka-logs</span><br></pre></td></tr></table></figure></li><li><p>启动</p><p>Kafka使用Zookeeper，所以需要先启动Zookeeper，我没有使用Kafka内置的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zkServer.sh start</span><br></pre></td></tr></table></figure><p>接着启动Kafka:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-server-start.sh config/server.properties</span><br></pre></td></tr></table></figure></li><li><p>创建topic</p><p>使用下面的命令创建名为<code>single_node</code>的topic，副本数为1，分区数为1，命令执行结束后，<code>kafka-logs</code>路径下就会生成一个<code>single_node-0</code>的文件夹。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.h --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic single_node</span><br></pre></td></tr></table></figure></li><li><p>发布与消耗数据</p><p>执行下面的命令创建producer进程，从标准输入中获取数据，并发送到Kafka集群中的single_node这个topic中，默认地，每一行将作为单独的一条信息发送出去。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-producer.sh --broker-list localhost:9092 --topic single_node</span><br><span class="line">wxt</span><br><span class="line">zf</span><br><span class="line">i love u</span><br></pre></td></tr></table></figure><p>执行下面的命令创建consumer进程，消耗指定topic的数据，这里就是标准输出的数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic single_node --from-beginning</span><br><span class="line">wxt</span><br><span class="line">zf</span><br><span class="line">i love u</span><br></pre></td></tr></table></figure></li></ol><p>以上均是单机版的Kafka配置与使用。</p><p></p><p class="article-more-link"> <a href="/2017/02/27/kafka_quickstart/#more">Read More</a></p><div class="article-tag"><i class="fa fa-tag"></i> <a class="tag-link" href="/tags/Kafka/">Kafka</a></div><p></p></div></div></article><article id="post-evil" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-inner" style="border-radius:1.5px;box-shadow:10px 10px 5px #ccc"> <a href="/2017/02/27/evil/" itemprop="url"><img src="http://7xwggp.com1.z0.glb.clouddn.com/alice.jpg" class="article-banner"></a><header class="article-header"><center><h1 itemprop="name"> <a class="article-title" href="/2017/02/27/evil/">再见我的暴力女王</a></h1><div class="article-meta"><div class="article-date"> <a href="/2017/02/27/evil/"><time datetime="2017-02-27T12:11:31.000Z" itemprop="datePublished">2017-02-27</time></a></div></div></center></header><div class="article-entry" itemprop="articleBody"><p></p><p>初二的时候，老妈同事的儿子来我家排练吹笛子，给我讲了生化危机3，当时没记住名字；</p><p>后来在家里的电脑上翻到了，还是没字幕英文版的，就这样看完了；</p><p>到了高二，周末回家，把第一部第二部给补完了，没看过瘾，导致后来第二部反复拿出来看，可能看了有十多遍了，里面的角色很鲜明，很喜欢吉尔，喜欢短发帅气的她；</p><p>没过多久，第四部就上映了，在网上看过一遍之后才去老文化馆那边的电影院再看一遍，记得那次的3D眼睛还是硬纸片做的；第五部也是在网上看的枪版，越来越没趣。</p><p>今天，和实验室的小伙伴一起看了终章，看完有点失落，追了这么多年的欧美暴力女王，就这么结束了。我不说这是情怀，有点装逼，但可能也是因为生化3，开始了我喜欢丧尸类型片子之路。等网上出了终章的未删减版，我要再刷一波。</p><p>最后，刚刚在知乎上看到“如何评价生化危机6”里面有个回答说，我觉得最大的彩蛋是我旁边的哥们儿看到女主骑着摩托绝尘而去的时候，突然说了一句，她真该进复联。。。</p><p></p><p class="article-more-link"> <a href="/2017/02/27/evil/#more">Read More</a></p><div class="article-tag"><i class="fa fa-tag"></i> <a class="tag-link" href="/tags/生化危机/">生化危机</a></div><p></p></div></div></article><article id="post-Robust and Skew-resistant Parallel Joins in Shared-Nothing Systems" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-inner" style="border-radius:1.5px;box-shadow:10px 10px 5px #ccc"><header class="article-header"><center><h1 itemprop="name"> <a class="article-title" href="/2017/01/17/Robust and Skew-resistant Parallel Joins in Shared-Nothing Systems/">Robust and Skew-resistant Parallel Joins in Shared-Nothing Systems</a></h1><div class="article-meta"><div class="article-date"> <a href="/2017/01/17/Robust and Skew-resistant Parallel Joins in Shared-Nothing Systems/"><time datetime="2017-01-17T05:11:31.000Z" itemprop="datePublished">2017-01-17</time></a></div></div></center></header><div class="article-entry" itemprop="articleBody"><p></p><h2 id="并行连接处理的两种基本框架"><a href="#并行连接处理的两种基本框架" class="headerlink" title="并行连接处理的两种基本框架"></a>并行连接处理的两种基本框架</h2><ul><li><p><strong>hash-based</strong> 基于哈希，如下图所示，分为四个步骤：</p><ol><li>partition划分，将原先每个节点上存储的$R_i$和$S_i$按照连接属性键的哈希值进行划分，比如图中，将第一个节点(大的实线矩形)中的$R_1$和$S_1$分别划分为k个子集；</li><li>distribution分发，根据连接属性键的哈希值，将上面的子集分发到另外一个空闲节点上，比如图中，将每个节点中的第k个子集$R_{ik}$ 和 $S_{ik}$ 同时分发到一个空闲节点上，那么这个空闲节点存储的数据为$R_k=\bigcup_{i=1}^{n}R_{ik}$,$S_k=\bigcup_{i=1}^{n}S_{ik}$;</li><li>build构建，在空闲节点中，对数据集$R_k$进行扫描，并对它构建一个存储在内存中的哈希表；</li><li>prob检测，在空闲节点中，对数据集$S_k$进行遍历，判断每一条数据的键值是否存在于上面构建的哈希表中，并输出连接结果.</li></ol><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/hash-based.png" alt="hash-based"></p></li><li><p><strong>duplication-based</strong> 基于副本，如下图所示，分为三个步骤：</p><ol><li>duplication复制，针对每个节点，将其中存储的数据集$R_i$广播到其他所有并行节点上(不是空余节点)，这样在广播操作结束后，所有节点上的数据集$R_k=\bigcup_{i=1}^{n}R_i=R$即为全集R；</li><li>build构建，构建哈希表，与hash-based相似；</li><li>prob检测，遍历另外一个数据集，输出连接结果，与hash-based相似.</li></ol></li></ul><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/duplicated-based.png" alt="duplicated-based"></p><h2 id="PRPD连接算法"><a href="#PRPD连接算法" class="headerlink" title="PRPD连接算法"></a>PRPD连接算法</h2><ol><li><p>PRPD定义：partial redistribution &amp; partition duplication，即将hash-based和duplication-based相结合.</p></li><li><p>处理流程，如下图所示：处理数据集R和S的连接，假设R是均匀分布，S是倾斜分布. 将每个节点中存储的S划分为两部分，$S_{loc}$是倾斜数据子集，$S_{redis}$是剩余的非倾斜数据子集.前者保留才原节点中不动，后者需要根据连接键值重新分发到一个空余节点中，类似与hash-based中的distribution操作. 同样，将每个节点中存储的R划分为两部分，$R_{dup}$是与$S_{loc}$连接键值相同的数据子集，$R_{redis}$是剩余的数据子集. 前者需要广播到其余所有的原节点中，类似于duplication-based中的duplication操作，后者需要根据连接键值重新分发到空余节点中，按照hash-based的最后两步，与$S_{redis}$进行连接.</p><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/PRPD.jpg" alt="PRPD"></p></li><li><p>存在的问题：</p><ul><li>global skew，涉及到的对数据集S和R的划分需要预先获取每个节点上的倾斜键值的分布；</li><li>broadcasting，数据子集R的广播操作对网络负载施压，并且广播量将随着节点数量的增加而增加.</li></ul></li></ol><h2 id="本文提出算法"><a href="#本文提出算法" class="headerlink" title="本文提出算法"></a>本文提出算法</h2><p>PRPQ是基于两个可有效处理数据倾斜的分布式连接算法，semijoin-based和query-based. 基于这两者，提出改进.</p><h3 id="Semijoin-based-连接"><a href="#Semijoin-based-连接" class="headerlink" title="Semijoin-based 连接"></a>Semijoin-based 连接</h3><ol><li><p>semi-join的定义：半连接，从一个表中返回的行与另一个表中数据进行<strong>不完全</strong>连接查询，即查找到匹配的数据行就返回，不再继续查找.</p></li><li><p>semijoin-based连接，如下图所示. 数据集R和S在各自的属性a和b上做连接操作，分为以下四步骤：</p><ol><li>类似于hash-based中的第1,2两步，将各个节点中的数据集$R_i$按照连接属性的哈希值进行切分，再将元组分发到各自对应的空闲计算节点中(图中的红色虚线);</li><li>对各个节点中的数据集$S_i$在属性b上做投影操作得到$\pi_b(S_i)$，根据哈希值将这些属性b的unique key分发到计算节点中；</li><li>每个计算节点k收到数据集S的key 子集$\pi_b(S_{ik})$，和数据集R的子集$R_k=\bigcup_{i=1}^nR_{ik}$，对这两个子集做连接操作，将能连接上的R元组回发到各自的原节点i上(图中的③号线)；</li><li>各个原节点接收到retrieval返回的R集元组，与本地存储的S集元组做最后实际的连接操作，输出结果.</li></ol><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/semijoin.png" alt="semijoin"></p></li><li><p>特点：</p><ul><li>由于<strong>投影</strong>操作，S数据集只考虑unique key，而不考虑key的粒度，因此可以<strong>解决数据倾斜</strong>；</li><li>第2和第3步骤，只传输key和能连接上的元组，因此<strong>减轻了网络传输代价</strong>.</li><li>对于高选择性的连接，第2步和第3步中，S集的key和retrieval的R集元组交叠的数据量较大，仍然可能带来很大的网络通信量.</li></ul></li></ol><h3 id="Query-based-连接"><a href="#Query-based-连接" class="headerlink" title="Query-based 连接"></a>Query-based 连接</h3><ol><li><p>根据semijoin-based的第三个特点(存在的问题)，对第3和第4步进行改进，则有query-based连接算法.改进如下：</p><ol><li>若存在连接上的key和R集元组，则只返回value，而不是整个元组；若没有数据能连接上，则返回值为null的value；</li><li>返回的value和本地的S数据集做最后的实际连接操作，输出连接结果.</li></ol></li><li><p>特点：</p><ul><li>对于高选择性的连接处理，优势大，减轻网络通信负载；</li><li>对于低选择性的连接处理，存在问题，对于第3步没有能连接上的key，需要给返回的value赋值为null，以保证<key ,value>的序列以便最后的连接处理，因此可能降低处理速度.</key></li></ul></li><li><p>折中综合：通过一个<strong>计数器</strong>来统计第3步骤中null出现的比例，从而动态地选择适合的方法，即当null比例较低时，使用query-based，否则使用semijoin-based.</p><h3 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h3><p>本文比较推崇直接在内存中进行连接计算，而不使用基于磁盘的计算框架比如MapReduce. 因此网络通信成本至关重要.当处理大规模的连接操作，上述两种方法都可能遭遇无法接受的网络通信负荷.</p><h3 id="PRPQ连接算法"><a href="#PRPQ连接算法" class="headerlink" title="PRPQ连接算法"></a>PRPQ连接算法</h3><ol><li><p>PRPQ定义：partial redistribution &amp; partial query，将hash-based和query-based相结合，如下图所示，分为四步骤：</p><ol><li><p>R distribution，与hash-based类似，将各个节点i上存储的数据集$R_i$根据连接属性a的哈希值，重新分发到一个空余计算节点上(图中红色虚线①)；</p></li><li><p>Push query keys，将各个节点i上存储的数据集$S_i$划分为两部分，低数据倾斜部分$S_i^{‘}$和高数据倾斜部分$h_i$. 根据连接属性b的哈希值，同时将$S_i^{‘}$的元组和$h_i$的投影unique key集合$\pi_b(h)$重新分发到对应的计算节点上(图中紫色虚线②)；</p></li><li>Return queried values，在每个计算节点k上，与hash-based的第3步类似，对集合$R_k=\bigcup_{i=1}^{n}R_{ik}$建立哈希表，(1). 对接收到的集合$\bigcup_{i=1}^{n}S_{ik}^{’}$进行遍历，并查找哈希表，直接输出连接结果；(2). 对接收到的key集合$\pi_b(h_{ik})$也遍历并查找路由表，如果没有匹配的key，则将retrieval的value置为null，若有匹配的key，则返回对应R的value.所有返回的value和节点k接收到key的顺序一致，并返回发送到原节点i；</li><li>Result lookup，接收到计算节点返回的value集合之后，在原节点中遍历value，并和本地存储的数据集S的高倾斜部分h进行连接，输出连接结果：若value为null，则继续扫描下一个；若不为空，则必定存在一个R和S的元组能连接上. 因此，最终的连接结果是第3步骤的部分结果$\bigcup$第4部分的连接结果.</li></ol><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/PRPQ.png" alt="PRPQ"></p></li><li><p>特点：</p><ul><li>与query-based算法相比<ol><li>当处理的数据集包含大量倾斜程度低的数据时，在网络上传送的query key以及对应的value的规模将相当小. 在倾斜程度为0的情况下，即为hash-based算法的实现.因此，PRPQ算法有效地弥补了query-based算法的缺点，提高了鲁棒性.</li><li>继承了query-based算法的优点，处理倾斜程度高的数据集时，大大减少网络通信量，因为高倾斜的元组并没有直接在网络上传输，而仅仅传输其unique key.</li></ol></li><li>与PRPD算法相比<ol><li>最主要的区别在于，使用query而不是duplication操作.</li><li>PRPQ涉及到的数据划分(第2步骤对S数据集进行倾斜程度的划分)，只定性分析局部的倾斜度，而不需要全局的；而PRPD需要获取全局数据集S的倾斜分布信息.关于如何定义全局倾斜，PRPD在连接操作之前将倾斜程度高的元组均匀分发到所有节点上.这个预处理操作会带来额外的通信代价.</li><li>对于倾斜程度中等mid-skew的元组，如何确定问题，PRPD使用广播的操作，可能导致节点负荷超载.</li></ol></li></ul></li></ol></li></ol><p></p><p class="article-more-link"> <a href="/2017/01/17/Robust and Skew-resistant Parallel Joins in Shared-Nothing Systems/#more">Read More</a></p><div class="article-tag"><i class="fa fa-tag"></i> <a class="tag-link" href="/tags/Join/">Join</a></div><p></p></div></div></article><nav id="page-nav"> <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/home.html">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a></nav></section></div><div style="height:10px;pistion:absolute;bottom:0"></div><footer id="footer"><div class="outer"><div id="search-form-wrap"><form class="search-form"> <input type="text" class="ins-search-input search-form-input" placeholder="Search"> <button type="submit" class="search-form-submit"></button></form><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"> <input type="text" class="ins-search-input" placeholder="Type something..."><span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)"},ROOT_URL:"/",CONTENT_URL:"/content.json"}</script><script src="/js/insight.js"></script></div><div id="footer-info" class="inner"> &copy; 2017<i class="fa fa-heart blink-slow"></i> Tankcat<br> Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme by <a href="http://github.com/ppoffice">PPOffice</a></div></div></footer><div id="container"></div><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var gitment=new Gitment({id:"",owner:"tankcat",repo:"tankcat.github.io",oauth:{client_id:"60fb85b01453b027d1f5",client_secret:"4d0e75031ae53e76418d288b34897a8718481fd2"}});gitment.render("comments")</script><script src="/vendor/lightgallery/js/lightgallery.min.js"></script><script src="/vendor/lightgallery/js/lg-thumbnail.min.js"></script><script src="/vendor/lightgallery/js/lg-pager.min.js"></script><script src="/vendor/lightgallery/js/lg-autoplay.min.js"></script><script src="/vendor/lightgallery/js/lg-fullscreen.min.js"></script><script src="/vendor/lightgallery/js/lg-zoom.min.js"></script><script src="/vendor/lightgallery/js/lg-hash.min.js"></script><script src="/vendor/lightgallery/js/lg-share.min.js"></script><script src="/vendor/lightgallery/js/lg-video.min.js"></script><script src="/js/main.js"></script></div><script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script><script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"></script></body></html>