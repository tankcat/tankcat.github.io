<!DOCTYPE html><html lang="en"><head><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css"><meta charset="utf-8"><title>Tankcat</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><link rel="shortcut icon" href="/css/images/favicon.ico"><link rel="stylesheet" href="/vendor/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/vendor/open-sans/styles.css"><link rel="stylesheet" href="/vendor/source-code-pro/styles.css"><link rel="stylesheet" href="/css/comment.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/tagclouds.css"><link rel="stylesheet" href="/css/font-awesome.css"><script src="/vendor/jquery/2.1.3/jquery.min.js"></script><link rel="stylesheet" href="/vendor/lightgallery/css/lightgallery.min.css"><script src="//cdn.bootcss.com/jquery/2.1.0/jquery.min.js" type="text/javascript"></script><script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script><script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script><script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></head><body><div id="containerr"><header id="header" style="padding-top:15px"><div id="header-main" class="header-inner"><div class="outer"><a href="/" id="logo"><i class="logo"></i></a><nav id="main-nav"> <a class="main-nav-link" href="/index.html">Home</a> <a class="main-nav-link" href="/archives">Archive</a> <a class="main-nav-link" href="/categories">Category</a> <a class="main-nav-link" href="/tags">Tag</a> <a class="main-nav-link" href="/about">About</a> <a class="main-nav-link" href="/favorite">Photos</a></nav></div></div><div id="main-nav-mobile" class="header-sub header-inner"><table class="menu outer"><tr><td><a class="main-nav-link" href="/index.html">Home</a></td><td><a class="main-nav-link" href="/archives">Archive</a></td><td><a class="main-nav-link" href="/categories">Category</a></td><td><a class="main-nav-link" href="/tags">Tag</a></td><td><a class="main-nav-link" href="/about">About</a></td><td><a class="main-nav-link" href="/favorite">Photos</a></td><td><div class="search-form"> <input type="text" class="ins-search-input search-form-input" placeholder="Search"></div></td></tr></table></div></header><div class="outer"><aside id="profile"><div class="profile-inner"></div></aside><section id="main"><article id="post-Course1-V" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-inner" style="border-radius:1.5px;box-shadow:10px 10px 5px #ccc"> <a href="/2017/12/20/Course1-V/" itemprop="url"><img src="http://7xwggp.com1.z0.glb.clouddn.com/quicksort_algorithm.jpeg" class="article-banner"></a><header class="article-header"><center><h1 itemprop="name"> <a class="article-title" href="/2017/12/20/Course1-V/">Algorithm Specialization I-V QuickSort Algorithm</a></h1><div class="article-meta"><div class="article-date"> <a href="/2017/12/20/Course1-V/"><time datetime="2017-12-20T14:50:00.000Z" itemprop="datePublished">2017-12-20</time></a></div></div></center></header><div class="article-entry" itemprop="articleBody"><p></p><p>这一章节的课程主要是关于快速排序，它是一个经典的随机算法，会介绍伪码、如何以线性的时间以及最小的额外空间来围绕一个pivot对一个数组进行划分、不同pivot的选择对性能的影响以及阐述算法是如何运行的。</p><h2 id="Quick-Sort-overview-快速排序简介"><a href="#Quick-Sort-overview-快速排序简介" class="headerlink" title="Quick Sort overview / 快速排序简介"></a>Quick Sort overview / 快速排序简介</h2><blockquote><p>update：2017/12/19</p></blockquote><p>QuickSort快速排序是一个很经典、著名的算法，很实用，是由图灵奖获得者Hoare提出的，在现实应用中经常比Merge Sort更加高效。它是一个很巧妙的算法，它的代码言简意赅。可以通过数学分析来解释为什么Quick Sort可以运行得很快，它的平均运行时间是$O(nlogn)$。和Merge Sort不同的是，QuickSort直接在原始数组的位置上重复地进行swap操作，只需要很少的额外空间。</p><p>首先回顾一下排序问题，假设不包含重复数字：</p><ul><li>输入是包含n个无序数字的数组</li><li>输出是包含n个递增有序数字的数组</li></ul><p>QuickSort的关键子程序是“围绕一个pivot对数组进行划分”，即从数组中选择一个数字作为pivot(后面会介绍选择哪一个数字作为pivot)，然后把所有小于pivot的数字放置在pivot左边，所有大于pivot的数字放置在pivot右边，这样就把数组划分为两个bucket。如下图所示，选择第一个数字3作为pivot，重新排序数组，使得所有小于3的数字位于左边，所有大于3的数字位于右边。在这一阶段，不关注bucket内部是否是有序的。所以划分操作的直接目的是<strong>把pivot放置在正确的位置上</strong>，最终目的是排序。</p><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/pivot.png" alt=""></p><p>关于划分操作，有两个结论：</p><ol><li>这个操作的运行时间是线性的$O(n)$，且不需要额外的空间</li><li>这个操作减少了problem size，能够继续使用分治算法来进行排序</li></ol><p>最后介绍Quick Sort的整体处理流程，输入数组A以及长度n：</p><ol><li><p>如果数组A只包含一个元素，则直接返回</p></li><li><p>调用ChoosePivot(A，n)选择pivot p</p></li><li><p>以p为分界点将A进行划分，如下图所示，左半部分的元素都小于p，右半部分的元素都大于p</p><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/partition.png" alt=""></p></li><li><p>递归对左半部分子数组进行QuickSort</p></li><li><p>递归对右半部分子数组进行QuickSort</p></li></ol><p></p><p class="article-more-link"> <a href="/2017/12/20/Course1-V/#more">Read More</a></p><div class="article-tag"><i class="fa fa-tag"></i> <a class="tag-link" href="/tags/Algorithm-Specialization/">Algorithm Specialization</a>, <a class="tag-link" href="/tags/Course-I/">Course I</a></div><p></p></div></div></article><article id="post-Course1-IV" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-inner" style="border-radius:1.5px;box-shadow:10px 10px 5px #ccc"> <a href="/2017/12/19/Course1-IV/" itemprop="url"><img src="http://7xwggp.com1.z0.glb.clouddn.com/master2.png" class="article-banner"></a><header class="article-header"><center><h1 itemprop="name"> <a class="article-title" href="/2017/12/19/Course1-IV/">Algorithm Specialization I-IV The Master Method</a></h1><div class="article-meta"><div class="article-date"> <a href="/2017/12/19/Course1-IV/"><time datetime="2017-12-19T00:29:00.000Z" itemprop="datePublished">2017-12-19</time></a></div></div></center></header><div class="article-entry" itemprop="articleBody"><p></p><p>这一章节的课程主要介绍Master method，一种通用的分析分治算法运行时间的数学工具，先给出motivation，再介绍形式化描述，接着讲解6个示例，最后讨论Master method的证明。</p><h2 id="Motivation-动机"><a href="#Motivation-动机" class="headerlink" title="Motivation / 动机"></a>Motivation / 动机</h2><blockquote><p>update：2017/12/18</p></blockquote><p>潜在有用的算法通常需要数学分析来评估其性能，回顾小学时期的整数相乘算法使用$\Theta(n^2)$的运行时间来计算两个n位整数的乘积$x\times y$。递归算法是将x分解为$x=10^{\frac{1}{2}n}a+b$，将y分解为$y=10^{\frac{1}{2}n}c+d$，则$x\times y = 10^nac+10^{\frac{1}{2}n}(ad+bc)+bd$。即递归计算$ac,ad,bc,bd$的乘积即可。令T(n)表示计算两个n位整数乘积过程中操作的数量，基线条件是$T(1)\leq $常数，对于$n\geq 1$，有$T(n)\leq 4T(\frac{1}{2}n)+O(n)$。此外，一个更好的递归算法是减少一次递归调用，只计算ac,bd与(a+b)(c+d)，而ad+bc=(a+b)(c+d)-ac-bd。这样，对于$n\geq1$，有$T(n)\leq3T(\frac{1}{2}n)+O(n)$。</p><h2 id="Formal-statement-形式化叙述"><a href="#Formal-statement-形式化叙述" class="headerlink" title="Formal statement / 形式化叙述"></a>Formal statement / 形式化叙述</h2><blockquote><p>update：2017/12/18</p></blockquote><p>这一节课程视频主要介绍Master method的形式化叙述，可以理解为解决递归问题的一个black box，有一个前提假设，即所有的子问题拥有相同的size。其形式化表述如下：</p><ol><li><p>首先是基线条件Base Case：当n足够小时，T(n)为常数</p></li><li><p>通常递归调用的情况下，对于较大的n，假设有$T(n)\leq a\cdot T(\frac{n}{b})+O(n^d)$，其中a、b、d都是常数，与n大小无关</p><ul><li>a是递归调用的次数($\geq 1$)</li><li>b是输入大小收缩系数($&gt; 1$)</li><li>d是“合并阶段”运行时间的指数($\geq 0$)</li></ul><p>则有$ T(n)=\begin{cases}O(n^dlogn) &amp;a = b^d \ O(n^d) &amp; a &lt; b^d \\O(n^{log_ba}) &amp; a &gt; b^d \end{cases}​$</p><p>需要注意的是，当$a=b^d$时，big-O里面的log基数省略没写，这是因为基数具体为哪个值并不重要，不同基数带来的变化是常量级别的；而当$a&gt;b^d$时，由于log是在指数的位置，所以基数是哪个值就很重要了，不能忽略。</p></li></ol><h2 id="Examples-示例"><a href="#Examples-示例" class="headerlink" title="Examples / 示例"></a>Examples / 示例</h2><blockquote><p>update：2017/12/18</p></blockquote><p>这一节课程主要是利用6个具体示例来说明Master method。</p><h3 id="示例1：Merge-sort"><a href="#示例1：Merge-sort" class="headerlink" title="示例1：Merge sort"></a>示例1：Merge sort</h3><p>首先确定a、b、d的数值：</p><ul><li>a=2</li><li>b=2</li><li>d=1</li></ul><p>满足$a=b^d$，因此Merge sort的$T(n)=O(n^dlogn)=O(nlogn)$</p><h3 id="示例2：有序数组的二分查找"><a href="#示例2：有序数组的二分查找" class="headerlink" title="示例2：有序数组的二分查找"></a>示例2：有序数组的二分查找</h3><p>首先确定a、b、d的数值：</p><ul><li>a=1</li><li>b=2</li><li>d=0</li></ul><p>和Merge sort不同，只需要将要查找的数与中间元素比较，如果小于中间元素，则递归调用左半部分，否则调用右半部分，所以a的值为1；递归之外的操作就是元素的比较，因此d的值为0。由于满足$a=b^d$，因此有序数组的二分查找的$T(n)=O(n^dlogn)=O(logn)$</p><h3 id="示例3：整数相乘的递归算法I"><a href="#示例3：整数相乘的递归算法I" class="headerlink" title="示例3：整数相乘的递归算法I"></a>示例3：整数相乘的递归算法I</h3><p>首先确定a、b、d的数值：</p><ul><li>a=4</li><li>b=2</li><li>d=1</li></ul><p>整数相乘的基础递归算法总共有4次调用，所以a=4；每一次调用的整数位数是原来的一半，所以b=2；递归调用之外的加操作是线性的，所以d=1。由于满足$a&gt;b^d$，因此整数相乘的基础递归算法的$T(n)=O(n^{log_ba})=O(n^2)$</p><h3 id="示例4：整数相乘的递归算法II"><a href="#示例4：整数相乘的递归算法II" class="headerlink" title="示例4：整数相乘的递归算法II"></a>示例4：整数相乘的递归算法II</h3><p>首先确定a、b、d的数值：</p><ul><li>a=3</li><li>b=2</li><li>d=1</li></ul><p>整数相乘的改进递归算法总共有3次调用，所以a=3；每一次调用的整数位数是原来的一半，所以b=2；递归调用之外的加操作是线性的，所以d=1。由于满足$a&gt;b^d$，因此整数相乘的基础递归算法的$T(n)=O(n^{log_ba})=O(n^{log_23})=O(n^{1.59})$</p><h3 id="示例5：Strassen矩阵乘法"><a href="#示例5：Strassen矩阵乘法" class="headerlink" title="示例5：Strassen矩阵乘法"></a>示例5：Strassen矩阵乘法</h3><p>首先确定a、b、d的数值：</p><ul><li>a=7</li><li>b=2</li><li>d=2</li></ul><p>Strassen矩阵乘法是递归调用7次$P_1$~$P_7$加减操作，所以a=7；$P_1$~$P_7$子矩阵的规模是原始矩阵的一半，所以b=2；递归调用之外的加操作规模是子矩阵的大小，因此d=1。由于满足$a&gt;b^d$，因此整数相乘的基础递归算法的$T(n)=O(n^{log_ba})=O(n^{log_27})=O(n^{2.81})$</p><h3 id="示例6：Fictitious-recurrence-for-a-lt-b-d"><a href="#示例6：Fictitious-recurrence-for-a-lt-b-d" class="headerlink" title="示例6：Fictitious recurrence for $a&lt;b^d$"></a>示例6：Fictitious recurrence for $a&lt;b^d$</h3><p>假设a、b、d的数值：</p><ul><li>a=2</li><li>b=2</li><li>d=2</li></ul><p>由于满足$a&lt;b^d$，因此$T(n)=O(n^d)=O(n^2)$</p><p></p><p class="article-more-link"> <a href="/2017/12/19/Course1-IV/#more">Read More</a></p><div class="article-tag"><i class="fa fa-tag"></i> <a class="tag-link" href="/tags/Algorithm-Specialization/">Algorithm Specialization</a>, <a class="tag-link" href="/tags/Course-I/">Course I</a></div><p></p></div></div></article><article id="post-Course1-III" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-inner" style="border-radius:1.5px;box-shadow:10px 10px 5px #ccc"> <a href="/2017/12/18/Course1-III/" itemprop="url"><img src="http://7xwggp.com1.z0.glb.clouddn.com/recursive.png" class="article-banner"></a><header class="article-header"><center><h1 itemprop="name"> <a class="article-title" href="/2017/12/18/Course1-III/">Algorithm Specialization I-III Dive and Conquer Algorithms</a></h1><div class="article-meta"><div class="article-date"> <a href="/2017/12/18/Course1-III/"><time datetime="2017-12-18T09:05:00.000Z" itemprop="datePublished">2017-12-18</time></a></div></div></center></header><div class="article-entry" itemprop="articleBody"><p></p><p>这一章节的课程围绕Divide and conquer分治算法的思想，讨论三个比较有意思的例子，分别是：</p><ol><li>找出给定数组中的逆序对，这个问题和计算两个排名表的相似度有关，因此又与推荐算法中的协同过滤有关</li><li>矩阵乘法，利用Strassen提出的递归算法</li><li>在给定平面中找出最近点对，三个问题中最具挑战性的一个</li></ol><h2 id="Counting-inversions-I-统计逆序对I"><a href="#Counting-inversions-I-统计逆序对I" class="headerlink" title="Counting inversions I/ 统计逆序对I"></a>Counting inversions I/ 统计逆序对I</h2><blockquote><p>update：2017/12/12</p></blockquote><p>这节课的视频复习了分治思想的paradigm，即先将大问题分解为小问题，再递归求解小问题，最后合并每个小问题的求解结果。此外，继续给出一个具体的问题：找出一个数组中所有的逆序对。逆序对的定义是：数据对(i,j)，使得$i<j $且$a[i]>A[j]$。给定输入数组[1,3,5,2,4,6]，可以看出其中逆序对为(3,2)，(5,2)和(5,4)。可以通过如右图所示的连线方法来求解逆序对的数量，第一行是有序，第二行是原序，将数字相同的连接起来，则交叉点的数量就是逆序对的个数。有个题外话，为什么要计算逆序对？其实它的应用场景可以是两个排名list的相似度计算，比如协同过滤。</j></p><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/inversions.png" alt=""></p><p>逆序对求解，这里只讲两种方法，暴力求解与分治求解。</p><ol><li><p>暴力求解：直接嵌套循环，逐个判断，时间复杂度是$O(n^2)$</p></li><li><p>递归求解：先定义inversion，分为三种，如下图所示。求解过程就是先递归对左半数组求解left inversion的数量x，再递归对右半数组求解right inversion的数量y，然后求解split inversion的数量z，最后返回$x+y+z$之和就是最终结果了。这节课视频暂时没有讲解计算split inversion的实现，但是目标是以线性时间的复杂度$O(n)$来实现。</p><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/inversions_type.png" alt=""></p></li></ol><h2 id="Counting-inversions-II-统计逆序-II"><a href="#Counting-inversions-II-统计逆序-II" class="headerlink" title="Counting inversions II/ 统计逆序 II"></a>Counting inversions II/ 统计逆序 II</h2><blockquote><p>update：2017/12/13</p></blockquote><p>这一节课的视频主要解决上一个视频中遗留下来的问题，即如何统计split inversions。关键点在于利用Merge sort的思路，在递归调用时，除了统计左右半数组的left inversion和right inversion外，还需要顺便对左右半数据进行排序。这就是在递归时多做一点工作来简化split inversion的统计。为什么这么做呢？因为可以发现Merge sort的merge步骤可以自然地用来统计split inversion数量。</p><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/sort_and_count.png" alt=""></p><p>如果左半数组B中的所有元素都小于右半数组C中的元素，那么split inversion的个数就是0。按照下图所示的merge操作，可以总结出一个结论，如果右半数组中的元素y比左半数组中的某个元素x小，则x之后剩余的所有元素都能和y组成逆序对。这是显然的，因为左右半数组前提已经是有序的了。这个统计split inversion的运行时间也是线性的，因为前面的课程已经分析了merge操作是$O(n)$，统计求和本身也是$O(n)$，则$O(n)+O(n)=O(n)$。递归调用和Merge sort一样，则找出数组中的逆序对，这个问题的总运行时间是$O(n\cdot log n)$。</p><p></p><p class="article-more-link"> <a href="/2017/12/18/Course1-III/#more">Read More</a></p><div class="article-tag"><i class="fa fa-tag"></i> <a class="tag-link" href="/tags/Algorithm-Specialization/">Algorithm Specialization</a>, <a class="tag-link" href="/tags/Course-I/">Course I</a></div><p></p></div></div></article><article id="post-Assignment1" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-inner" style="border-radius:1.5px;box-shadow:10px 10px 5px #ccc"> <a href="/2017/12/12/Assignment1/" itemprop="url"><img src="http://7xwggp.com1.z0.glb.clouddn.com/assignment1.png" class="article-banner"></a><header class="article-header"><center><h1 itemprop="name"> <a class="article-title" href="/2017/12/12/Assignment1/">Algorithm专项课程—Problem Sets and Programming Assignments</a></h1><div class="article-meta"><div class="article-date"> <a href="/2017/12/12/Assignment1/"><time datetime="2017-12-12T11:00:00.000Z" itemprop="datePublished">2017-12-12</time></a></div></div></center></header><div class="article-entry" itemprop="articleBody"><p></p><h2 id="Problems-set"><a href="#Problems-set" class="headerlink" title="Problems set"></a>Problems set</h2><ol><li><p>3-way-Merge Sort : Suppose that instead of dividing in half at each step of Merge Sort, you divide into thirds, sort each third, and finally combine all of them using a three-way merge subroutine. What is the overall asymptotic running time of this algorithm? (Hint: Note that the merge step can still be implemented in O(n) time.)</p><ul><li style="list-style:none"><input type="checkbox" checked="checked"> $n log (n)$</li><li style="list-style:none"><input type="checkbox"> $n(log(n))^2$</li><li style="list-style:none"><input type="checkbox"> $n^2log(n)$</li><li style="list-style:none"><input type="checkbox"> n</li></ul><p>这道题是问如果Merge sort每次是把一个数组划分成三个部分，那么运行时间复杂度是多少。尽管是每个大问题划分成三个小问题，但是反映到recursion tree上，树的深度依旧是logarithmic，且每一层的merge操作的运行时间依旧是线性的，所以最终的复杂度仍然是$O(nlog(n))$。</p></li><li><p>You are given functions f and g such that $f(n)=O(g(n))$. Is $f(n)\cdot log_2(f(n)^c)=O(g(n)\cdot log_2(g(n))) $? (Here c is some positive constant.) You should assume that f and g are nondecreasing and always bigger than 1.</p><ul><li style="list-style:none"><input type="checkbox" checked="checked"> True</li><li style="list-style:none"><input type="checkbox"> False</li><li style="list-style:none"><input type="checkbox"> Sometimes yes, sometimes no, depending on the constant $c$</li><li style="list-style:none"><input type="checkbox"> Sometimes yes, sometimes no, depending on the function $f$ and $g$</li></ul><p>这道题是问如果函数$f$与$g$满足$f(n)=O(g(n))$，那么$f(n)\cdot log_2(f(n)^c)=O(g(n)\cdot log_2(g(n))) $是否成立。根据条件可知，存在$c_1，n_0$使得当$n\geq n_0$时有$f(n)\leq c_1\cdot g(n)$。假设所问结论成立，则存在$c_2，n_0$使得当$n\geq n_0$时有$f(n)\cdot log_2(f(n)^c)=O(g(n)\cdot log_2(g(n)))$，即$f(n)\cdot log_2(f(n)^c)=c_2\cdot g(n)\cdot log_2(g(n))$，化简规约一下，$c\cdot f(n)\cdot log_2(f(n))=c_2\cdot g(n)\cdot log_2(g(n))$，将$f(n)\leq c_1\cdot g(n)$代入，显然是可以成立的</p></li><li><p>Assume again two (positive) nondecreasing functions f and gsuch that $f(n)=O(g(n))$. Is $2^{f(n)}=O(2^{g(n)})$ ? (Multiple answers may be correct, you should check all of those that apply.)</p><ul><li style="list-style:none"><input type="checkbox"> Always</li><li style="list-style:none"><input type="checkbox"> Never</li><li style="list-style:none"><input type="checkbox" checked="checked"> Sometimes yes, sometimes no (depending on $f$ and $g$)</li><li style="list-style:none"><input type="checkbox" checked="checked"> Yes if $f(n)\leq g(n)$ for all sufficiently large $n$</li></ul><p>这道题是问如果函数$f$与$g$满足$f(n)=O(g(n))$，那么 $2^{f(n)}=O(2^{g(n)})$ 是否成立。我们可以通过一些特殊的例子来解答。</p><ul><li>假设$f(n)=g(n)=n$，这种情况下，$2^n=O(2^n)$是显然成立的</li><li>假设$f(n)=10n，g(n)=n$，这种情况下，显然有$2^{10n}\neq O(2^n)$，这个在Course2课程的案例中介绍过证明</li></ul><p>综上所述，这个结论不总是对的，也不总是错的。</p></li><li><p>k-way-Merge Sort. Suppose you are given $k$ sorted arrays, each with $n$ elements, and you want to combine them into a single array of $kn$ elements. Consider the following approach. Using the merge subroutine taught in lecture, you merge the first 2 arrays, then merge the $3^{rd}$ given array with this merged version of the first two arrays, then merge the $4^{th}$ given array with the merged version of the first three arrays, and so on until you merge in the final ($k^{th}$) input array. What is the running time taken by this successive merging algorithm, as a function of $k$ and $n$? (Optional: can you think of a faster way to do the k-way merge procedure ?)</p><ul><li style="list-style:none"><input type="checkbox"> $\Theta(nlog(k))$</li><li style="list-style:none"><input type="checkbox" checked="checked"> $\Theta(nk^2)$</li><li style="list-style:none"><input type="checkbox"> $\Theta(n^2k)$</li><li style="list-style:none"><input type="checkbox"> $\Theta(nk)$</li></ul><p>这道题是问在k-way归并排序中，如果给定k个有序数组，每个数组有n个元素，现在要将它们合并成一个包含$kn$个元素的大数组，归并操作如下：首先归并前两个数组，得到的新数组继续和第三个数组合并，依此类推。问这个连续的归并操作的运行时间复杂度是多少。每次归并操作都是线性时间$O(kn)$的，且有k次归并，因此上界的时间复杂度是$O(k^2n)$。对于下界，每次至少有$\frac{1}{2}k$个元素参与合并，因此下界运行时间是$\Omega(nk^2)$。综上所述，运行时间满足$\Theta(nk^2)$</p></li><li><p>Arrange the following functions in increasing order of growth rate (with g(n) following $f(n)$ in your list if and only if $f(n)=O(g(n)))$.</p><p>a) $\sqrt n$</p><p>b)10n</p><p>c) $n^{1.5}$</p><p>d)$2^{\sqrt log(n)}$</p><p>e)$n^{\frac{5}{3}}$</p><p>这道题是要求把以下五个函数按照增长率由小到大排序。答案是$2^{\sqrt log(n)} \leq \sqrt n \leq n^{1.5} \leq n^{\frac{5}{3}} \leq 10^n$。前面两个的证明可以是左右两边同时去对数。后面几个显然成立。</p></li></ol><p></p><p class="article-more-link"> <a href="/2017/12/12/Assignment1/#more">Read More</a></p><div class="article-tag"><i class="fa fa-tag"></i> <a class="tag-link" href="/tags/Algorithm-Specialization/">Algorithm Specialization</a></div><p></p></div></div></article><article id="post-Course1-II" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-inner" style="border-radius:1.5px;box-shadow:10px 10px 5px #ccc"> <a href="/2017/12/12/Course1-II/" itemprop="url"><img src="http://7xwggp.com1.z0.glb.clouddn.com/course2.jpg" class="article-banner"></a><header class="article-header"><center><h1 itemprop="name"> <a class="article-title" href="/2017/12/12/Course1-II/">Algorithm Specialization I-II Asymptotic Analysis</a></h1><div class="article-meta"><div class="article-date"> <a href="/2017/12/12/Course1-II/"><time datetime="2017-12-12T10:55:00.000Z" itemprop="datePublished">2017-12-12</time></a></div></div></center></header><div class="article-entry" itemprop="articleBody"><p></p><h2 id="The-gist-要旨"><a href="#The-gist-要旨" class="headerlink" title="The gist / 要旨"></a>The gist / 要旨</h2><blockquote><p>update：2017/12/11</p></blockquote><p>Asymptotic analysis是设计和分析算法的vocabulary，比如大O表示法：</p><ul><li>从较高的层次分析算法的sweet spot</li><li>足够coarse来压缩依赖于系统/编程语言/编译器的细节</li><li>足够sharp来进行不同算法之间的有效对比，尤其是针对大规模输入集</li></ul><p>High-level Idea：比如$6\cdot n\cdot log_2n$== $n\cdot log n$，也就是说运行时间是$O(n\cdot log n)$</p><ol><li>压缩常数因子：依赖于系统/编程语言/编译器等</li><li>压缩低阶因子：与输入规模的增大无关</li></ol><p>举了四个例子：</p><ol><li>判断数组A中是否包含给定的整数t，$O(n)$</li><li>判断数组A或者B中是否包含给定的整数t，$2\cdot n = O(n)​$</li><li>判断数组A和B中是否包含相同的整数，$O(n^2)$</li><li>判断数组A中是否包含重复的整数，$\frac{1}{2}n\cdot (n+1) = O(n^2)$</li></ol><h2 id="Big-Oh-notation-大O表示法"><a href="#Big-Oh-notation-大O表示法" class="headerlink" title="Big-Oh notation / 大O表示法"></a>Big-Oh notation / 大O表示法</h2><blockquote><p>update：2017/12/11</p></blockquote><p>这一节课讲解大O表示法的定义。令T(n)是n的函数f(n)，通常表示一个算法的worst case运行时间，那么问题是：什么时候$T(n)=O(f(n))$？答案是，当n足够大，最终T(n)的上限是一个常数与f(n)的乘积。下图所示，给出形式化定义：</p><p>当存在常数c和$n_0$，对于所有的$n\geq n_0$，有$T(n)\leq c\cdot f(n)$，则称$T(n) = O(f(n))$。其中，常数c和$n_0$与n无关。<br></p><p class="article-more-link"> <a href="/2017/12/12/Course1-II/#more">Read More</a></p><div class="article-tag"><i class="fa fa-tag"></i> <a class="tag-link" href="/tags/Algorithm-Specialization/">Algorithm Specialization</a>, <a class="tag-link" href="/tags/Course-I/">Course I</a></div><p></p></div></div></article><nav id="page-nav"> <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a></nav></section></div><div style="height:10px;pistion:absolute;bottom:0"></div><footer id="footer"><div class="outer"><div id="search-form-wrap"><form class="search-form"> <input type="text" class="ins-search-input search-form-input" placeholder="Search"> <button type="submit" class="search-form-submit"></button></form><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"> <input type="text" class="ins-search-input" placeholder="Type something..."><span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)"},ROOT_URL:"/",CONTENT_URL:"/content.json"}</script><script src="/js/insight.js"></script></div><div id="footer-info" class="inner"> &copy; 2017<i class="fa fa-heart blink-slow"></i> Tankcat<br> Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme by <a href="http://github.com/ppoffice">PPOffice</a></div></div></footer><div id="container"></div><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var gitment=new Gitment({id:"",owner:"tankcat",repo:"tankcat.github.io",oauth:{client_id:"60fb85b01453b027d1f5",client_secret:"4d0e75031ae53e76418d288b34897a8718481fd2"}});gitment.render("comments")</script><script src="/vendor/lightgallery/js/lightgallery.min.js"></script><script src="/vendor/lightgallery/js/lg-thumbnail.min.js"></script><script src="/vendor/lightgallery/js/lg-pager.min.js"></script><script src="/vendor/lightgallery/js/lg-autoplay.min.js"></script><script src="/vendor/lightgallery/js/lg-fullscreen.min.js"></script><script src="/vendor/lightgallery/js/lg-zoom.min.js"></script><script src="/vendor/lightgallery/js/lg-hash.min.js"></script><script src="/vendor/lightgallery/js/lg-share.min.js"></script><script src="/vendor/lightgallery/js/lg-video.min.js"></script><script src="/js/main.js"></script></div><script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script><script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"></script></body></html>