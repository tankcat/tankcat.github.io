<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tankcat</title>
  
  <subtitle>I&#39;ll try anything once...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://tankcat2.com/"/>
  <updated>2017-08-21T14:25:40.000Z</updated>
  <id>http://tankcat2.com/</id>
  
  <author>
    <name>Tankcat</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>鼓楼半日记</title>
    <link href="http://tankcat2.com/2017/08/15/gulou/"/>
    <id>http://tankcat2.com/2017/08/15/gulou/</id>
    <published>2017-08-15T12:11:31.000Z</published>
    <updated>2017-08-21T14:25:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天跟着zf去鼓楼的办公室，发现大门口右手边就是云南路地铁站口，右拐过去就是上海路。想到小厨娘就在附近，决定扔下zf一个人去买蛋糕。不知道怎么想的，可能天不热，没骑车步行过去的。以前步行只知道跟着导航急匆匆地赶到目的地，不在意沿途的风景。今天边走变看，走着走着就看到了最喜欢吃的朱师傅梅花糕。以前领过很多人来吃，都是跟着导航走，今天无意间走到，感觉很奇妙。上海路起起伏伏，回来骑车的时候感觉更明显。从上海路拐进广州路，人越来越多，后来发现是到了儿童医院。最后终于找到小厨娘，被告知想吃的抹茶盒子下午两点才有，说好的要芒果班戟，回来一吃发现拿的是榴莲。</p><p>快到办公室的时候开始下雷阵雨，快去跑回去，没过一会儿雨就停了。两个人中午商量着吃什么，其实这个商圈好吃的很多，韩料啦，串串啦，西餐啦，大众点评上好多评分高的店铺。但是雨停了之后太阳出来了，有点热，两个人都不太想吃辣的，于是就索性吃了鸡鸣汤包。上次去还是清明节。去的路上无意间看到一家小咖啡店，发现店家品味跟我一样哈，竟然想起来用伊索的瓶子插花。<br><a id="more"></a><br><img src="http://7xwggp.com1.z0.glb.clouddn.com/yisuo.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天跟着zf去鼓楼的办公室，发现大门口右手边就是云南路地铁站口，右拐过去就是上海路。想到小厨娘就在附近，决定扔下zf一个人去买蛋糕。不知道怎么想的，可能天不热，没骑车步行过去的。以前步行只知道跟着导航急匆匆地赶到目的地，不在意沿途的风景。今天边走变看，走着走着就看到了最喜欢吃的朱师傅梅花糕。以前领过很多人来吃，都是跟着导航走，今天无意间走到，感觉很奇妙。上海路起起伏伏，回来骑车的时候感觉更明显。从上海路拐进广州路，人越来越多，后来发现是到了儿童医院。最后终于找到小厨娘，被告知想吃的抹茶盒子下午两点才有，说好的要芒果班戟，回来一吃发现拿的是榴莲。&lt;/p&gt;
&lt;p&gt;快到办公室的时候开始下雷阵雨，快去跑回去，没过一会儿雨就停了。两个人中午商量着吃什么，其实这个商圈好吃的很多，韩料啦，串串啦，西餐啦，大众点评上好多评分高的店铺。但是雨停了之后太阳出来了，有点热，两个人都不太想吃辣的，于是就索性吃了鸡鸣汤包。上次去还是清明节。去的路上无意间看到一家小咖啡店，发现店家品味跟我一样哈，竟然想起来用伊索的瓶子插花。&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://tankcat2.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>Tragic Ending or Peace Ending ?</title>
    <link href="http://tankcat2.com/2017/07/21/my%20chester/"/>
    <id>http://tankcat2.com/2017/07/21/my chester/</id>
    <published>2017-07-20T16:00:00.000Z</published>
    <updated>2017-07-21T01:44:52.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>那个一直嘶吼的他走了，在很多人的青春中躁动的声音消失了，这个世界总是留不住想要留住的人….</p></blockquote><p>收拾好准备出宿舍门的时候，打开朋友圈，看到有好友转发西菇自杀了，晴天霹雳。</p><p>各大媒体、社交平台都开始报道这个消息，朋友圈也开始各种转发，大家明明都还沉浸在新收到的新单mv的推送中，可他就这么离开了。</p><p>有的人可能只知道lol登陆界面上的numb，有的人可能是变形金刚的bgm what i’ve done，new divide和iridescent而知道linkin park，有的人可能是因为今天的朋友圈被告知有个乐队的主场自杀了。高三一次月考作文我就以西菇为题材，写了他从悲惨的童年到获得如今的成就，写了他的纹身，他的耳洞，他的嗓音转变，他的专辑，他的这条路到底是有多心酸、坚强与挣扎。他的作品获得了无数粉丝的喜爱，无疑他的作品来源于悲惨的童年经历，但这段经历如今又带走了他的生命，这些因果到底是矛盾的。</p><p>西菇的自杀让我想到台湾女作家林奕含，一样是童年被x侵，一样是在作品中透露出自己的无奈和无助，他们感受到的痛苦是真真切切的。可能在挣扎中想要积极向上，也确实创造了许多作品激励并拯救了许多同样饱受苦痛折磨的人，但喧嚣与欢乐始终都是别人的，音乐只是病痛的舒缓剂，不是所有的经历都能云淡风轻地过去，有些事每每回想，总是锥心地痛一次。时间不是万能的，抑郁的人自杀也不是矫情。</p><p>他的死对至亲和粉丝来说无疑是悲惨的结局，但他的前半生可能一直在寻找somewhere i belong，而今日凌晨，他找到了。</p><p>I wanna let go of the pain I’ve felt so long…</p><p>somewhere i belong…</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;那个一直嘶吼的他走了，在很多人的青春中躁动的声音消失了，这个世界总是留不住想要留住的人….&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;收拾好准备出宿舍门的时候，打开朋友圈，看到有好友转发西菇自杀了，晴天霹雳。&lt;/p&gt;
&lt;p&gt;各大媒体、社交平台都开始报道这个消息，朋友圈也开始各种转发，大家明明都还沉浸在新收到的新单mv的推送中，可他就这么离开了。&lt;/p&gt;
&lt;p&gt;有的人可能只知道lol登陆界面上的numb，有的人可能是变形金刚的bgm what i’ve done，new divide和iridescent而知道linkin park，有的人可能是因为今天的朋友圈被告知有个乐队的主场自杀了。高三一次月考作文我就以西菇为题材，写了他从悲惨的童年到获得如今的成就，写了他的纹身，他的耳洞，他的嗓音转变，他的专辑，他的这条路到底是有多心酸、坚强与挣扎。他的作品获得了无数粉丝的喜爱，无疑他的作品来源于悲惨的童年经历，但这段经历如今又带走了他的生命，这些因果到底是矛盾的。&lt;/p&gt;
&lt;p&gt;西菇的自杀让我想到台湾女作家林奕含，一样是童年被x侵，一样是在作品中透露出自己的无奈和无助，他们感受到的痛苦是真真切切的。可能在挣扎中想要积极向上，也确实创造了许多作品激励并拯救了许多同样饱受苦痛折磨的人，但喧嚣与欢乐始终都是别人的，音乐只是病痛的舒缓剂，不是所有的经历都能云淡风轻地过去，有些事每每回想，总是锥心地痛一次。时间不是万能的，抑郁的人自杀也不是矫情。&lt;/p&gt;
&lt;p&gt;他的死对至亲和粉丝来说无疑是悲惨的结局，但他的前半生可能一直在寻找somewhere i belong，而今日凌晨，他找到了。&lt;/p&gt;
&lt;p&gt;I wanna let go of the pain I’ve felt so long…&lt;/p&gt;
&lt;p&gt;somewhere i belong…&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://tankcat2.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Linkin Park" scheme="http://tankcat2.com/tags/Linkin-Park/"/>
    
      <category term="Chester Bennington" scheme="http://tankcat2.com/tags/Chester-Bennington/"/>
    
  </entry>
  
  <entry>
    <title>Storm的容错</title>
    <link href="http://tankcat2.com/2017/07/19/fault%20tolerance%20of%20storm/"/>
    <id>http://tankcat2.com/2017/07/19/fault tolerance of storm/</id>
    <published>2017-07-18T16:00:00.000Z</published>
    <updated>2017-07-20T00:44:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="当某个worker失效时"><a href="#当某个worker失效时" class="headerlink" title="当某个worker失效时"></a>当某个worker失效时</h2><p>当某个worker失效时，Supervisor会将这个worker重启。如果在重启的过程中，这个worker不停地失效，并且不能向Nimbus汇报心跳，那么Nimbus会将这个worker重新分配到其他的机器。</p><h2 id="当某个node失效时"><a href="#当某个node失效时" class="headerlink" title="当某个node失效时"></a>当某个node失效时</h2><p>当某个node(物理节点)失效时，该node上的所有task都将超时，Nimbus会把这些task重新分配到其他的node上。</p><h2 id="当Nimbus或者Supervisor守护进程失效时"><a href="#当Nimbus或者Supervisor守护进程失效时" class="headerlink" title="当Nimbus或者Supervisor守护进程失效时"></a>当Nimbus或者Supervisor守护进程失效时</h2><p>Nimbus和Supervisor的守护进程都是快速失败和无状态的，无论何时当发生意想不到的情况时，进程会自行终止，所有的状态信息都是存储在Zookeeper或者磁盘上。Nimbus和Supervisor的守护进程必须在监视器或虚拟光驱的监督下允许，所以一旦守护进程失效，就会立刻被重启。</p><p>ps: 守护进程是指一直在后台运行，且不受任何终端控制的进程，用于执行特点的系统任务。</p><h2 id="Nimbus是否是单点失效"><a href="#Nimbus是否是单点失效" class="headerlink" title="Nimbus是否是单点失效"></a>Nimbus是否是单点失效</h2><p>如果Nimbus所在的node失效，worker进行将继续运行；若worker失效，Supervisor也会继续对它们进行重启。但是没有Nimbus，在必要的时候worker不能被重新分配到其他的node。</p><a id="more"></a><h2 id="Storm如何保证消息的可靠性处理"><a href="#Storm如何保证消息的可靠性处理" class="headerlink" title="Storm如何保证消息的可靠性处理"></a>Storm如何保证消息的可靠性处理</h2><p>Storm提供了某些机制来保证消息的可靠性处理，即使存在node失效或者信息丢失，包括“尽力服务best effort”、“至少处理一次at least once”和“只处理一次exactly once”。下面讲讲Storm是如何保证数据至少处理一次的。</p><h3 id="消息被“完全处理fully-processed”是什么意思"><a href="#消息被“完全处理fully-processed”是什么意思" class="headerlink" title="消息被“完全处理fully processed”是什么意思"></a>消息被“完全处理fully processed”是什么意思</h3><p>从spout发出的一个tuple可能会触发成千上万个tuple的创建。结合下面这个例子考虑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TopologyBuilder builder = <span class="keyword">new</span> TopologyBuilder();</span><br><span class="line">builder.setSpout(<span class="string">"sentences"</span>, <span class="keyword">new</span> KestrelSpout(<span class="string">"kestrel.backtype.com"</span>, <span class="number">22133</span>, <span class="string">"sentence_queue"</span>, <span class="keyword">new</span> StringScheme()));</span><br><span class="line">builder.setBolt(<span class="string">"split"</span>, <span class="keyword">new</span> SplitSentence(), <span class="number">10</span>).shuffleGrouping(<span class="string">"sentences"</span>);</span><br><span class="line">builder.setBolt(<span class="string">"count"</span>, <span class="keyword">new</span> WordCount(), <span class="number">20</span>).fieldGrouping(<span class="string">"split"</span>, <span class="keyword">new</span> Fields(<span class="string">"word"</span>));</span><br></pre></td></tr></table></figure><p>这个topology从一个Kestrel队列中读取sentence，将sentence划分成若干个word，接着将每个word和该word出现的次数发送给下一个bolt。这种情况下“从spout发出的一个tuple可能会触发成千上万个tuple的创建”：sentence中的每次word对应的tuple和携带有计数的word对应的tuple。构成的消息树如下所示：</p><p><img src="http://storm.apache.org/releases/current/images/tuple_tree.png" alt=""></p><p>如果这棵tuple树发送完成，并且树中的每一条消息都被正确地处理，那么就认为从spout发出的tuple被“完全处理”了。若某个tuple的消息树在给定的时间内没有被完全处理，那么就认为这个tuple失效了。这个超时的时间可以在构建topology时通过参数<code>Config.TOPOLOGY_MESSAGE_TIMEOUT_SECS</code>来配置，默认值为30秒。</p><h3 id="消息被完全处理或处理失败后会发生什么"><a href="#消息被完全处理或处理失败后会发生什么" class="headerlink" title="消息被完全处理或处理失败后会发生什么"></a>消息被完全处理或处理失败后会发生什么</h3><p>为了理解这个问题，我们先回顾一下从spout发出的tuple的生命周期。下面给出spout的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ISpout</span> <span class="keyword">extends</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">(Map conf, TopologyContext context, SpoutOutputCollector collector)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">nextTuple</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">ack</span><span class="params">(Object msgId)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fail</span><span class="params">(Object msgId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，通过调用Spout的<code>nextTuple()</code>方法，Storm向Spout请求一个tuple。Spout使用<code>open()</code>方法中的<code>SpoutOutputCollector</code>向它的一个输出流中发送一个tuple。在发送时，Spout会为每个tuple提供一个”消息id”，用来在后面的处理过程中识别tuple。例如，<code>KestrelSpout</code>从kestrel队列中读取一条消息，然后发送一条带有“消息id”的消息，这个消息id是由Kestrel提供的。使用<code>SpoutOutputCollector</code>发送消息一般是这样的形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_collector.emit(<span class="keyword">new</span> Values(<span class="string">"field1"</span>, <span class="string">"fields2"</span>, <span class="number">3</span>),msgId);</span><br></pre></td></tr></table></figure><p>接着，tuple会被发送到下游的消费bolt，Storm会追踪其创建的消息树。如果检测到某个tuple被完全处理了，根据消息id，Storm调用最初发送该tuple的Spout任务的<code>ack()</code>方法。类似地，若该tuple超时了，Storm会调用<code>fail()</code>方法。需要注意的是，对于每个tuple，响应ack和失败处理fail只会由最初创建这个tuple的Spout任务执行。换言之，在整个集群中，若Spout存在多个实例，但是tuple只会被创建它的那个Spout任务实例响应或者失效处理。</p><p>再以KestrelSpout为例来看看Spout需要进行哪些操作来保证消息的可靠性处理。当kestrelSpout从kestrel队列中读取一条消息时，可以看作是它“打开”了这条消息。这意味着，消息并没有真正从队列中取出，而是被标记为“挂起”的状态，等待消息被完全处理的信号。在挂起状态时，消息不会被发送到其他消费者。此外，若消费者断开了连接，所有挂起的消息会被放回队列中。消息在打开时，Kestrel会为每个消息提供一个唯一的id。当把tuple发送给<code>SpoutOutputCollector</code>时，KestrelSpout用“消息id”作为tuple的唯一标识。一段时间后，当KestrelSpout中的<code>ack()</code>或者<code>fail()</code>被调用时，KestrelSpout会根据消息id向Kestrel请求将消息从队列中移除(ack)，或者将消息重新放回队列中(fail)。</p><h3 id="Storm的可靠性API"><a href="#Storm的可靠性API" class="headerlink" title="Storm的可靠性API"></a>Storm的可靠性API</h3><p>使用Storm的可靠性机制时需要注意两点：第一，在tuple树上创建新的连接时需要通知Storm；第二，当处理完每个tuple时需要通知Storm。通过以上两点操作，Storm可以检测到tuple树何时被完全处理，并在适当的时候调用ack和fail。Storm API以一种非常精确的方式来实现这两个操作。</p><p>在tuple树上指定一个连接的操作称为<code>锚定anchoring</code>。当发送一个新的tuple时进行锚定。让我们用下面这个bolt为例，该bolt将包含sentence的tuple分割成若干包含word的tuple：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SplitSentence</span> <span class="keyword">extends</span> <span class="title">BaseRichBolt</span></span>&#123;</span><br><span class="line">  OutputCollector _collector;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(Map conf, TopologyContext context, OutputCollector collector)</span></span>&#123;</span><br><span class="line">    _collector = collector;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple tuple)</span></span>&#123;</span><br><span class="line">    String sentence = tuple.getString(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(String word : sentence.split(<span class="string">" "</span>))&#123;</span><br><span class="line">          _collector.emit(tuple, <span class="keyword">new</span> Values(word));</span><br><span class="line">    &#125;</span><br><span class="line">    _collector.ack(tuple);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer declarer)</span></span>&#123;</span><br><span class="line">    declarer.declare(<span class="keyword">new</span> Fields(<span class="string">"word"</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过将输入tuple指定为<code>emit()</code>的第一个参数对每个单词对应的tuple进行锚定。这样，在下游的后续处理中若该tuple处理失败了，位于tuple树根节点的spout tuple就会被重新处理。相应地，如果按照下面的方法发送tuple：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_collector.emit(<span class="keyword">new</span> Values(word));</span><br></pre></td></tr></table></figure><p>这种方式被称为“非锚定”。在这种情况下，下游的tuple处理失败不会触发根节点tuple的重新处理。但这种非锚定的发送在某些场合下也是合适的，这取决于我们对topology的容错要求。</p><p>一个输出的tuple可以被锚定到多个输入tuple。这在数据流连接或者聚合操作时很有用。一个失败的多锚定的tuple会导致spout中多个tuple被重新处理。多锚定是通过指定一个tuple列表，而不是单一的tuple，来实现的，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Tuple&gt; anchors = <span class="keyword">new</span> ArrayList&lt;Tuple&gt;();</span><br><span class="line">anchors.add(tuple1);</span><br><span class="line">anchors.add(tuple2);</span><br><span class="line">_collector.emit(anchors, <span class="keyword">new</span> Values(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br></pre></td></tr></table></figure><p>多锚定把输出tuple加入到多个tuple树中。需要注意的是，多锚定可能会破坏tuple树的结构，并创建tuple的有向无环图，如下所示：</p><p><img src="http://storm.apache.org/releases/current/images/tuple-dag.png" alt=""></p><p>Storm的实现既支持对tuple树的处理，也支持有向无环图的处理。</p><p>锚定就是如何把一个消息加入到指定的tuple树中——Storm可靠性处理API的接下来部分将具体说明何时完全处理完tuple树中的一个tuple。这是通过调用<code>OutputCollector</code>中的<code>ack()</code>和<code>fail()</code>方法实现的。回顾<code>SplitSentence</code>的例子，可以发现输入tuple是在左右单词tuple被发送出去之后被ack的。</p><p>我们可以使用<code>OutputCollector</code>的<code>fail()</code>方法使得位于tuple树根节点的spout tuple立即失效。比如，某个应用可能选择补货来自数据库客户端的一个异常，使得输入tuple立刻失效。通过这种方式，重新处理spout tuple就会比等待tuple超时更快。</p><p>处理的每个tuple都必须被ack或fail。Storm使用内存来追踪每个tuple，所以，如果不对其进行ack或者fail，负责追踪的任务很会就会发生内存溢出。</p><p>Bolt处理tuple的通用模式是：读取输入tuple，发送基于该tuple而生成的tuple，在<code>execute()</code>方法执行结束时ack输入tuple。大多数bolt都采取这样的处理方式。这些bolt大多属于过滤器或者简单的函数一类。Storm提供了接口<code>BasicBolt</code>涵盖了以上操作。例如，若使用BasicBolt，SplitSentence可以是如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SplitSentence</span> <span class="keyword">extends</span> <span class="title">BaseBasicBolt</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple tuple, BasicOutputCollector collector)</span></span>&#123;</span><br><span class="line">      String sentence = tuple.getString(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">for</span>(String word : sentence.split(<span class="string">" "</span>))&#123;</span><br><span class="line">          collector.emit(<span class="keyword">new</span> Values(word));</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer declarer)</span></span>&#123;</span><br><span class="line">      declarer.declare(<span class="keyword">new</span> Fields(<span class="string">"word"</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上这种实现方式比之前的方法要简单许多，并且在语义上可以达到相同的效果。发送给<code>BasicOutputCollector</code>的tuple被自动锚定到输入tuple，并且在<code>execute()</code>执行结束后会自动ack输入tuple。</p><p>相反，做连接或者聚合操作的bolt可能需要推迟ack，直到一批tuple完成了某种计算结果。聚合和连接操作一般也需要对输出tuple进行多锚定。这个操作超出了<code>IBasicBolt</code>的应用范围。</p><h3 id="在tuple被重新处理时如何使得应用正确运行"><a href="#在tuple被重新处理时如何使得应用正确运行" class="headerlink" title="在tuple被重新处理时如何使得应用正确运行"></a>在tuple被重新处理时如何使得应用正确运行</h3><p>按照软件设计的一般思路，答案是“取决于实际情况”。如果想要保证计算过程都能满足恰好一次的语义，可以使用Trident API。在某些情况下，比如数据分析任务中，丢弃一些数据是可以接受的，因此通过将参数<code>Config.TOPOLOGY_ACKERS</code>置为0，使得acker bolt的数量为0，从而取消应用的容错性。但是在其他情况下，需要保证每个计算过程满足至少处理一次的语义，并且不允许丢弃任何数据。如果所有的操作都是idenpotent，或者未来会发生重复删除的操作，那么这将十分有用。(an indemponent operation is one that has no additional effect if it is called more than once with the same input paramenters).</p><h3 id="Storm是如何以一种高效的方式实现可靠性的"><a href="#Storm是如何以一种高效的方式实现可靠性的" class="headerlink" title="Storm是如何以一种高效的方式实现可靠性的"></a>Storm是如何以一种高效的方式实现可靠性的</h3><p>一个topology拥有一组特殊的acker任务，用来追踪每个spout tuple发出tuple的DAG。当一个acker发现一个DAG完成时，它会向创建该spout tuple的spout任务实例发送消息，让这个任务来ack消息。我们可以通过参数<code>Config.TOPOLOGY_ACKERS</code>来配置acker的数量，Storm默认值为1。</p><p>理解Storm可靠性实现的最好的方法是了解tuple和tuple DAG的生命周期。当一个tuple被创建时，无论是在spout还是bolt中，它被分配一个64位的id。这个id将被acker用来追踪每个spout tuple的tuple DAG。</p><p>当在bolt中发送一个新的tuple时，输入tuple 锚定的所有spout tuple的id将会被复制到新的tuple中。tuple被ack时，它会向适合的acker任务发送消息，通知如何修改tuple树。实际上，它通知acker的是“在这个spout tuple所在的tuple树中，我已经被完全处理了，这些是被锚定到我的新的tuple，需要加到这个树中”。</p><p>以下图为例，如果tuple D和 E是基于tuple C创造出来的，当C被ack时，tuple树需要做如下修改：</p><p><img src="http://storm.apache.org/releases/current/images/ack_tree.png" alt=""></p><p>由于C被移除的同时D和E被加进来，所以tuple树不会过早地结束。</p><p>关于Storm是如何跟踪tuple树还有许多细节，正如前面所说的，在一个topology中我们可以设置任意数量的acker，但这带来一个新的问题：当某个tuple被ack，它如何知晓让哪个acker来发送消息？</p><p>Storm使用哈希算法将spout tuple匹配到acker上。由于每个tuple携带了它所在tuple树的spout tuple的id，因此它们知道需要和哪个acker通信。</p><p>另一个细节问题是acker是如何知道它们追踪的spout tuple是来自哪个spout 任务的。实际上spout task在发送一个新的tuple时，它会向适合的acker发送一个简单的消息，通知它这个spout tuple是和自己的任务id相关联的。当acker发现某个tuple 树被完全处理了，它就知道需要向哪个task发送完成消息。</p><p>acker 实际上不会直接追踪tuple树。对于拥有成千上万个节点的tuple树而言，追踪整个树会消耗完所有的内存。相反，acker采用一种特殊的策略，只要占用固定的内存空间来追踪每个spout tuple，大概20字节。这个追踪算法是Storm运行的关键，也是突破技术之一。</p><p>一个acker存储了spout tuple id到一组值得映射表。 第一个值是创建这个spout tuple的task id号，用于后面发送完成信号。第二个值是一个称为“ack val”的64位数字。这个值代表了整个tuple树的状态，与树的大小无关。因为这个值仅仅是这个tuple树中所有被创建或者被ack的tuple的tuple id进行异或运算得到的结果值。</p><p>当一个acker发现ack val的值变为0时，它就知道tuple树被完全处理了。由于tuple id是一个随机的64位数字，因此ack val碰巧为0是一种极小概率的事件。理论计算可得，在每秒ack一万次的情况下，需要5000万年才会发生一次错误。而且即使是这样，也只会在tuple碰巧失败的时候才会发生数据丢失的情况。</p><p>假设现在我们已经理解了这个可靠性算法，让我们再分析一下所有失败的情况，看看这些情况下Storm是如何避免数据丢失的：</p><ul><li>task失效时tuple没被ack：在这种情况下，位于根节点的spout tuple会在任务超时后重新处理。</li><li>Acker进程失效：在这种情况下，acker追踪的所有spout tuple都会由于超时而被重新处理。</li><li>Spout进程失效：在这种情况下，Spout任务的来源会重新处理这些消息。举个例子，Kestrel和RabbitMQ之类的队列会将所有挂起的消息重新放回队列中。</li></ul><p>综上，Storm的可靠性机制是完全分布式的，可扩展的，且支持容错的。</p><h3 id="调整可靠性"><a href="#调整可靠性" class="headerlink" title="调整可靠性"></a>调整可靠性</h3><p>由于acker进程是轻量级的，所以在topology中不需要很多的ack任务。我们可以通过Storm UI来监控它们的性能，它们的任务id为<code>_acker</code>。如果发现观察结果存在问题，就需要增加更多的acker任务。</p><p>如果不关心可靠性，也就是说，不担心在失败的情形下发生tuple的丢失，那么可以通过不跟踪tuple树来提升topology的性能。由于tuple树中的每个tuple都会携带一个ack消息，不追踪tuple树会使得传输的消息数量减半。同时，下游数据流中的id也会变少，降低网络带宽的消耗。</p><p>有三种方法可以移除Storm的可靠性机制。第一种方法是将<code>Config.TOPOLOGY_ACKERS</code>的值设置为0，在这种情况下，Storm会在spout发送tuple之后立即调用ack，这样tuple树就不会被追踪了。</p><p>第二种方法是基于消息本身移除可靠性。我们可以通过在<code>SpoutOutputCollector.emit()</code>方法中省略消息id来关闭spout tuple的追踪功能。</p><p>最后，如果不关系topology下游的tuple是否会失败，可以在发送tuple时选择发送发送非锚定unanchored的tuple。由于这些tuple不会被锚定到到任何一个spout tuple，因此如果它们没有被ack，也不会导致spout tuple的重新处理。</p>]]></content>
    
    <summary type="html">
    
      这篇文章主要整理storm中的容错是如何实现的
    
    </summary>
    
      <category term="Storm学习之路" scheme="http://tankcat2.com/categories/Storm%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="storm" scheme="http://tankcat2.com/tags/storm/"/>
    
      <category term="容错" scheme="http://tankcat2.com/tags/%E5%AE%B9%E9%94%99/"/>
    
  </entry>
  
  <entry>
    <title>Storm UI详解</title>
    <link href="http://tankcat2.com/2017/05/22/storm_ui/"/>
    <id>http://tankcat2.com/2017/05/22/storm_ui/</id>
    <published>2017-05-22T08:32:31.000Z</published>
    <updated>2017-07-20T00:45:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xwggp.com1.z0.glb.clouddn.com/storm_ui_config_summary.png" alt=""></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xwggp.com1.z0.glb.clouddn.com/storm_ui_config_summary.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Storm学习之路" scheme="http://tankcat2.com/categories/Storm%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="storm" scheme="http://tankcat2.com/tags/storm/"/>
    
      <category term="storm ui" scheme="http://tankcat2.com/tags/storm-ui/"/>
    
  </entry>
  
  <entry>
    <title>Storm Kafka之KafkaSpout</title>
    <link href="http://tankcat2.com/2017/05/18/KafkaSpout/"/>
    <id>http://tankcat2.com/2017/05/18/KafkaSpout/</id>
    <published>2017-05-18T12:11:31.000Z</published>
    <updated>2017-07-20T00:46:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>storm-kafka-XXX.jar</code>提供了核心Storm与Trident的组件Spout的代码实现，用于消费Kafka中存储的数据(0.8.x之后的版本)。本文只介绍核心Storm的KafkaSpout。</p><p>对于核心Storm与Trident两个版本的Spout实现，提供了<code>BrokerHost</code>接口，跟踪Kafka broker host$\rightarrow$partition的映射，并提供<code>KafkaConfig</code>接口来控制Kafka相关的参数。下面就这以上两点进行讲解。</p><h3 id="BrokerHost"><a href="#BrokerHost" class="headerlink" title="BrokerHost"></a>BrokerHost</h3><p>为了对Kafka spout进行初始化，我们需要创建一个<code>BrokerHost</code>的实例，Storm共提供了两种实现方式：</p><ol><li><p>ZkHosts。ZkHosts使用Zookeeper的实体对象，可动态地追踪Kafka broker$\rightarrow$partition之间的映射，通过调用下面两种函数创建ZkHosts:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZkHosts</span><span class="params">(String brokerZkStr,String brokerZkPath)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZkHosts</span><span class="params">(String brokerZkStr)</span></span></span><br></pre></td></tr></table></figure><p>其中，<code>brokerZkStr</code>是<code>ip:host</code>(主机:端口)，<code>brokerZkPath</code>是存放所有topic和partition信息的根目录，默认值为<code>\broker</code>。默认地，Zookepper每60秒刷新一次broker$\rightarrow$partition，通过<code>host:refreshFreqSecs</code>可以改变这个时间。</p></li></ol><a id="more"></a><ol><li><p>StaticHosts。这是另一个选择，不过broker$\rightarrow$partition之间的映射关系是静态的，创建这个类的实例之前，需要首选创建<code>GlobalPartitionInformation</code>类的实例，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Broker brokerForPartition0 = <span class="keyword">new</span> Broker(<span class="string">"localhost"</span>);<span class="comment">//localhost:9092,端口号默认为9092</span></span><br><span class="line">Broker brokerForPartition1 = <span class="keyword">new</span> Broker(<span class="string">"localhost"</span>,<span class="number">9092</span>);<span class="comment">//localhost:9092,显示地指定端口号</span></span><br><span class="line">Broker brokerForPartition2 = <span class="keyword">new</span> Broker(<span class="string">"localhost:9092"</span>);</span><br><span class="line">GlobalPartitionInformation partitionInfo = <span class="keyword">new</span> GlobalPartitionInformation();</span><br><span class="line">partitionInfo.addPartition(<span class="number">0</span>, brokerFroPartition0);<span class="comment">// partition0 到 brokerForPartition0的映射</span></span><br><span class="line">partitionInfo.addPartition(<span class="number">1</span>, brokerFroPartition1);</span><br><span class="line">partitionInfo.addPartition(<span class="number">2</span>, brokerFroPartition2);</span><br><span class="line">StaticHosts hosts = <span class="keyword">new</span> StaticHosts(partitionInfo);</span><br></pre></td></tr></table></figure></li></ol><h3 id="KafkaConfig"><a href="#KafkaConfig" class="headerlink" title="KafkaConfig"></a>KafkaConfig</h3><p>创建KafkaSpout需要的另一个参数是<code>KafaConfig</code>，通过调用以下两个函数进行对象创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">KafkaConfig</span><span class="params">(BrokerHosts host,String topic)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">KafkaConfig</span><span class="params">(BrokerHosts host,String topic,String clientId)</span></span></span><br></pre></td></tr></table></figure><p>其中，<code>host</code>可以为BrokerHost的任何一种实现，<code>topic</code>是一个topic的名称，<code>clientId</code>是一个可选择的参数，作为Zookeeper路径的一部分，存储spout当前数据读取的offset。</p><p>目前，KafkaConfig有两种扩展形式，<code>SpoutcConfig</code>提供额外的Zookeeper连接的字段信息，用于控制KafkaSpout特定的行为。<code>zkRoot</code>用于存储consumer的offset，<code>id</code>用于唯一标识当前的spout。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpoutConfig</span><span class="params">(BrokerHosts hosts,String topic,String zkRoot,String id)</span></span></span><br></pre></td></tr></table></figure><p>除了以上参数，SpoutConfig包括如下的字段值，用来控制KafkaSpout：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将当前的offset保存到Zookeeper的频率</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">long</span> stateUpdateIntervals = <span class="number">2000</span>;</span><br><span class="line"><span class="comment">//用于失效消息的重试策略</span></span><br><span class="line"><span class="keyword">public</span> String failedMsgRetryManagerClass = ExponentialBackofMsgRetryManager.class.getName();</span><br><span class="line"><span class="comment">//指数级别的back-off重试设置。在一个bolt调用OutputCollector.fail()后，用于重新设置的ExponentialBackoffMsgRetryManager。只有在ExponentialBackoffMsgRetryManager被使用时，才有效果。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">long</span> retryInitialDetails = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">double</span> retryDelayMultiplier = <span class="number">1.0</span>;</span><br><span class="line"><span class="comment">//连续重试之间的最大延时</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">long</span> retryDelayMaxMs = <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line"><span class="comment">//当retryLimit低于0时，不停地重新发送失效的消息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> retryLimit = -<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>KafkaSpout只接收一个SpoutConfig的实例作为参数。</p><p>下面给出一个实例：</p><ol><li><p>首先创建一个名为<code>couple</code>的topic，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --create --zookeeper localhost:3030 --partitions 4 --replication-factor 1 --topic couple</span><br></pre></td></tr></table></figure></li><li><p>写一个简单的Producer，将文件<code>string_data.txt</code>的记录发送到<code>couple</code>中，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">kafkaFileProducer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String topic_name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String file_name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> KafkaProducer&lt;String,String&gt; producer;</span><br><span class="line">    <span class="keyword">private</span> Boolean isAsync;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">kafkaFileProducer</span><span class="params">(String topic_name,String file_name,Boolean isAsync)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.file_name=file_name;</span><br><span class="line">        <span class="keyword">this</span>.topic_name=topic_name;</span><br><span class="line">        Properties properties=<span class="keyword">new</span> Properties();</span><br><span class="line">        properties.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</span><br><span class="line">        properties.put(<span class="string">"client.id"</span>,<span class="string">"CoupleProducer"</span>);</span><br><span class="line">        properties.put(<span class="string">"key.serializer"</span>,<span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">        properties.put(<span class="string">"value.serializer"</span>,<span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">        producer=<span class="keyword">new</span> KafkaProducer&lt;String, String&gt;(properties);</span><br><span class="line">        <span class="keyword">this</span>.isAsync=isAsync;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String key,String value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start_time=System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">if</span>(isAsync)&#123;</span><br><span class="line">            producer.send(<span class="keyword">new</span> ProducerRecord&lt;String, String&gt;(topic_name,key),<span class="keyword">new</span> CoupleCallBack(start_time,key,value));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                producer.send(<span class="keyword">new</span> ProducerRecord&lt;String, String&gt;(topic_name,key,value)).get();</span><br><span class="line">                System.out.println(<span class="string">"Sent message : ( "</span>+key+<span class="string">" , "</span>+value+<span class="string">" )"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String file_name=<span class="string">"DataSource/Data/string_data.txt"</span>;</span><br><span class="line">        String topic_name=<span class="string">"couple"</span>;</span><br><span class="line">        kafkaFileProducer producer=<span class="keyword">new</span> kafkaFileProducer(topic_name,file_name,<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> lineCount=<span class="number">0</span>;</span><br><span class="line">        FileInputStream fis=<span class="keyword">null</span>;</span><br><span class="line">        BufferedReader br=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis=<span class="keyword">new</span> FileInputStream(file_name);</span><br><span class="line">            br=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(fis));</span><br><span class="line">            String line=<span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span>((line=br.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                lineCount++;</span><br><span class="line">                producer.sendMessage(lineCount+<span class="string">""</span>,line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CoupleCallBack</span> <span class="keyword">implements</span> <span class="title">Callback</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> start_time;</span><br><span class="line">        <span class="keyword">private</span> String key;</span><br><span class="line">        <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CoupleCallBack</span><span class="params">(<span class="keyword">long</span> start_time, String key, String message)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.start_time = start_time;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.message = message;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            A callback method</span></span><br><span class="line"><span class="comment">            The user can implement to provide asynchronous handling of request completion.</span></span><br><span class="line"><span class="comment">            The method will be called when the record sent to the server has been acknowledged.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompletion</span><span class="params">(RecordMetadata recordMetadata, Exception e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> elapsed_time=System.currentTimeMillis()-start_time;</span><br><span class="line">            <span class="keyword">if</span>(recordMetadata!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"Message( "</span>+key+<span class="string">" , "</span>+ message+<span class="string">" ) sent to partition("</span>+recordMetadata.partition()+<span class="string">" ) , offset("</span> +recordMetadata.offset()+<span class="string">" ) in "</span>+elapsed_time+<span class="string">" ms"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写一个简单的Storm Topology，利用KafkaSpout读取couple中的数据(一条条的句子)，并分割成一个个的单词，统计单词个数，如下：</p><ul><li><p>SplitSentenceBolt</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SplitSentenceBolt</span> <span class="keyword">extends</span> <span class="title">BaseBasicBolt</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple tuple, BasicOutputCollector basicOutputCollector)</span> </span>&#123;</span><br><span class="line">        String sentence=tuple.getStringByField(<span class="string">"msg"</span>);</span><br><span class="line">        System.out.println(tuple.getSourceTask()+<span class="string">":"</span>+sentence);</span><br><span class="line">        String[] words=sentence.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span>(String word:words)&#123;</span><br><span class="line">            basicOutputCollector.emit(<span class="keyword">new</span> Values(word));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer outputFieldsDeclarer)</span> </span>&#123;</span><br><span class="line">        outputFieldsDeclarer.declare(<span class="keyword">new</span> Fields(<span class="string">"word"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>WordCountBolt</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountBolt</span> <span class="keyword">extends</span> <span class="title">BaseBasicBolt</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Long&gt; counts=<span class="keyword">null</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(Map conf,TopologyContext context)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.counts=<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">super</span>.prepare(conf,context);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple tuple, BasicOutputCollector basicOutputCollector)</span> </span>&#123;</span><br><span class="line">        String word=tuple.getStringByField(<span class="string">"word"</span>);</span><br><span class="line">        Long count=<span class="keyword">this</span>.counts.get(word);</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="keyword">null</span>)</span><br><span class="line">            count=<span class="number">0L</span>;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">this</span>.counts.put(word,count);</span><br><span class="line">        basicOutputCollector.emit(<span class="keyword">new</span> Values(word,count));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer outputFieldsDeclarer)</span> </span>&#123;</span><br><span class="line">        outputFieldsDeclarer.declare(<span class="keyword">new</span> Fields(<span class="string">"word"</span>,<span class="string">"count"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ReportBolt</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReportBolt</span> <span class="keyword">extends</span> <span class="title">BaseBasicBolt</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple tuple, BasicOutputCollector basicOutputCollector)</span> </span>&#123;</span><br><span class="line">        String word=tuple.getStringByField(<span class="string">"word"</span>);</span><br><span class="line">        Long count=tuple.getLongByField(<span class="string">"count"</span>);</span><br><span class="line">        String reportMsg=<span class="string">"&#123; word : "</span>+word+<span class="string">" , count : "</span>+count+<span class="string">" &#125;"</span>;</span><br><span class="line">        basicOutputCollector.emit(<span class="keyword">new</span> Values(reportMsg));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer outputFieldsDeclarer)</span> </span>&#123;</span><br><span class="line">        outputFieldsDeclarer.declare(<span class="keyword">new</span> Fields(<span class="string">"message"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>KafkaWordCountTopology</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountKafkaTopology</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KAFKA_SPOUT_ID=<span class="string">"kafka-spout"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SPLIT_BOLT_ID=<span class="string">"split-bolt"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String WORD_COUNT_BOLT_ID=<span class="string">"word-count-bolt"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REPORT_BOLT_ID=<span class="string">"report-bolt"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONSUME_TOPIC=<span class="string">"couple"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PRODUCT_TOPIC=<span class="string">"test"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ZK_ROOT=<span class="string">"/couple"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ZK_ID=<span class="string">"wordcount"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOPOLOGY_NAME=<span class="string">"word-count-topology"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        BrokerHosts brokerHosts=<span class="keyword">new</span> ZkHosts(<span class="string">"192.168.1.118:3030"</span>);</span><br><span class="line">        SpoutConfig spoutConfig=<span class="keyword">new</span> SpoutConfig(brokerHosts,CONSUME_TOPIC,ZK_ROOT,ZK_ID);</span><br><span class="line"></span><br><span class="line">        spoutConfig.scheme = <span class="keyword">new</span> SchemeAsMultiScheme(<span class="keyword">new</span> MessageScheme());</span><br><span class="line"></span><br><span class="line">        TopologyBuilder builder=<span class="keyword">new</span> TopologyBuilder();</span><br><span class="line">        builder.setSpout(KAFKA_SPOUT_ID,<span class="keyword">new</span> KafkaSpout(spoutConfig),<span class="number">3</span>);<span class="comment">//需要注意的是，spout的并行度不能超过topic的partition个数！</span></span><br><span class="line">        builder.setBolt(SPLIT_BOLT_ID,<span class="keyword">new</span> SplitSentenceBolt(),<span class="number">1</span>).shuffleGrouping(KAFKA_SPOUT_ID);</span><br><span class="line">        builder.setBolt(WORD_COUNT_BOLT_ID,<span class="keyword">new</span> WordCountBolt()).fieldsGrouping(SPLIT_BOLT_ID,<span class="keyword">new</span> Fields(<span class="string">"word"</span>));</span><br><span class="line">        builder.setBolt(REPORT_BOLT_ID,<span class="keyword">new</span> ReportBolt()).shuffleGrouping(WORD_COUNT_BOLT_ID);</span><br><span class="line">        <span class="comment">//builder.setBolt(KAFKA_BOLT_ID,new KafkaBolt&lt;String,Long&gt;()).shuffleGrouping(REPORT_BOLT_ID);</span></span><br><span class="line"></span><br><span class="line">        Config config=<span class="keyword">new</span> Config();</span><br><span class="line">        Map&lt;String,String&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//map.put("metadata.broker.list", "localhost:9092");</span></span><br><span class="line">        map.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</span><br><span class="line">    map.put(<span class="string">"serializer.class"</span>,<span class="string">"kafka.serializer.StringEncoder"</span>);</span><br><span class="line">        config.put(<span class="string">"kafka.broker.properties"</span>,map);</span><br><span class="line">        config.setNumWorkers(<span class="number">3</span>);</span><br><span class="line">      </span><br><span class="line">        LocalCluster cluster=<span class="keyword">new</span> LocalCluster();</span><br><span class="line"> cluster.submitTopology(TOPOLOGY_NAME,config,builder.createTopology());</span><br><span class="line">        Utils.sleep(<span class="number">10000</span>);</span><br><span class="line">        cluster.killTopology(TOPOLOGY_NAME);</span><br><span class="line">        cluster.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;storm-kafka-XXX.jar&lt;/code&gt;提供了核心Storm与Trident的组件Spout的代码实现，用于消费Kafka中存储的数据(0.8.x之后的版本)。本文只介绍核心Storm的KafkaSpout。&lt;/p&gt;
&lt;p&gt;对于核心Storm与Trident两个版本的Spout实现，提供了&lt;code&gt;BrokerHost&lt;/code&gt;接口，跟踪Kafka broker host$\rightarrow$partition的映射，并提供&lt;code&gt;KafkaConfig&lt;/code&gt;接口来控制Kafka相关的参数。下面就这以上两点进行讲解。&lt;/p&gt;
&lt;h3 id=&quot;BrokerHost&quot;&gt;&lt;a href=&quot;#BrokerHost&quot; class=&quot;headerlink&quot; title=&quot;BrokerHost&quot;&gt;&lt;/a&gt;BrokerHost&lt;/h3&gt;&lt;p&gt;为了对Kafka spout进行初始化，我们需要创建一个&lt;code&gt;BrokerHost&lt;/code&gt;的实例，Storm共提供了两种实现方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;ZkHosts。ZkHosts使用Zookeeper的实体对象，可动态地追踪Kafka broker$\rightarrow$partition之间的映射，通过调用下面两种函数创建ZkHosts:&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ZkHosts&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String brokerZkStr,String brokerZkPath)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ZkHosts&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String brokerZkStr)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中，&lt;code&gt;brokerZkStr&lt;/code&gt;是&lt;code&gt;ip:host&lt;/code&gt;(主机:端口)，&lt;code&gt;brokerZkPath&lt;/code&gt;是存放所有topic和partition信息的根目录，默认值为&lt;code&gt;\broker&lt;/code&gt;。默认地，Zookepper每60秒刷新一次broker$\rightarrow$partition，通过&lt;code&gt;host:refreshFreqSecs&lt;/code&gt;可以改变这个时间。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Storm学习之路" scheme="http://tankcat2.com/categories/Storm%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="kafka" scheme="http://tankcat2.com/tags/kafka/"/>
    
      <category term="storm" scheme="http://tankcat2.com/tags/storm/"/>
    
  </entry>
  
  <entry>
    <title>列存储中常见压缩技术</title>
    <link href="http://tankcat2.com/2017/05/11/compression/"/>
    <id>http://tankcat2.com/2017/05/11/compression/</id>
    <published>2017-05-11T05:40:00.000Z</published>
    <updated>2017-07-20T00:46:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>在列数据库中，实用面向列的压缩算法进行数据压缩，并且在处理数据时保持压缩的形式，即不通过解压来处理数据，很大程度上提升了查询性能.凭直觉就能知道，以列为存储形式的数据比以行为存储形式的数据更容易压缩.当处理的数据信息熵较低，即数据的局部性较高，那么压缩算法的性能越好.举个列子来说吧，现在有一张顾客表，包含了[姓名，电话，邮箱，传真]等属性.列存储使得所有的姓名存储在一起，所有的电话号码存储在一起.有一点可以确定的是，电话号码各自之间是要比周围其他属性的数值来得更加相似的.</p><p><strong>压缩的优势具体是什么呢？</strong>总结起来呢有两点：</p><ol><li>减少I/O操作次数.如果数据被压缩了，那么其实一次I/O读取(磁盘到内存/CPU)实际对应的源数据是远远超过不使用压缩技术的读取.</li><li>提高查询性能.如果查询执行器可以直接在压缩后的数据上进行操作，在进行具体的操作时不需要进行解压，而这个操作一般开销较大.</li></ol><p>列存储的压缩技术一般有消零和空格符算法(Null Supression)、Lerrpel-Ziv算法、词典编码算法(Dictionary Encoding)、行程编码算法(Run-length Encoding)、位向量算法(Bit-Vector Encoding)，其中较为常见的是后三种，接下来也重点介绍这三种.</p><a id="more"></a><h3 id="行程编码-Run-length-Encoding"><a href="#行程编码-Run-length-Encoding" class="headerlink" title="行程编码 Run-length Encoding"></a>行程编码 Run-length Encoding</h3><p>行程编码的核心思想是将有序列中的相同元素转化成一个三元组&lt;属性值，该值第一次出现的位置，出现的次数&gt;,适用于有序的列或者可转为有序的列.下面给出一个具体的例子.下图给出一个身高的有序列，使用行程编码，可转化为两个三元组.为了便于管理，可以在三元组上构建索引.需要注意的是，该算法比较适合distinct值较少的列，因为如果列中不同的值较多，比如所有的值都不同，那么创建的三元组的数量就会很大，施展不出该算法的优势.</p><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/run_length.png" alt=""></p><h3 id="位向量-Bit-Vector"><a href="#位向量-Bit-Vector" class="headerlink" title="位向量 Bit-Vector"></a>位向量 Bit-Vector</h3><p>位向量的核心思想是，将一个列中相同的值转为一个二元组&lt;属性值，在列中出现的位置的位图&gt;.下面给出一个简单的例子，图中给出的列是无序的，其中160这个值出现在第0、3、4、6个位置，162出现在第1、2、5个位置，则其位图的表示分别是1001101和0110010.使用该算法，整个列只要用两个简单的二元组就能表示出来.若列中distinct的值较少，则位图还可以用行程编码进行二次压缩.</p><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/bit_vector.png" alt=""></p><h3 id="词典编码-Dictionary-Encoding"><a href="#词典编码-Dictionary-Encoding" class="headerlink" title="词典编码 Dictionary Encoding"></a>词典编码 Dictionary Encoding</h3><p>词典编码，顾名思义，主要针对的是字符串的压缩，核心思想是利用简短的编码代替列中某些重复出现的字符串，维护一个字符串与编码的映射，就可以快速确定编码所指代的字符串，这个映射也就是所谓的Dictionary.下面给出12年Google在VLDB论文<a href="http://dl.acm.org/citation.cfm?id=2350259&amp;CFID=761347277&amp;CFTOKEN=44019228" target="_blank" rel="noopener">Processing a trillion cells per mouse click</a>上有关这个算法的例子，将列search_string划分为三个块，每个块中都存在重复的字符串。首先创建一个全局的字典表global_dictionary，该表中包含了search_string中的所有distinct字符串，且每个字符串分配一个全局唯一的id.接着，为每个块也创建一个字典表chunk_dictionary，包含在该块中的所有distinct字符串，为每个字符串分配一个块范围内的id，并且将这个id与该字符串的全局id对应起来，通过这种二级字典表的方式，一个字符串就可以通过全局字典表映射到一个全局id，再通过块字典表映射到一个块id，这样快中就不用再存储真正的字符串了，而是字符串对应的块id，也就是图中的elements.例如要查找chunk 0中第4个element对应的字符串时，找到该element对应的块id是4，对应的全局id是12，再查找全局字典表可知，该element对应字符串”yellow pages”.同样该算法适用于列中distinct字符串较少的情况.</p><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/dictionary_encoding.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在列数据库中，实用面向列的压缩算法进行数据压缩，并且在处理数据时保持压缩的形式，即不通过解压来处理数据，很大程度上提升了查询性能.凭直觉就能知道，以列为存储形式的数据比以行为存储形式的数据更容易压缩.当处理的数据信息熵较低，即数据的局部性较高，那么压缩算法的性能越好.举个列子来说吧，现在有一张顾客表，包含了[姓名，电话，邮箱，传真]等属性.列存储使得所有的姓名存储在一起，所有的电话号码存储在一起.有一点可以确定的是，电话号码各自之间是要比周围其他属性的数值来得更加相似的.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;压缩的优势具体是什么呢？&lt;/strong&gt;总结起来呢有两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;减少I/O操作次数.如果数据被压缩了，那么其实一次I/O读取(磁盘到内存/CPU)实际对应的源数据是远远超过不使用压缩技术的读取.&lt;/li&gt;
&lt;li&gt;提高查询性能.如果查询执行器可以直接在压缩后的数据上进行操作，在进行具体的操作时不需要进行解压，而这个操作一般开销较大.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;列存储的压缩技术一般有消零和空格符算法(Null Supression)、Lerrpel-Ziv算法、词典编码算法(Dictionary Encoding)、行程编码算法(Run-length Encoding)、位向量算法(Bit-Vector Encoding)，其中较为常见的是后三种，接下来也重点介绍这三种.&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://tankcat2.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="压缩" scheme="http://tankcat2.com/tags/%E5%8E%8B%E7%BC%A9/"/>
    
      <category term="行程编码" scheme="http://tankcat2.com/tags/%E8%A1%8C%E7%A8%8B%E7%BC%96%E7%A0%81/"/>
    
      <category term="词典编码" scheme="http://tankcat2.com/tags/%E8%AF%8D%E5%85%B8%E7%BC%96%E7%A0%81/"/>
    
      <category term="位向量" scheme="http://tankcat2.com/tags/%E4%BD%8D%E5%90%91%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>“视图”漫游</title>
    <link href="http://tankcat2.com/2017/05/10/view/"/>
    <id>http://tankcat2.com/2017/05/10/view/</id>
    <published>2017-05-10T06:17:31.000Z</published>
    <updated>2017-07-20T00:47:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>百度百科里面有关视图(View)的定义是，“指数据库中的视图，是一个虚拟表，其内容由查询定义”.</p><p>从用户的角度来看，一个视图是从一个<strong>特定的角度</strong>来查看数据库中的数据；</p><p>从数据库系统内部来看，视图是存储在数据库中的SQL Select语句，从一个或者多个基本表(相对于虚表而言)中导出的，和基本表类似，视图也包含行和列，但是在物理上不以存储的数据值集的形式存在.下面给出一张图来解释这段话的意思.从图上我们可以看出，数据库并没有对视图的数据进行物理上的存储，存储的只是视图的定义，也就是响应的Select.</p><a id="more"></a><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/view.jpg" alt=""></p><p>从数据库系统外部来看，视图就如同一张基本表，对基本表能够进行的一般操作都可以应用在视图上，比如增删改查.</p><p>那视图有优点呢？换句话说，<strong>为什么要使用视图呢？</strong>归纳起来有四点：</p><ol><li>简化负载查询.视图的定义是基于一个查询声明，这个查询声明可能关联了很多底层的表，可以使用视图向数据库的使用者或者外部程序隐藏复杂的底层表关系.</li><li>限制特定用户的数据访问权.处于安全原因，视图可以隐藏一些数据，比如社会保险基金表，可以用视图只显示姓名，地址，不显示社会保险号和工资数等.</li><li>支持列的动态计算.基本表一般都不支持这个功能，比如有一张<code>orders</code>订单表，包含产品数量<code>produce_num</code>与单价<code>produce_price_each</code>两个列，当需要查询总价时，就需要先查询出所有记录，再在代码中进行计算；而如果使用视图的话，只要在视图中添加一列<code>total_price(product_num*produce_price_each)</code>就可以直接查询出订单的总价了.</li><li>兼容旧版本.假设需要对数据库进行重新设计以适应一个新的业务需求，可能需要删除一些旧表，创建一些新表，但是又不希望这些变动会影响到那些旧程序，此时，就可以使用视图来适配那些旧程序.这就像公共API一样，无论内部发生什么改变，不影响上层的使用.</li></ol><p>既然说视图也是一种SQL语句，<strong>那么它和查询的区别是什么呢？</strong>简单来说，有三点：</p><ol><li>存储上，视图存储是数据库设计的一部分，而查询则不是；</li><li>更新限制上，因为视图来自于基本表，所以可间接地对基本表进行更新，但是存在诸多限制，比如不能在使用了group by语句的视图中插入值.</li><li>排序结果上，通过查询，可以对一个基本表进行排序，而视图不可以.</li></ol><p>此外，经常对视图的增删改查还是会转换为对基本表的增删改查，会不会降低操作的效率呢？其实未必，尤其是对于多表关联，视图创建后数据库内部会作出相应处理，建立对应的查询路径，反而有利于查询的效率，<strong>这就涉及到物化视图的知识了</strong>.</p><p><a href="https://en.wikipedia.org/wiki/Materialized_view" target="_blank" rel="noopener">维基百科里解释道，</a>物化视图(Materialized View)，也叫做快照，是包含了查询结果的数据库对象，可能是一个远程数据的本地副本，或者是一张表或连接结果的行或者列的子集，等.创建物化视图的过程有时候也被称作是物化，一种缓存查询结果的形式，类似于函数式编程中将函数值进行缓存，有时也称作是“预计算”，用来提高查询的性能与效率.</p><p>在关系型数据库中，如果涉及到对基本视图的查找或修改，都会转化为与之对应的基本表的查找或修改.而物化视图采取不同的方法.查询的结果被缓存在一个实体表中，而不是一个视图里，<strong>实际存储着数据的</strong>，这个实体表会随着基本表的更新而更新. 这种方法利用额外的存储代价和允许部分数据过期的代价，使得查询时的数据访问更加高效.在数据仓库中，物化视图经常使用，尤其是代价较大的频繁基本表查询操作.</p><p>和基本视图还有一点不同的是，在物化视图中，可以在任何一列上建立索引，相反，基本视图通常只能在与基本表相关的列上建立索引.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;百度百科里面有关视图(View)的定义是，“指数据库中的视图，是一个虚拟表，其内容由查询定义”.&lt;/p&gt;
&lt;p&gt;从用户的角度来看，一个视图是从一个&lt;strong&gt;特定的角度&lt;/strong&gt;来查看数据库中的数据；&lt;/p&gt;
&lt;p&gt;从数据库系统内部来看，视图是存储在数据库中的SQL Select语句，从一个或者多个基本表(相对于虚表而言)中导出的，和基本表类似，视图也包含行和列，但是在物理上不以存储的数据值集的形式存在.下面给出一张图来解释这段话的意思.从图上我们可以看出，数据库并没有对视图的数据进行物理上的存储，存储的只是视图的定义，也就是响应的Select.&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://tankcat2.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="视图" scheme="http://tankcat2.com/tags/%E8%A7%86%E5%9B%BE/"/>
    
      <category term="物化视图" scheme="http://tankcat2.com/tags/%E7%89%A9%E5%8C%96%E8%A7%86%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>近日爱读诗词</title>
    <link href="http://tankcat2.com/2017/05/09/poet/"/>
    <id>http://tankcat2.com/2017/05/09/poet/</id>
    <published>2017-05-09T04:44:31.000Z</published>
    <updated>2017-05-09T08:13:28.000Z</updated>
    
    <content type="html"><![CDATA[<center><br><strong>闲居初夏午睡起</strong><br><br>梅子留酸软齿牙，<br><br>芭蕉分绿与窗纱。<br><br>日长睡起无情思，<br><br>闲看儿童捉柳花。<br><br>ps:很喜欢杨万里的写景<br><br><a id="more"></a><br><br><strong>初夏即事</strong><br><br>石梁茅屋有弯碕，<br><br>流水溅溅度两陂。<br><br>晴日暖风生麦气，<br><br>绿阴幽草胜花时。<br><br>ps:读这首诗的那天正好是立夏<br><br><br><br><strong>苔</strong><br><br>白日不到处，<br><br>青春恰自来。<br><br>苔花如米小，<br><br>也学牡丹开。<br><br>ps:那日选这首诗是有原因的，自己阴差阳错地参加了学院的杰出青年评比。由于自己是保研来的华师大，现在又才研一，除了屈指可数的科研成果，其余方面均为有所建树。不出所料，只拿了一个靠亲朋好友投票来的人气奖。但是，个人成果的匮乏，没有使我退缩，依然自信上场，这毕竟也是一种锻炼，也可以看看别人是如何展示自己的。<br><br></center><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;br&gt;&lt;strong&gt;闲居初夏午睡起&lt;/strong&gt;&lt;br&gt;&lt;br&gt;梅子留酸软齿牙，&lt;br&gt;&lt;br&gt;芭蕉分绿与窗纱。&lt;br&gt;&lt;br&gt;日长睡起无情思，&lt;br&gt;&lt;br&gt;闲看儿童捉柳花。&lt;br&gt;&lt;br&gt;ps:很喜欢杨万里的写景&lt;br&gt;&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://tankcat2.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="诗词" scheme="http://tankcat2.com/tags/%E8%AF%97%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>聚类索引与非聚类索引</title>
    <link href="http://tankcat2.com/2017/05/06/index/"/>
    <id>http://tankcat2.com/2017/05/06/index/</id>
    <published>2017-05-06T13:08:00.000Z</published>
    <updated>2017-07-20T00:47:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>索引，是对数据库表中一列或者多列的值进行排序的一种数据结构，以便于快速访问数据库表的特定信息.如果没有索引，则需要遍历整张表，直到定位到所需的信息为止.可见，索引是用来<strong>定位</strong>的，加快数据库的查询速度.</p><h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><p>索引可分为聚集索引与非聚集索引.下面就两者分别介绍.</p><h3 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h3><p>在聚集索引中，表中行的物理顺序与索引的顺序相同，且一张表只能包含一个聚集索引.聚集索引类似物电话簿，索引可以包含一个或者多个列，类似电话簿按照姓氏和名字进行组织一样.</p><p>聚集索引很适用于那些经常要搜索范围值的列。使用聚集索引找到包含第一个值的行后，便可以确保包含后续索引值的行在物理上相邻.比如，若应用程序执行的某个查询经常检索某一个日期范围的记录，使用聚集索引可以迅速找到包含开始日期的行，接着检索相邻的行，直到到达结束日期.这样有助于提高类似查询的性能.</p><a id="more"></a><p>索引是通过<a href="http://blog.jobbole.com/24006/" target="_blank" rel="noopener">二叉树</a>的数据结构来描述的，我们可以这么理解聚集索引：索引的叶子节点就是数据节点，如下图所示.</p><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/cluster.JPG" alt=""></p><h3 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h3><p>非聚集索引的逻辑顺序与表中行的物理存储数据不同，数据结构中的叶节点仍然是索引节点，有一个指针指向对应的数据块，如下图所示.</p><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/noncluster.JPG" alt=""></p><h2 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h2><p>实际上，可把索引理解为一种特殊的目录。下面举个例子来说明一下聚集索引与非聚集索引的区别.</p><p>我们的汉语字典的正文本身就是一个聚集索引。比如，我们要查“安”字，就会很自然地翻开字典的前几页，因为“安”的拼音是“an”，而按照拼音排序汉字的字典是以英文字母“a”开头并以“z”结尾的，那么“安”字就自然地排在字典的前部。如果翻完了所有以“a”开头的部分仍然找不到这个字，那么就说明您的字典中没有这个字；同样的，如果查“张”字，那也会将您的字典翻到最后部分，因为“张”的拼音是“zhang”。也就是说，<strong>字典的正文部分本身就是一个目录</strong>，您不需要再去查其他目录来找到您需要找的内容。我们<strong>把这种正文内容本身就是一种按照一定规则排列的目录称为“聚集索引”</strong>。</p><p>如果我们认识某个字，可以快速地从自动中查到这个字。但也可能会遇到不认识的字，不知道它的发音，这时候，就不能按照刚才的方法找到我们要查的字，而需要去根据“偏旁部首”查到要找的字，然后根据这个字后的页码直接翻到某页来找到您要找的字。但结合“部首目录”和“检字表”而查到的字的排序并不是真正的正文的排序方法，比如查“张”字，我们可以看到在查部首之后的检字表中“张”的页码是672页，检字表中“张”的上面是“驰”字，但页码却是63页，“张”的下面是“弩”字，页面是390页。很显然，这些字并不是真正的分别位于“张”字的上下方，现在看到的连续的“驰、张、弩”三字实际上就是他们在<strong>非聚集索引中的排序</strong>，<strong>是字典正文中的字在非聚集索引中的映射</strong>。我们可以通过这种方式来找到您所需要的字，但它需要两个过程，先找到目录中的结果，然后再翻到所需要的页码。我们<strong>把这种目录纯粹是目录，正文纯粹是正文的排序方式称为“非聚集索引”</strong>。</p><p>通过以上例子，我们可以理解到什么是“聚集索引”和“非聚集索引”。进一步引申一下，我们可以很容易的理解：每个表只能有一个聚集索引，因为目录只能按照一种方法进行排序。</p><h2 id="两种索引的应用场合"><a href="#两种索引的应用场合" class="headerlink" title="两种索引的应用场合"></a>两种索引的应用场合</h2><table><thead><tr><th>动作描述</th><th>聚集索引</th><th>非聚集索引</th></tr></thead><tbody><tr><td>经常对列进行分组排序</td><td>√</td><td>√</td></tr><tr><td>返回某个范围内的数据</td><td>√</td><td>×</td></tr><tr><td>一个或者极少不同的值</td><td>×</td><td>×</td></tr><tr><td>小数目的不同值</td><td>√</td><td>×</td></tr><tr><td>大数目的不同值</td><td>×</td><td>√</td></tr><tr><td>频繁更新的列</td><td>×</td><td>√</td></tr><tr><td>频繁更新索引列</td><td>×</td><td>√</td></tr><tr><td>外键列</td><td>√</td><td>√</td></tr><tr><td>主键列</td><td>√</td><td>√</td></tr><tr><td></td><td></td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;索引，是对数据库表中一列或者多列的值进行排序的一种数据结构，以便于快速访问数据库表的特定信息.如果没有索引，则需要遍历整张表，直到定位到所需的信息为止.可见，索引是用来&lt;strong&gt;定位&lt;/strong&gt;的，加快数据库的查询速度.&lt;/p&gt;
&lt;h2 id=&quot;基本知识&quot;&gt;&lt;a href=&quot;#基本知识&quot; class=&quot;headerlink&quot; title=&quot;基本知识&quot;&gt;&lt;/a&gt;基本知识&lt;/h2&gt;&lt;p&gt;索引可分为聚集索引与非聚集索引.下面就两者分别介绍.&lt;/p&gt;
&lt;h3 id=&quot;聚集索引&quot;&gt;&lt;a href=&quot;#聚集索引&quot; class=&quot;headerlink&quot; title=&quot;聚集索引&quot;&gt;&lt;/a&gt;聚集索引&lt;/h3&gt;&lt;p&gt;在聚集索引中，表中行的物理顺序与索引的顺序相同，且一张表只能包含一个聚集索引.聚集索引类似物电话簿，索引可以包含一个或者多个列，类似电话簿按照姓氏和名字进行组织一样.&lt;/p&gt;
&lt;p&gt;聚集索引很适用于那些经常要搜索范围值的列。使用聚集索引找到包含第一个值的行后，便可以确保包含后续索引值的行在物理上相邻.比如，若应用程序执行的某个查询经常检索某一个日期范围的记录，使用聚集索引可以迅速找到包含开始日期的行，接着检索相邻的行，直到到达结束日期.这样有助于提高类似查询的性能.&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://tankcat2.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="索引" scheme="http://tankcat2.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>&lt;刀锋&gt;观后感</title>
    <link href="http://tankcat2.com/2017/04/20/daofeng/"/>
    <id>http://tankcat2.com/2017/04/20/daofeng/</id>
    <published>2017-04-20T12:11:31.000Z</published>
    <updated>2017-05-05T12:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>先摘抄一段刀锋里面我很喜欢的一段话，“For men and women are not only themselves; they are also the region in which they were born, the city apartment or the farm in which they learnt to walk, the games they played as children, the tales they overheard, the food they ate, the schools they attended, the sports they followed, the poets they read and the God they believed in. It is all these things that have made them what they are, and these are the things that you can’t come to know by hearsay, you can only know them if you have lived them. You can only know them if you are them.”</p><a id="more"></a><p>“因为人不论男男女女，都不仅仅是他们自身；他们也是自己出生的乡土，学步的农场或城市公寓，儿时玩的游戏，私下听来的山海经，吃的饭食，上的学校，关心的运动，吟哦的诗章，和信仰的上帝。这一切东西把他们造成现在这样，而这些东西都不是道听途说就可以了解的，你非得和那些人生活过。要了解这些，你就得是这些。 ”</p><p>无论中英文，都是一流的文字，解释了各种文化之间的冲突，以及冲突误解的永恒性。</p><p>很少有外国作品上让我读得这么舒服，这完全归功于周旭良老师的翻译功底，整本书翻译地非常好，读起来如沐春风。书写得很平淡，但每个角色都很有意思，拉里最为迷人。很奇怪，刚开始看的时候我脑子里对拉里的想象，居然是血战钢锯岭里的戴斯蒙特，这里也仅是人物形象。拉里一直追寻的答案，等同于追求终极真理，而这个问题最终都会归结到理性与精神的绝对满足。真的很难以想象，拉里这样的人，现实中又有多少，他们的生活又是怎样的？这种绝对的内心的泰然平和，我生生世世估计也做不到吧。</p>]]></content>
    
    <summary type="html">
    
      追随内心需求，探索人生价值与真谛.
    
    </summary>
    
      <category term="读书笔记" scheme="http://tankcat2.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="传记" scheme="http://tankcat2.com/tags/%E4%BC%A0%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>&lt;简明美国史&gt;观后感</title>
    <link href="http://tankcat2.com/2017/04/16/historyUSA/"/>
    <id>http://tankcat2.com/2017/04/16/historyUSA/</id>
    <published>2017-04-16T12:11:31.000Z</published>
    <updated>2017-05-05T12:08:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>相对于厚重的、教科书式的历史文献，这是一本薄薄的，轻松的普及读本，没有平板数据，没有经济图表，却把把美国历史的端倪，黑暗，辉煌，血腥，光明清晰地勾勒出来。</p><a id="more"></a><p>有人说陈勤老师的这本美国史写得实在是太简太浅显，但是对我这种历史水平只停留在高中课本上的”史盲“来说，基本上是够了，从脉络上了解美国自1620年《五月花号公约》至2016年奥巴马最后的执政之间所发生的重大历史事件，这其中涵盖了美国从英属殖民地开始，到1776年《独立宣言》宣告独立，到1860年林肯领导南北战争，再到一战、二战、冷战，以及至今美国发生的种种。读完全书的第一感受是，陈勤老师应当是亲美派的，书中给我描述的美国是一个有趣、鲜活、有人味的美国，虽然对历史变革中发生的流血事件只是轻描淡写地带过，但还是能些许体会到”世界何尝不简单，历史从来不温柔“这一面。读完一遍脑海中对美国的历史线还是稍有混乱，有时间自己再整理整理。</p>]]></content>
    
    <summary type="html">
    
      青山遮不住，毕竟东流去.
    
    </summary>
    
      <category term="读书笔记" scheme="http://tankcat2.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="历史" scheme="http://tankcat2.com/tags/%E5%8E%86%E5%8F%B2/"/>
    
  </entry>
  
  <entry>
    <title>MIT 6.824 Lab 1 MapReduce</title>
    <link href="http://tankcat2.com/2017/03/14/Lab1_MapReduce/"/>
    <id>http://tankcat2.com/2017/03/14/Lab1_MapReduce/</id>
    <published>2017-03-14T14:57:31.000Z</published>
    <updated>2017-05-06T13:05:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在这个实验中，我们将构建一个MapReduce的类库，作为使用Go语言进行编程与构建容错分布式系统的介绍。首先，我们将编写一个简单的MapReduce程序。接着，编写一个Master程序，手动向MapReduce的worker分发任务，解决worker的失效。类库的接口与容错的方法，和<a href="http://research.google.com/archive/mapreduce-osdi04.pdf" target="_blank" rel="noopener">论文MapReduce: Simplified Data Processing on Large Clusters</a>类似。<br><a id="more"></a></p><h2 id="软件工具"><a href="#软件工具" class="headerlink" title="软件工具"></a>软件工具</h2><p>我们可以使用 <a href="http://www.golang.org/" target="_blank" rel="noopener">Go</a>语言完成该实验(或所有实现).Go的网站上有许多教程，在个人计算机上安装与开发Go十分简便。评测实验代码使用的Go版本是1.7，因此我们也最好使用该版本进行代码编写，以免出现一些版本问题。</p><p>课程提供了部分MapReduce的实现代码，包括分布式与非分布式的操作。我们可以使用 <a href="https://git-scm.com/" target="_blank" rel="noopener">git</a>获取最初的类库版本。该课程的git仓库链接为<code>git://g.csail.mit.edu/6.824-golabs-2017</code>。我们可以使用下面的命令，克隆一份类库到自己的计算机上。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone git://g.csail.mit.edu/6.824-golabs-2017 6.824</span><br><span class="line">cd 6.824</span><br><span class="line">ls</span><br><span class="line">Makefile src</span><br></pre></td></tr></table></figure><p>Git提供了追踪代码修改的功能。举个例子，如果我们需要对编写的代码进行checkpoint，可执行下面的命令提交更改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -am 'partial solution to lab 1'</span><br></pre></td></tr></table></figure><p>MapReduce的实现部分提供了两种模式操作，即<em>顺序的</em>与<em>分布式的</em>。前者，在一个时刻内只存在一个map或者reduce的task在执行：首先，第一个map的task执行结束，接着是第二个、第三个…；当所有的map task均执行完后，第一个reduce的task开始执行，接着是第二个、第三个…。这种模式的运行速度不快，但是对于debug是有用的。分布式的模式同时运行多个worker线程，首先并行执行map的task，接着是reduce的task。这种模式执行速度快，但是实现与调试较为困难。</p><h2 id="熟悉源码"><a href="#熟悉源码" class="headerlink" title="熟悉源码"></a>熟悉源码</h2><p>mapreduce包提供了Map/Reduce的类库。应用程序调用<code>Distributed()</code>（位于<code>master.go</code>文件）以启动一个job作业，也可以调用<code>Sequential()</code>(也位于<code>master.go</code>)，在debug的时候启动一个顺序执行。</p><p>代码按照以下步骤执行一个job：</p><ol><li><p>应用程序提供一些输入文件，一个map函数，一个reduce函数，以及reduce task的并行度(<code>nReduce</code>)；</p></li><li><p>使用以上信息，创建一个master。启动一个RPC服务器(见<code>master rpc.go</code>文件)，等待worker注册完毕(使用RPC调用<code>Register()</code>，定义在<code>master.go</code>文件)。当task可用时(步骤4与步骤5)，<code>schedule()</code>(见文件<code>schedule.go</code>)决定如何将这些task分配给worker，以及如何处理worker的失效；</p></li><li><p>master将每个输入文件指定给一个map task，为每个map的task至少调用一次<code>doMap()</code>(见<code>common_map.go</code>)。当使用<code>Sequential()</code>或者是向一个worker发出<code>DoTask</code>的RPC请求时，采取同样的做法。每次调用<code>doMap()</code>会读取适当的文件，在该文件的内容上使用map 函数，并将中间结果<code>key/value</code>键值对写入<code>nReduce</code>个中间文件。<code>doMap()</code>对key进行哈希，挑选一个中间文件，则相应的reduce task会处理这个key。在所有的map task执行结束后将会存在$nMap \times nReduce$个文件。每个文件名包含一个前缀：map task与reduce task的序号。如果有两个map task和三个reduce task，则map task会创建六个中间文件，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mrtmp.xxx-0-0</span><br><span class="line">mrtmp.xxx-0-1</span><br><span class="line">mrtmp.xxx-0-2</span><br><span class="line">mrtmp.xxx-1-0</span><br><span class="line">mrtmp.xxx-1-1</span><br><span class="line">mrtmp.xxx-1-2</span><br></pre></td></tr></table></figure><p>每个worker必须能够读取其他worker读写的文件。现实应用中的部署采用分布式存储系统来实现这一点，比如GFS，即使worker运行在不同的机器上。在实验中，我们在同一个机器上运行所有的worker，使用本地文件系统；</p></li><li><p>接下来master为每个reduce task至少调用一次<code>doReduce()</code>(见<code>common_reduce.go</code>)。与<code>doMap()</code>一样，直接或者通过一个worker进行操作。reduce task r 的<code>doReduce()</code>从每个map task中收集第r个中间文件，为文件中的每个key调用reduce 函数。reduce task会产生<code>nReduce</code>个结果文件；</p></li><li><p>master调用<code>mr.merge()</code>(见<code>master_splitmerge.go</code>)，将<code>nReduce</code>个文件的内容合并到一个文件中；</p></li><li><p>master向每个worker发送<code>RPC Shutdown</code>，接着关闭自己的RPC服务器。</p></li></ol><blockquote><p>注意：在接下来的练习中，我们需要自己重写/调整 <code>doMap()</code>，<code>doReduce()</code>和<code>schedule()</code>，这些方法分布位于<code>common_map.go</code>，<code>common_reduce.go</code>和<code>schedule.go</code>文件中。我们也需要在<code>../main/wc.go</code>文件中编写map和reduce函数。</p></blockquote><p>我们不需要修改其他任何文件，但是阅读这些文件对理解其他方法是如何参与整体架构的运行是有帮助的。</p><h2 id="第一部分：Map-Reduce的输入与输出"><a href="#第一部分：Map-Reduce的输入与输出" class="headerlink" title="第一部分：Map/Reduce的输入与输出"></a>第一部分：Map/Reduce的输入与输出</h2><p>在给定的Map/Reduce代码实现中存在代码缺失。在写我们的第一个Map/Reduce函数前，需要完成顺序实现模块。特别地，给定的代码中缺失了两个关键部分：划分一个map task的输出的函数，和收集一个reduce task的所有输入的函数。这两个模块分别被位于<code>common_map.go</code>和<code>common_reduce.go</code>中的 <code>doMap()</code>，<code>doReduce()</code>执行。这些文件中的注释可为我们指出正确的方向。</p><p>为了验证是否正确地实现了<code>doMap()</code>和<code>doReduce()</code>的编写，课程提供了一组用Go编写的测试套件，用于检测正确性。这些测试程序位于<code>test_test.go</code>文件中。可以执行下面的命令，运行顺序模式的测试程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd 6.824</span><br><span class="line">export "GOPATH=$PWD" # go needs $GOPATH to be set to the project's working directory</span><br><span class="line">cd "$GOPATH/src/mapreduce"</span><br><span class="line">go test -run Sequential</span><br><span class="line">ok  mapreduce2.694s</span><br></pre></td></tr></table></figure><p>如果运行测试程序的输出结果不是<em>ok</em>，则说明我们的程序中有bug。为了展示更详细的输出内容，在<code>common.go</code>文件中设置<code>debugEnabled = true</code>，并在上面的测试命令中添加<code>-v</code>。则我们会得出类似下面的更多输出信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">env "GOPATH=$PWD/../../" go test -v -run Sequential</span><br><span class="line">=== RUN   TestSequentialSingle</span><br><span class="line">master: Starting Map/Reduce task test</span><br><span class="line">Merge: read mrtmp.test-res-0</span><br><span class="line">master: Map/Reduce task completed</span><br><span class="line">--- PASS: TestSequentialSingle (1.34s)</span><br><span class="line">=== RUN   TestSequentialMany</span><br><span class="line">master: Starting Map/Reduce task test</span><br><span class="line">Merge: read mrtmp.test-res-0</span><br><span class="line">Merge: read mrtmp.test-res-1</span><br><span class="line">Merge: read mrtmp.test-res-2</span><br><span class="line">master: Map/Reduce task completed</span><br><span class="line">--- PASS: TestSequentialMany (1.33s)</span><br><span class="line">PASS</span><br><span class="line">ok  mapreduce2.672s</span><br></pre></td></tr></table></figure><h2 id="第二部分：单个worker的单词计数"><a href="#第二部分：单个worker的单词计数" class="headerlink" title="第二部分：单个worker的单词计数"></a>第二部分：单个worker的单词计数</h2><p>现在我们要实现一个简单的Map/Reduce程序——单词统计。在<code>main/wc.go</code>中，发现函数体空的<code>mapF()</code>和<code>reduceF()</code>。我们的任务是填充这两个函数，使得<code>wc.go</code>汇报每个单词出现的频数。一个单词是任何连续的字母序列，由<a href="http://golang.org/pkg/unicode/#IsLetter" target="_blank" rel="noopener">unicode.IsLetter</a>控制。</p><p>在~/6.824/src/main有一些输入文件，以<code>pg-* txt</code>形式为路径名，下载自 <a href="https://www.gutenberg.org/ebooks/search/%3Fsort_order%3Ddownloads" target="_blank" rel="noopener">Project Gutenberg</a>。下面是添加了输入文件运行<code>wc</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd 6.824</span><br><span class="line">export "GOPATH=$PWD"</span><br><span class="line">cd "$GOPATH/src/main"</span><br><span class="line">go run wc.go master sequential pg-*.txt</span><br><span class="line">command-line-arguments</span><br><span class="line">./wc.go:14: missing return at end of function</span><br><span class="line">./wc.go:21: missing return at end of function</span><br></pre></td></tr></table></figure><p>由于<code>mapF()</code>和<code>reduceF()</code>没有实现，所以出现编译错误。</p><p>回顾<a href="http://research.google.com/archive/mapreduce-osdi04.pdf" target="_blank" rel="noopener">论文MapReduce: Simplified Data Processing on Large Clusters</a>的第二部分。我们实现的<code>mapF()</code>和<code>reduceF()</code>与第2.1章节中描述的有一点区别。我们需要向<code>mapF()</code>传入文件名和文件内容，将内容分割成蛋醋，返回一个<code>mapreduce.KeyValue</code>的slice (Go的一种类型)。我们可以选择放入<code>mapF()</code>输出的key和value的内容。对于单词计数，使用单词作为key才有意义。对于每个key和由<code>mapF()</code>生成的该key的slice，会调用一次<code>reduceF()</code>，返回一个string，包含该key出现的频数总和。</p><blockquote><p>提示：a good read on what strings are in Go is the <a href="http://blog.golang.org/strings" target="_blank" rel="noopener">Go Blog on strings</a>.</p><p>提示：我们可以使用 <a href="http://golang.org/pkg/strings/#FieldsFunc" target="_blank" rel="noopener">strings.FieldsFunc</a> 来将string划分成单词；</p><p>提示：我们可以使用strconv 包(<a href="http://golang.org/pkg/strconv/" target="_blank" rel="noopener">http://golang.org/pkg/strconv/</a>) ，很方便地将string转为integer。</p></blockquote><p>我们可以使用下面的例子进行测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd "$GOPATH/src/main"</span><br><span class="line">time go run wc.go master sequential pg-*.txt</span><br><span class="line">master: Starting Map/Reduce task wcseq</span><br><span class="line">Merge: read mrtmp.wcseq-res-0</span><br><span class="line">Merge: read mrtmp.wcseq-res-1</span><br><span class="line">Merge: read mrtmp.wcseq-res-2</span><br><span class="line">master: Map/Reduce task completed</span><br><span class="line">14.59user 3.78system 0:14.81elapsed</span><br></pre></td></tr></table></figure><p>输出结果将保存在文件<code>mrtmp.wxseq</code>中。如果代码实现是正确的，则执行下面的命令将输出下面的信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sort -n -k2 mrtmp.wcseq | tail -10</span><br><span class="line">he: 34077</span><br><span class="line">was: 37044</span><br><span class="line">that: 37495</span><br><span class="line">I: 44502</span><br><span class="line">in: 46092</span><br><span class="line">a: 60558</span><br><span class="line">to: 74357</span><br><span class="line">of: 79727</span><br><span class="line">and: 93990</span><br><span class="line">the: 154024</span><br></pre></td></tr></table></figure><p>执行下面的命令可以删除输出文件和所有中间文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm mrtmp.*</span><br></pre></td></tr></table></figure><p>为了方便测试，可以执行下面的命令，并报告程序的正确与否。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash ./test-wc.sh</span><br></pre></td></tr></table></figure><h2 id="第三部分：分发MapReduce-task"><a href="#第三部分：分发MapReduce-task" class="headerlink" title="第三部分：分发MapReduce task"></a>第三部分：分发MapReduce task</h2><p>我们当前的代码实现在一个时刻只运行一个map和reduce的task。Map/Reduce最大的卖点之一就是它可以自动地将顺序执行的代码并行化，而免去了开发者的额外工作。在这部分实验中，我们要实现另一个版本的MapReduce，将工作划分成多个worker线程，使用多核并行执行。尽管不能与现实MapReduce的部署一样，在多台机器上分布式部署，我们可以使用RPC来模拟分布式计算。</p><p><code>mapreduce/master.go</code>中的代码主要用于管理一个MapReduce的job。课程在<code>mapreduce/worker.go</code>的代码中提供了一个完整的worker线程的代码，并在<code>mapreduce/common_rpc.go</code>中提供了处理RPC的代码。</p><p>我们的工作是实现<code>mapreduce/schedule.go</code>中的<code>schedule()</code>函数。master在一个MapReduce的job运行期间，两次调用<code>schedule()</code>，一次是为了Map操作，一次是为了Reduce操作。<code>schedule()</code>的功能是将task分发到可用的worker上执行。一般来说，task的数量多于worker线程的数量，因此<code>schedule()</code>必须每次给一个worker分配一组task，并且只有当所有的task都执行完时，<code>schedule()</code>才可以返回。</p><p><code>schedule()</code>通过读取参数<code>registerChan</code>获取worker的集合。该channel为每个worker生成一个包含worker的RPC地址的字符串。某些worker可能在调用<code>schedule()</code>前就已经存在，而有些可能在<code>schedule()</code>运行期间被启动。<code>schedule()</code>需要使用所有的worker，包括那些在启动之后出现的。</p><p>使用<code>mapreduce/common_rpc.go</code>中的<code>call()</code>向一个worker发送一个RPC请求。第一个参数是worker的地址，从<code>registerChan</code>中获取。第二个参数是<code>Worker.DoTask</code>。第三个参数是结构体<code>DoTaskArgs</code>，最后一个参数是<code>nil</code>。</p><p>在这部分我们只需要修改<code>schedule.go</code>，如果修改了其他文件，比如debug部分，需要在提交测试之前还原到初始内容。</p><p>为了测试代码，我们使用与第一部分相同的测试套件，但是需要将<code>-run Sequential</code>替换成<code>-run Basic</code>。这回执行不包含worker失效的分布式测试代码，代替前面运行的顺序模式代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> test -run TestBasic</span><br></pre></td></tr></table></figure><blockquote><p>提示：<a href="https://golang.org/pkg/net/rpc/" target="_blank" rel="noopener">RPC package</a> 记录了Go的RPC包。</p><p>提示：<code>schedule()</code>需要向并行的worker发送RPC，以便worker可能并发运行task。我们可以在 <a href="http://golang.org/doc/effective_go.html#concurrency" target="_blank" rel="noopener">Concurrency in Go</a>上找到实现这一目标的语句。</p><p>提示：<code>schedule()</code>必须等待一个worker执行结束，才能给该worker分配下一个task。我们可以发现Go的channel很有用。</p><p>提示：我们可以发现 <a href="https://golang.org/pkg/sync/#WaitGroup" target="_blank" rel="noopener">sync.WaitGroup</a> 很有帮助。</p><p>提示：追踪bug最简单的方法是插入打印状态信息的语句(可调用<code>common.go</code>中的<code>debug</code>)，执行命令<code>go test -run TestBasic &gt; out</code>收集文件中的输出数据，并思考输出的内容与理解实现的代码是否匹配。最后一步思考是很重要的。</p><p>提示：为了检测代码是否包含竞争状态，运行Go的<a href="https://golang.org/doc/articles/race_detector.html" target="_blank" rel="noopener">race detector</a>：<code>go test -race -run TestBasic &gt; out</code></p><p>注意：课程给出的代码是在一个UNIX进程下执行worker线程，并可利用一台机器的多核。需要进行某些调整，以在多台机器上利用网络通信运行worker。RPC需要使用TCP而不是UNIX-domain的socket。需要在所有的机器上启动worker，并且所有的机器需要通过某种网路文件系统共享存储。</p></blockquote><h2 id="第四部分：处理worker失效"><a href="#第四部分：处理worker失效" class="headerlink" title="第四部分：处理worker失效"></a>第四部分：处理worker失效</h2><p>这部分我们将使master处理失效的worker。MapReduce以一种相对容易的方式处理，因为worker不会保存持久的状态信息。如果一个worker失效了，master发送给该worker的任何RPC也将失效，由于一个timeout。因此，如果master发送的RPC失效了，master需要将分配给失效worker的task重新分配给另一个worker。</p><p>一个RPC失效不一定代表对应的worker不行执行task，worker可能已经执行了，但是回应丢失了，或者work仍然在执行而master的RPC超时了。因此，可能导致两个worker接收到相同的task，计算，并生成输出数据。一个map或者reduce函数的两次调用，会生成相同的输出结果(即map和reduce函数是函数式的)。所以如果后续处理去读一个输出或者读取另一个，不会发生不一致性。此外，MapReduce的框架保证了map和reduce的函数输出操作是原子性的：输出文件要么是不存在，要么是包含map或者reduce函数的一次执行的全部输出内容(实验代码并非真正实现了这一点，只是在task结束时worker失效，因此不存在一个任务的并发执行)。</p><blockquote><p>我们不需要处理master的失效。使master具备容错较为困难，因为master需要维持状态信息，以便在失效后进行操作恢复。后面的实验致力于解决这一问题。</p></blockquote><p>我们实现的代码必须通过<code>test_test.go</code>中的两个测试案例。第一个案例测试了一个worker的失效，第二个测试了多个worker的失效。这些测试案例会阶段性地启动新的worker，这样master可以继续向下运行，但是在处理完一部分task后这些worker失效。执行下面的命令运行这些测试：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> test -run Failure</span><br></pre></td></tr></table></figure><p>在这部分我们只需要修改<code>schedule.go</code>，如果修改了其他文件，比如debug部分，需要在提交测试之前还原到初始内容。</p><h2 id="运行所有的测试"><a href="#运行所有的测试" class="headerlink" title="运行所有的测试"></a>运行所有的测试</h2><p>我们可以执行脚本<code>src/main/test-mr.sh</code>来运行所有的测试案例。正确的代码实现输出信息类似于下面的内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bash ./test-mr.sh</span><br><span class="line">==&gt; Part I</span><br><span class="line">ok  mapreduce3.053s</span><br><span class="line"></span><br><span class="line">==&gt; Part II</span><br><span class="line">Passed test</span><br><span class="line"></span><br><span class="line">==&gt; Part III</span><br><span class="line">ok  mapreduce1.851s</span><br><span class="line"></span><br><span class="line">==&gt; Part IV</span><br><span class="line">ok  mapreduce10.650s</span><br><span class="line"></span><br><span class="line">==&gt; Part V (challenge)</span><br><span class="line">Passed test</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      最近在自学MIT6.824的分布式系统课程，翻译自课程主页，第一节课讲得是MapReduce并行计算框架的基本知识。这部分是实验的介绍，先作翻译，代码还在编写当中。
    
    </summary>
    
      <category term="MIT6.824" scheme="http://tankcat2.com/categories/MIT6-824/"/>
    
    
      <category term="MapReduce" scheme="http://tankcat2.com/tags/MapReduce/"/>
    
  </entry>
  
  <entry>
    <title>MIT 6.824 Lecture 1 MapReduce</title>
    <link href="http://tankcat2.com/2017/03/14/Lecture1_MapReduce/"/>
    <id>http://tankcat2.com/2017/03/14/Lecture1_MapReduce/</id>
    <published>2017-03-14T14:52:31.000Z</published>
    <updated>2017-05-06T13:05:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Distributed-System-Engineering"><a href="#Distributed-System-Engineering" class="headerlink" title="Distributed System Engineering"></a>Distributed System Engineering</h2><ol><li>什么是分布式系统？<ul><li>多个协同工作的计算机</li><li>大规模数据库，P2P文件共享，MapReduce，DNS，等</li><li>许多关键性基础设施也是分布式的！<a id="more"></a></li></ul></li><li>为什么需要分布式？<ul><li>为了连接物理上独立的实体</li><li>为了通过隔离实现安全</li><li>为了通过副本实现容错</li><li>为了通过并行CPU/内存/磁盘/网络提高吞吐量</li></ul></li><li>分布式遇到的问题？<ul><li>复杂：许多并发的部分</li><li>必须解决部分失效</li><li>难以实现潜在性能</li></ul></li><li>为什么开这门课？<ul><li>趣味性：难题+强大的解决方案</li><li>实用性：在实际系统中使用，受大型web网站的兴起驱动</li><li>科研性：许多进程+未解决的大问题</li><li>动手能力：在实验中构建复杂的系统</li></ul></li></ol><h2 id="Course-Structure"><a href="#Course-Structure" class="headerlink" title="Course Structure"></a>Course Structure</h2><ol><li>课程网址：<a href="http://pdos.csail.mit.edu/6.824" target="_blank" rel="noopener">http://pdos.csail.mit.edu/6.824</a></li><li>课题组人员<ul><li>Robert Morris, lecturer</li><li>Frans Kaashoek, lecturer</li><li>Lara Araujo, TA</li><li>Anish Athalye, TA</li><li>Srivatsa Bhat, TA</li><li>Daniel Ziegler, TA</li></ul></li></ol><ol><li>课程的组成部分<ul><li>课堂讲解</li><li>文献阅读</li><li>中期检测(2)</li><li>实验</li><li>期末考试(可选)</li></ul></li></ol><ol><li><p>课堂讲解</p><p>​大概念，论文讨论，实验</p></li><li><p>文献阅读</p><ul><li>研究性论文，经典+最新的</li><li>某些论文论述了关键概念和重要细节</li><li>课堂大部分时间是有关文献的讲解，请做好课前预习工作</li><li>每篇论文都会有一个简短的问题，需要向我们提交你的回答，问题与答案的提交截止时间为晚上10点</li></ul></li><li><p>中期检测是随堂的；期末考试定在考试周</p></li><li><p>实验目标</p><ul><li>对某些重要技术的深入理解</li><li>分布式编程</li><li>第一个实验室定于周五起</li><li>一个星期后一段时间</li></ul></li><li><p>实验内容</p><ul><li><p>Lab 1: MapReduce</p></li><li><p>Lab 2: 使用Raft，利用副本进行容错</p></li><li><p>容错key/value存储</p></li><li><p>共享key/value存储</p></li></ul></li><li><p>学期末可选的最终项目，一组2-3人</p><ul><li>最终的项目替代Lab 4</li><li>每个人考虑好一个项目，向我们清楚地阐述</li></ul></li><li><p>实验的份数取决于通过的测试案例个数</p></li></ol><ul><li>我们会提供测试案例，因此你需要知道你是否能完成地很好</li><li>注意：如果一个案例大部分情况下是通过的，少数情况不能通过，则取决于我们运行这个案例是否是通过的</li></ul><ol><li>实验的调试是耗时的</li></ol><ul><li>早日动手</li><li>在Piazza上进行提问<ul><li>在TA办公时间进行答疑</li></ul></li></ul><h2 id="Main-Topics"><a href="#Main-Topics" class="headerlink" title="Main Topics"></a>Main Topics</h2><ol><li><p>这个课程是关于基础架构的，可被应用使用。将分布式的概念从应用程序中抽象出来。三大抽象分别是：</p><ul><li><p>存储</p></li><li><p>通信</p></li><li><p>计算</p><p>[图解：用户，应用服务器，存储服务器]</p></li></ul></li><li><p>一些话题会反复出现</p></li><li><p>话题：实现</p><p>RPC，线程，并发控制</p></li><li><p>话题：性能</p><ul><li>理想目标：可扩展的吞吐<ul><li>Nx 服务器　$\rightarrow$  Nx 总吞吐，通过并行CPU，磁盘，网络</li><li>因此处理更大的负载只需购买更多的机器</li></ul></li><li>N的增大增加了扩展的难度<ul><li>负载不均衡</li><li>不可并行化的代码：初始化，交互</li><li>共享资源的瓶颈，比如网络</li></ul></li></ul></li><li><p>话题：容错</p><ul><li>1000个服务器，负载的网络　$\rightarrow$  总会有故障发生</li><li>我们想对应用程序隐藏这些失效</li><li>我们总需要：<ul><li>可用性——　应用程序可以继续运行</li><li>持续性——　当故障被修复时，应用程序的数据可被恢复使用</li></ul></li><li>大概念：备份服务器<ul><li>如果有服务器宕机了，客户机可使用其他服务器</li></ul></li></ul></li><li><p>话题：一致性</p><ul><li>通用基础设施需要定义明确的行为，比如“Get(k) yields the value from the most recent Put(k,v)”</li><li>实现良好的行为是困难的！<ul><li>多个副本服务器难以保持一致</li><li>在多级更新的过程中客户机可能出现宕机</li><li>服务器在比较尴尬的时出现宕机，比如在执行结束后和发送回复前</li><li>网络可能会使活跃的服务器看起来是不活跃的；存在“分裂的集群”的风险</li></ul></li><li>一致性与性能问题<ul><li>一致性需要通信，比如“get latest Put()”</li><li>强一致性可能会造成系统处理速度降低</li><li>高性能可能会带来若一致性</li></ul></li></ul><h2 id="Case-Study：MapReduce"><a href="#Case-Study：MapReduce" class="headerlink" title="Case Study：MapReduce"></a>Case Study：MapReduce</h2><p>MapReduce是6.824课程重要话题中的一个很好的示例，也是Lab 1主要内容。</p><ol><li><p>MapReduce Overview</p><ul><li><p>概念：在多个TB级数据集上进行长达多个小时的计算</p><ul><li><p>比如对爬行网页的图结构分析</p></li><li><p>只有在数千台计算机的同时计算下可行</p></li><li><p>通常不是分布式系统的专家也可以进行开发</p></li><li><p>分布式是比较令人头疼的，比如处理故障失效</p></li></ul></li><li>总体目标：非专家的程序员也可以轻松对数据处理进行划分，多个服务器并行处理，提高效率</li><li>用户自行定义Map和Reduce函数：顺序编码；通常是相当简单的</li><li>MR在数千台机器上运行，输入数据规模巨大，隐藏了分布实现细节</li></ul></li><li><p>MapReduce的抽象视图</p><p>输入数据被划分成M个文件</p><p>Input 1 $\rightarrow$ Map $\rightarrow$ a, 1 b,1 c,1</p><p>Input 2 $\rightarrow$ Map $\rightarrow$        b,1</p><p>Input 3 $\rightarrow$ Map $\rightarrow$ a,1        c,1</p><p>​                                 |      |     |</p><p>​                                        |    $\rightarrow$ Reduce $\rightarrow$ c,2</p><p>​                                       —- $\rightarrow$ Reduce $\rightarrow$ b,2</p><ul><li>MR为每个输入文件调用Map( )，生成k2,v2的集合<ul><li>中间临时数据</li><li>每一次Map( )的调用就是一个task</li></ul></li><li>MR为给定的可k2聚集所有的中间值v2，并将它们传送给Reduce( )</li><li>Reduce( )生成最终输出结果<k2,v3>的集合，并存储在R个输出文件中</k2,v3></li></ul></li><li><p>示例：单词统计</p><ul><li>输入是数千个文本文件</li><li>Map(k,v)<ul><li>将v划分成单个单词</li><li>对于每个单词w，emit(w,”1”)</li></ul></li><li>Reduce(k,v)<ul><li>emit(len(v))</li></ul></li></ul></li><li><p>MapReduce想用户隐藏了许多负载的实现细节</p><ul><li>启动服务器</li><li>追踪完成作业的task</li><li>数据移动</li><li>故障恢复</li></ul></li><li><p>MapReduce具有良好的可扩展性</p><ul><li>N个机器可以提供N倍的吞吐量<ul><li>假设M和R均大于N，即大量的输入文件与输出key</li><li>Map( )可以并行运行，并且不存在交互，Reduce( )同样如此</li><li>因此可以通过部署更多的机器来获取更高的吞吐量，而不是每个应用程序配置专用的高效并行。机器的代价来的比程序员低！</li></ul></li><li>什么可能会限制性能？<ul><li>我们关注可以优化的地方</li><li>CPU？内存？磁盘？网络？</li><li>在2004年，受限于“网络截面带款”<ul><li>[图解：服务器，网络交换机层次树]</li><li>需要注意的是所有的数据经过Map$\rightarrow$Reduce操作后均流经网络</li><li>根节点的交换机：100-200 GB/s</li><li>1800台机器，因此是55MB/s/机器</li></ul></li><li>因此当时是关注最小化网络数据传输量(如今的数据中心网络速度大大提高)</li></ul></li></ul></li><li><p>更多的细节(论文中的图1)</p><ul><li>master：将task分配给worker；记录所有中间数据的存放位置</li><li>M个Map task，R个Reduce task</li><li>输入数据存储在GFS中，每个Map的输入文件有三个拷贝副本</li><li>所有的机器均运行GFS和MR worker</li><li>task的数量多余worker</li><li>当旧的task处理完毕后，master分发新的task</li><li>Map worker通过哈希将中间数据划分为R个分区，并存储在本地磁盘</li><li>直到Map执行完毕后调回调用Reduce</li><li>master需要告知Reduce，从Map worker中读取中间数据分区</li><li>Reduce 将最终的结果写入GFS，一个Reduce task对应一个文件</li></ul></li><li><p>细节的设计是如何减少低速网络带来的影响？</p><ul><li>Map的输入数据是读取自存储在本地磁盘GFS中的副本，无需经由网络</li><li>中间数据只会在网络上传输一次，Map worker将数据写入本地磁盘，而不是GFS</li><li>中间数据被划分成多个文件，单个文件中存储大量的key，一次传输尽量多的数据更为高效</li></ul></li><li><p>如何获取良好的负载均衡？</p><ul><li>扩展的关键——N-1个服务器等待1个服务器的情况是较为糟糕的，但是某些task确实比其他task的处理时间更长</li><li>解决方法：令task的数量多余worker<ul><li>当worker处理完之前的task时，master分发新的task</li><li>则不存在一个太大的task以至于占据了全部处理时间</li><li>处理速度快的服务器比慢速的服务器处理更多的任务</li></ul></li></ul></li><li><p>什么是容错？</p><ul><li>在MR作业期间如果一个服务器宕机了怎么办？</li><li>隐藏故障是简易编程重要的一部分</li><li>为什么不从头开始重新执行作业呢？</li><li>MR只重新运行失效的Map和Reduce<ul><li>MR要求它们均是纯函数：<ul><li>不需要在调用期间保存状态信息</li><li>除了输入与输出数据，不需要进行其他文件读写操作</li><li>在task之间不需要进行通信</li></ul></li><li>则重新执行也可获得相同的输出结果</li></ul></li><li>以上有关纯函数的需求是MR的的主要限制，与其他并行编程框架相比，但是对于MR的简易性是至关重要的</li></ul></li><li><p>worker的故障恢复细节：</p></li></ol><ul><li><p>Map worker 宕机：</p><p>master发现ping worker无回应</p><p>宕机的worker的Map中间数据输出丢失，但是每个Reduce task需要这些数据</p><p>master重新运行，为输入数据在GFS上的副本分配task</p><p>某些Reduce worker可能已经读取了失效worker的中间数据，这里我们依赖于函数式与确定性的Map()！</p><p>如果Reduce已经获取全部的中间数据，则master不要重新运行Map，尽管后续的Reduce宕机可能需要强制失效的Map重新执行</p></li><li><p>Reduce worker宕机：</p><p>   已经执行结束的task没问题——与副本一同存储在GFS中</p><p>   master重新启动位于其他worker上的没有完成的task</p><ul><li><p>Reduce worker在写输出的过程中出现宕机：</p><p>GFS对输出进行原子重命名，以防止执行结束前数据可见，这样master在其他地方重新运行Reduce task</p></li></ul></li></ul></li></ol><ol><li><p>其他故障或者问题：</p><ul><li><p>如果master为同一个Map( ) task指定两个worker怎么办？</p><p>可能master错误地判断其中一个worker已经失效，从而只把其中一个worker的信息通知给Reduce worker</p></li><li><p>如果master为同一个Reduce( ) task指定两个worker怎么办？</p><p>则这两个worker会同时向GFS写相同的输出文件！GFS原子重命名可防止mixing；一个完整的文件是可见的</p></li><li><p>如果某个worker处理速率很慢——straggler？</p><p>可能是由于硬盘问题，此时master会为当前的几个task启动第二个副本</p></li><li><p>如果某个worker由于毁坏的h/w或者s/w导致输出结果不正确怎么办？</p><p>MR会认定为是CPU和软件的停止运行故障  </p></li></ul><ol><li><p>对于哪些应用程序，MapReduce不能表现良好的性能？</p><p>不是所有的应用程序都适合map/shuffle/reduce模式的</p><p>规模小的数据，处理代价高，不如不是网站后端的数据</p><p>大规模数据的少量更新，比如在一个大规模索引中添加少量文档</p><p>不可预知的读取 (Map和Reduce均不能选择输入)</p><p>频繁数据转移，比如page-rank，可以使用多个MR但是效率低下</p></li><li><p>结论</p><ul><li>MapReduce单方面使大集群计算流行<ul><li>不是最高效/灵活</li><li>良好的可扩展性</li><li>简易编程——故障与数据迁移均被隐藏</li></ul></li><li>这些是实践中的良好权衡，我们将在课程后面看到一些更先进的改进，实验愉快！</li></ul></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      最近在自学MIT6.824的分布式系统课程，翻译自课程主页，第一节课讲得是MapReduce并行计算框架的基本知识。后续会继续更新论文的阅读笔记与实验实现。
    
    </summary>
    
      <category term="MIT6.824" scheme="http://tankcat2.com/categories/MIT6-824/"/>
    
    
      <category term="MapReduce" scheme="http://tankcat2.com/tags/MapReduce/"/>
    
  </entry>
  
  <entry>
    <title>Go初探</title>
    <link href="http://tankcat2.com/2017/03/12/go/"/>
    <id>http://tankcat2.com/2017/03/12/go/</id>
    <published>2017-03-12T13:31:31.000Z</published>
    <updated>2017-05-05T11:27:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="包，变量和函数"><a href="#包，变量和函数" class="headerlink" title="包，变量和函数"></a>包，变量和函数</h3><ol><li><p>每个Go程序都是由<code>包</code>组成的，程序运行的入口是<code>main</code>。下面的程序使用并导入了包<code>fmt</code>和<code>math/rand</code>。一般地，包名与导入路径的最后一个目录一致，即<code>math/rand</code>包由<code>package rand</code>语句开始。</p><a id="more"></a><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"math/rand"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">"My favorite number is"</span>, rand.Int(<span class="number">10</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">My favorite number is <span class="number">1</span></span><br></pre></td></tr></table></figure><p>上述的导入语句是使用了圆括号进行组合导入，即<code>打包</code>导入。也可以编写成多个导入语句，即：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"math/rand"</span></span><br></pre></td></tr></table></figure><p>在Go中，首字母大写的名称是被导出的，比如<code>Pi</code>是从包<code>math</code>中导出的名称 。在导入包之后，你只能访问包所导出的名称，任何包未导出的名称均不能被包外的代码访问。执行下面的代码会出错，需要将<code>math.pi</code>替换成<code>math.Pi</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span></span>&#123;</span><br><span class="line">  fmt.Println(math.pi)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">tmp/sandbox738653879/main.<span class="keyword">go</span>:<span class="number">9</span>: cannot refer to unexported name math.pi</span><br><span class="line">tmp/sandbox738653879/main.<span class="keyword">go</span>:<span class="number">9</span>: undefined: math.pi</span><br></pre></td></tr></table></figure></li><li><p>在Go中，函数可以没有参数，或者接受多个参数，在下面的例子中，<code>add</code>接受两个<code>int</code>类型的参数。需要注意的是，类型位于变量名之后。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span><span class="title">int</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x+y</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Println(add(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>当函数的两个或者连续多个参数是同一类型时，可以省略除了最后一个参数的其他参数的类型，比如<code>add</code>函数的参数可以重新写成<code>x, y int</code>。</p><p>此外，函数的返回值数量可以是任意多个，比如下面的例子<code>swap</code>函数返回了两个字符串。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="keyword">string</span>)</span><span class="params">(<span class="keyword">string</span>,<span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> y,x</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  a, b　:= swap(<span class="string">"hello"</span>,<span class="string">"world"</span>)</span><br><span class="line">  fmt.Println(a,b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">world hello</span><br></pre></td></tr></table></figure><p>Go的返回值可以被命名，并可像在函数体开头声明的变量那样使用。下面的例子中，返回值是两个int类型的变量x和y，函数内的<code>return</code>语句没有参数，返回各个变量的当前值，称为<code>裸返回</code>。裸返回语句只能用在类似下面例子中的短函数中，在长函数中使用会影响代码的可读性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(sum <span class="keyword">int</span>)</span><span class="params">(x, y <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">  x = sum * <span class="number">4</span> / <span class="number">9</span></span><br><span class="line">  y = sum - x</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Println(split(<span class="number">17</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="number">7</span> <span class="number">10</span></span><br></pre></td></tr></table></figure></li><li><p>关键字<code>var</code>用于定义变量，与函数的参数列表一样，类型放在变量名后面。下面的例子中定义了一个变量列表，<code>var</code>语句可以在包或者函数级别中使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">var</span> c, clojure, java <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> flag <span class="keyword">bool</span></span><br><span class="line">  fmt.Println(flag, c, clojure, java)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="literal">false</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>变量定义如果不包含初始值，则对应默认值，比如<code>int</code>的默认值为0，<code>bool</code>的默认值为false，<code>string</code>的默认值为””。</p><p>当变量定义包含初始值时，一个变量对应一个值。如果初始化使用的是表达式，则变量可以省略类型，从初始值中获得类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">var</span> flag, label <span class="keyword">bool</span> = <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> c, clojure, java = <span class="number">1</span>, <span class="string">"great"</span>, <span class="number">2.1</span></span><br><span class="line">  fmt.Println(flag, label, c, clojure, java)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="literal">true</span> <span class="literal">false</span> <span class="number">1</span> great <span class="number">2.1</span></span><br></pre></td></tr></table></figure><p>回顾<code>swap</code>例子中的main函数使用的操作符<code>:=</code>，对应地，a和b为<code>短声明变量</code>，该操作符可以在类型明确的地方替代<code>var</code>。<strong>需要注意的是，:=不能在函数外使用，函数外的每个语句都必须以关键字开始(<code>var</code>, <code>func</code>等)</strong>。</p></li><li><p>Go的基本类型如下：</p><ul><li>bool</li><li>string</li><li>int int8 int16 int32 int64 </li><li>uint uint8 uint16 uint32 uint64 uinttr</li><li>byte // unit8的别名</li><li>rune // int32的别名，代表一个Unicode码</li><li>float32 float64</li><li>complex64 complex128</li></ul><p><code>int</code>，<code>uint</code>和<code>uintptr</code>类型在32位的系统上一般是32位，在64位系统上是64位。当需要使用一个整数时，首选<code>int</code>，仅当有特殊情况时才使用定长整数类型或者无符号整数类型。</p><p>下面的例子展示了不同类型的变量，与<code>打包</code>导入一样，变量定义打包在一个语法块中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math/cmplx"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span>(</span><br><span class="line">Flag <span class="keyword">bool</span> = <span class="literal">false</span></span><br><span class="line">  MaxInt unit64 = <span class="number">1</span> &lt;&lt; <span class="number">64</span> - <span class="number">1</span></span><br><span class="line">  z <span class="keyword">complex128</span> = cmplx.Sqrt(<span class="number">-5</span> + <span class="number">12i</span>)</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> f = <span class="string">"%T(%v)\n"</span></span><br><span class="line">  fmt.Printf(f, Flag, Flag)</span><br><span class="line">  fmt.Printf(f, MaxInt, MaxInt)</span><br><span class="line">  fmt.Printf(f, z, z)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="keyword">bool</span>(<span class="literal">false</span>)</span><br><span class="line"><span class="keyword">uint64</span>(<span class="number">18446744073709551615</span>)</span><br><span class="line"><span class="keyword">complex128</span>((<span class="number">2</span>+<span class="number">3i</span>))</span><br></pre></td></tr></table></figure><p>表达式<code>T(v)</code>将值v转换为类型T，比如下列的数值转换：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">42</span></span><br><span class="line"><span class="keyword">var</span> f <span class="keyword">float64</span> = <span class="keyword">float64</span>(i)</span><br><span class="line"><span class="keyword">var</span> u <span class="keyword">uint</span> = <span class="keyword">uint</span>(f)</span><br><span class="line"></span><br><span class="line">or simple</span><br><span class="line">i := <span class="number">42</span></span><br><span class="line">f := <span class="keyword">float64</span>(i)</span><br><span class="line">u := <span class="keyword">uint</span>(f)</span><br></pre></td></tr></table></figure><p>与C语言不同的是，Go在不同类型的变量之间赋值时需要进行显示转换。比如下面的例子中，未将<code>x*x+y*y</code>显示转换成<code>float64</code>而报错。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x, y <span class="keyword">int</span> = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line"><span class="keyword">var</span> f <span class="keyword">float64</span> = math.Sqrt((x*x + y*y))</span><br><span class="line"><span class="keyword">var</span> z <span class="keyword">uint</span> = <span class="keyword">uint</span>(f)</span><br><span class="line">fmt.Println(x, y, z)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">tmp/sandbox259072833/main.<span class="keyword">go</span>:<span class="number">10</span>: cannot use x * x + y * y (<span class="keyword">type</span> <span class="keyword">int</span>) as <span class="keyword">type</span> <span class="keyword">float64</span> in argument to math.Sqrt</span><br></pre></td></tr></table></figure><p>定义一个变量却不显示指定其类型时(使用<code>:=</code>或者<code>var =</code>表达式语法)，变量的类型由右侧的值推到得出。<br>当右侧的数值定义了类型时，新变量的类型与其相同，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">j := i <span class="comment">// j 也是一个 int</span></span><br></pre></td></tr></table></figure><p>但是当右侧的数值包含了未指明类型的数字常量时，新变量可能是int，float64或者complex128。这取决于常量的精度：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">42</span>           <span class="comment">// int</span></span><br><span class="line">f := <span class="number">3.142</span>        <span class="comment">// float64</span></span><br><span class="line">g := <span class="number">0.867</span> + <span class="number">0.5i</span> <span class="comment">// complex128</span></span><br></pre></td></tr></table></figure><p>在Go中，常量的定义使用<code>const</code>关键字，常量可以是字符，字符串，布尔或者数字类型的值，但是不可以用<code>:=</code>语法定义。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">const</span> Pi = <span class="number">3.14</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> World = <span class="string">"世界"</span></span><br><span class="line">  fmt.Println(<span class="string">"Hello"</span>, World)</span><br><span class="line">  fmt.Println(<span class="string">"Happy"</span>, Pi, <span class="string">"Day"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> Truth = <span class="literal">true</span></span><br><span class="line">  fmt.Println(<span class="string">"Go rules?"</span>, Truth)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">Hello 世界</span><br><span class="line">Happy <span class="number">3.14</span> Day</span><br><span class="line">Go rules? <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>数值常量一般是高精度的<code>值</code>。一个未指定类型的常量由上下文来决定其类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line">   <span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line">   <span class="keyword">const</span>(</span><br><span class="line">   Big = <span class="number">1</span> &lt;&lt; <span class="number">100</span></span><br><span class="line">     Small = Big &gt;&gt; <span class="number">99</span></span><br><span class="line">   )</span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">needInt</span><span class="params">(x <span class="keyword">int</span>)</span><span class="title">int</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> x * <span class="number">10</span> + <span class="number">1</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">needFloat</span><span class="params">(x <span class="keyword">float64</span>)</span><span class="title">float64</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> x * <span class="number">0.1</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     fmt.Println(needInt(Small))</span><br><span class="line">     fmt.Println(needFloat(Small))</span><br><span class="line">     fmt.Println(needFloat(Big))</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   output:</span><br><span class="line">   <span class="number">21</span></span><br><span class="line">   <span class="number">0.2</span></span><br><span class="line">   <span class="number">1.2676506002282295e+29</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><ol><li><p>Go只有一种循环结构<code>for</code>。基本<code>for</code>循环包含三个由分号分开的组成部分：</p><ul><li>初始化语句：在第一次循环执行前被执行</li><li>循环条件表达式：每轮迭代开始前被求值</li><li>后置语句：每轮迭代后执行</li></ul><p>初始化语句一般是一个短变量声明，该变量仅在整个循环语句中可见。如果表达式的值变为false，迭代终止。与C，Java等语言不同的是，<code>for</code>语句的三个组成部分并不需要用括号括起来，但循环体必须用<code>{ }</code>括起来。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">sum += i</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(sum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="number">45</span></span><br></pre></td></tr></table></figure><p>此外，循环的初始化语句与后置语句均是可选的，比如上面的例子可以改写成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum := <span class="number">1</span> </span><br><span class="line"><span class="keyword">for</span> ; sum &lt; <span class="number">1000</span>; &#123;</span><br><span class="line">    sum += sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于以上，可以省略分号，则功能类似于其他语言中的<code>while</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span>　sum &lt; <span class="number">1000</span> &#123;</span><br><span class="line">     sum += sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若省略了循环条件，循环不会结束，因此可用更简洁的方式表达死循环。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>与<code>for</code>一样，Go的<code>if</code>语句也不要求用<code>( )</code>将条件括起来，但是还是需要用<code>{ }</code>将语句块括起来。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqrt</span><span class="params">(x <span class="keyword">float64</span>)</span><span class="title">string</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> sqrt(-x)+ <span class="string">"i"</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprint(math.Sqrt(x))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Println(sqrt(<span class="number">2</span>), sqrt(<span class="number">-4</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br></pre></td></tr></table></figure><p><code>if</code>语句可以在条件之前执行一个简单语句，该语句定义的变量的作用域仅在<code>if</code>范围之内，比如下面的例子，若把<code>return lim</code>改成<code>return v</code>便会报错。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(x, n , lim <span class="keyword">float64</span>)</span><span class="title">float64</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim　&#123;</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> lim</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Println(</span><br><span class="line">    pow(<span class="number">3</span>, <span class="number">2</span>, <span class="number">10</span>),</span><br><span class="line">      pow(<span class="number">3</span>, <span class="number">3</span>, <span class="number">20</span>)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="number">9</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><p>在<code>if</code>的便捷语句定义的变量同样可以在任何对应的<code>else</code>块中使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(x, n, lim <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line"><span class="keyword">return</span> v</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%g &gt;= %g\n"</span>, v, lim)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里开始就不能使用 v 了</span></span><br><span class="line"><span class="keyword">return</span> lim</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(</span><br><span class="line">pow(<span class="number">3</span>, <span class="number">2</span>, <span class="number">10</span>),</span><br><span class="line">pow(<span class="number">3</span>, <span class="number">3</span>, <span class="number">20</span>),</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="number">27</span> &gt;= <span class="number">20</span> <span class="comment">//需要注意的是，两个pow调用都在main调用fmt.Println前执行完毕了。</span></span><br><span class="line"><span class="number">9</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><p>练习：循环和函数。</p><blockquote><p>作为练习函数和循环的简单途径，用牛顿法实现开方函数。</p><p>在这个例子中，牛顿法是通过一个初始点z，然后然后重复以下过程求Sqrt(x)的近似值：</p><p>$z = z - \frac{z^2-x}{2z}$</p><p>为了做到这个，只需要重复计算10次。并且观察不同的值(1,2,3,…)是如何逐步逼近结果的。然后，修改循环条件，使得当值停止改变(或者改变非常小)的时候退出循环。观察迭代次数是否变化。结果与math.Sqrt接近吗？</p></blockquote><p>指定迭代次数版本：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sqrt</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">z:=<span class="keyword">float64</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++ &#123;</span><br><span class="line">z = z - (z*z-x)/(<span class="number">2</span>*z)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> z</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(Sqrt(<span class="number">2</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="number">1.4142135623730951</span></span><br></pre></td></tr></table></figure><p>无限逼近版本：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sqrt</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">z:=<span class="keyword">float64</span>(<span class="number">1</span>)</span><br><span class="line">y:= z - (z*z-x)/(<span class="number">2</span>*z)</span><br><span class="line"><span class="keyword">for</span> math.Abs(y-z)&gt; <span class="number">1e-10</span> &#123;</span><br><span class="line">z = y ;</span><br><span class="line">y = z - (z*z-x)/(<span class="number">2</span>*z)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="number">1.4142135623730951</span></span><br></pre></td></tr></table></figure></li><li><p><code>switch</code>分支语句，除非以<code>fallthrough</code>语句结束，否则分支会自动终止。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Print(<span class="string">"Go runs on "</span>)</span><br><span class="line"><span class="keyword">switch</span> os := runtime.GOOS; os &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"darwin"</span>:</span><br><span class="line">fmt.Println(<span class="string">"OS X."</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">"linux"</span>:</span><br><span class="line">fmt.Println(<span class="string">"Linux."</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// freebsd, openbsd,</span></span><br><span class="line"><span class="comment">// plan9, windows...</span></span><br><span class="line">fmt.Printf(<span class="string">"%s."</span>, os)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">Go runs on nacl.</span><br></pre></td></tr></table></figure><p><code>switch</code>的条件从上到下的执行，当匹配成功的时候停止。例如，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> i &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span> :</span><br><span class="line">  <span class="keyword">case</span> f() :</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当i==0时不会调用f。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"When's Saturday?"</span>)</span><br><span class="line">today := time.Now().Weekday()<span class="comment">//计算当前的星期几</span></span><br><span class="line"><span class="keyword">switch</span> time.Saturday &#123;</span><br><span class="line"><span class="keyword">case</span> today + <span class="number">0</span>:</span><br><span class="line">fmt.Println(<span class="string">"Today."</span>)</span><br><span class="line"><span class="keyword">case</span> today + <span class="number">1</span>:</span><br><span class="line">fmt.Println(<span class="string">"Tomorrow."</span>)</span><br><span class="line"><span class="keyword">case</span> today + <span class="number">2</span>:</span><br><span class="line">fmt.Println(<span class="string">"In two days."</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"Too far away."</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">When<span class="string">'s Saturday?</span></span><br><span class="line"><span class="string">Too far away.</span></span><br></pre></td></tr></table></figure><p>没有条件的switch与<code>switch　true</code>一样。这一构造使得可以用更清晰的形式来编写长的<code>it-then-elese</code>链。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  t := time.Now()</span><br><span class="line">  <span class="keyword">switch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> t.Hour() &lt; <span class="number">12</span>:</span><br><span class="line">      fmt.Println(<span class="string">"Good Morning!"</span>)</span><br><span class="line">      <span class="keyword">case</span> t.Hour &lt; <span class="number">17</span> :</span><br><span class="line">      fmt.Println(<span class="string">"Good Afternoon!"</span>)</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">      fmt.Println(<span class="string">"Good Evening!"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">Good Morning!</span><br></pre></td></tr></table></figure></li><li><p><code>defer</code>语句会延迟函数的执行，直到上层函数返回，延迟调用的参数会立刻生成，但是在上层函数返回前，函数都不会调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"world"</span>)</span><br><span class="line">fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure><p>延迟的函数调用被压入一个栈中，当函数返回时，会按照先进后出的顺序调用被延迟的函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">"counting"</span>)</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++ &#123;</span><br><span class="line">      <span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(<span class="string">"done"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">counting</span><br><span class="line">done</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="复杂类型"><a href="#复杂类型" class="headerlink" title="复杂类型"></a>复杂类型</h3><ol><li><p>Go使用<code>pointer</code>来保存变量的内存地址，即指针。类型<code>* T</code>是指向类型T的值的指针，默认值为<code>nil</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span></span><br></pre></td></tr></table></figure><p><code>＆</code>符号会生成一个指向其作用对象的指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">42</span></span><br><span class="line">p = &amp;i</span><br></pre></td></tr></table></figure><p><code>*</code>符号表示指针指向的底层的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(*p) <span class="comment">// 通过指针p读取i</span></span><br><span class="line">*p = <span class="number">21</span> <span class="comment">//通过指针p设置i</span></span><br></pre></td></tr></table></figure><p>以上就是常说的间接引用与或非直接引用。与C不同的是，Go没有指针运算。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  i, j := <span class="number">42</span>, <span class="number">2701</span></span><br><span class="line"> p := &amp;i</span><br><span class="line">  fmt.Println(*p)<span class="comment">//通过指针读取i的值</span></span><br><span class="line">  *p = <span class="number">21</span> <span class="comment">//通过指针修改i的值</span></span><br><span class="line">  p = &amp;j <span class="comment">//修改指针的指向</span></span><br><span class="line">  *p = *p / <span class="number">37</span> <span class="comment">// 修改j的值</span></span><br><span class="line">  fmt.Println(j)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="number">42</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">73</span></span><br></pre></td></tr></table></figure></li><li><p>结构体<code>struct</code>是一个字段的集合，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">//定义一个坐标的结构体</span></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span>&#123;</span><br><span class="line">  X <span class="keyword">int</span></span><br><span class="line">  Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Println(Vertex&#123;<span class="number">1</span>,<span class="number">2</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">&#123;<span class="number">1</span> <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><p>结构体字段使用点号进行访问。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v := Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">v.X = <span class="number">4</span></span><br><span class="line">fmt.Println(v.X)</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p>结构体字段也可以通过指针来访问，通过指针间接的访问是透明的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v := Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">p := &amp;v</span><br><span class="line">p.X = <span class="number">1e9</span></span><br><span class="line">fmt.Println(v)</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">&#123;<span class="number">1000000000</span> <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><p>结构体文法表示通过结构体字段的值作为列表来分配一个结构体。语法可以只列出部分字段。字段名的顺序无关。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>(</span><br><span class="line">v1 = Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">  v2 = Vertex&#123;X : <span class="number">1</span>&#125; <span class="comment">//Y : 0 被省略</span></span><br><span class="line">  v3 = Vertex&#123; &#125; <span class="comment">//X : 0 和 Y : 0</span></span><br><span class="line">  p = &amp;Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">//类型为*Vertex</span></span><br><span class="line">)</span><br><span class="line">fmt.Println(v1, p ,v2, v3)</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">&#123;<span class="number">1</span> <span class="number">2</span>&#125; &amp;&#123;<span class="number">1</span> <span class="number">2</span>&#125; &#123;<span class="number">1</span> <span class="number">0</span>&#125; &#123;<span class="number">0</span> <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>数组是一个有n个类型为T的值的集合，记为<code>[n]T</code>。表达式<code>var a [10]int</code> 定义变量a是一个有十个整数的数组。数组的长度是类型的一部分，因此数组一旦定义不能改变大小。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a [<span class="number">2</span>]<span class="keyword">string</span></span><br><span class="line">  a[<span class="number">0</span>] = <span class="string">"Hello"</span></span><br><span class="line">  a[<span class="number">1</span>] = <span class="string">"World"</span></span><br><span class="line">  fmt.Println(a[<span class="number">0</span>],a[<span class="number">1</span>])</span><br><span class="line"> fmt.Prinlnt(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">Hello World</span><br><span class="line">[Hello World]</span><br></pre></td></tr></table></figure></li><li><p><code>[n]T</code>指向一个序列的值，并包含长度信息。数组<code>[]T</code>是一个元素类型为T的slice。<code>len(s)</code>返回slice s的长度。slice的零值为nil，其长度和容量均为0。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  s := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span> ,<span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">  fmt.Println(<span class="string">"s == "</span>, s)</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span> ; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">      fmt.Println(<span class="string">"s[%d] == %d\n"</span>, i, s[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">s == [<span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span> <span class="number">11</span> <span class="number">13</span>]</span><br><span class="line">s[<span class="number">0</span>] == <span class="number">2</span></span><br><span class="line">s[<span class="number">1</span>] == <span class="number">3</span></span><br><span class="line">s[<span class="number">2</span>] == <span class="number">5</span></span><br><span class="line">s[<span class="number">3</span>] == <span class="number">7</span></span><br><span class="line">s[<span class="number">4</span>] == <span class="number">11</span></span><br><span class="line">s[<span class="number">5</span>] == <span class="number">13</span></span><br></pre></td></tr></table></figure><p>slice可以包含任意类型的元素，包括另外一个slice。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printBoard</span><span class="params">(s [][]<span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span> ; i &lt; <span class="built_in">len</span>(s) ; i++ &#123;</span><br><span class="line">      fmt.Printf(<span class="string">"%s\n"</span>, strings.Join(s[i], <span class="string">" "</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  game := [][]<span class="keyword">string</span>&#123;</span><br><span class="line">      []<span class="keyword">string</span>&#123;<span class="string">"_"</span>, <span class="string">"_"</span>. <span class="string">"_"</span>&#125;,</span><br><span class="line">        []<span class="keyword">string</span>&#123;<span class="string">"_"</span>, <span class="string">"_"</span>. <span class="string">"_"</span>&#125;,</span><br><span class="line">        []<span class="keyword">string</span>&#123;<span class="string">"_"</span>, <span class="string">"_"</span>. <span class="string">"_"</span>&#125;,</span><br><span class="line">  &#125;</span><br><span class="line">  game[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">"X"</span></span><br><span class="line">  game[<span class="number">2</span>][<span class="number">2</span>] = <span class="string">"O"</span></span><br><span class="line">    game[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">"X"</span></span><br><span class="line">    game[<span class="number">1</span>][<span class="number">0</span>] = <span class="string">"O"</span></span><br><span class="line">  game[<span class="number">0</span>][<span class="number">2</span>] = <span class="string">"X"</span></span><br><span class="line">  printBoard(game)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">X _ X</span><br><span class="line">O _ _</span><br><span class="line">X _ O</span><br></pre></td></tr></table></figure><p>slice可以重新切片，创建一个新的slice值指向相同的数组。表达式<code>s[lo:hi]</code>表示从lo到hi-1的slice元素，含前端，不包含后端，因此，<code>s[lo:lo]</code>是空，<code>s[lo:lo+1]</code>有一个元素。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  s := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">  fmt.Println(<span class="string">"s =="</span>, s)</span><br><span class="line">  fmt.Println(<span class="string">"s[1:4] == "</span>, s[<span class="number">1</span> : <span class="number">4</span>])</span><br><span class="line">  <span class="comment">//省略前端，表示从0开始</span></span><br><span class="line">  fmt.Println(<span class="string">"s[:3] =="</span>, s[:<span class="number">3</span>])</span><br><span class="line">  <span class="comment">//省略后端，表示从当前位置开始，到len(s)结束</span></span><br><span class="line">  fmt.Println(<span class="string">"s[4:] =="</span>, s[<span class="number">4</span>:])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">s == [<span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span> <span class="number">11</span> <span class="number">13</span>]</span><br><span class="line">s[<span class="number">1</span>:<span class="number">4</span>] == [<span class="number">3</span> <span class="number">5</span> <span class="number">7</span>]</span><br><span class="line">s[:<span class="number">3</span>] == [<span class="number">2</span> <span class="number">3</span> <span class="number">5</span>]</span><br><span class="line">s[<span class="number">4</span>:] == [<span class="number">11</span> <span class="number">13</span>]</span><br></pre></td></tr></table></figure><p>可以使用函数<code>make</code>创建slice。这会分配一个全为零值的数组，并返回一个slice指向这个数组：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>为了指定容量，可以传递第三个参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s <span class="keyword">string</span>, x []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s len=%d cap=%d %v\n"</span>,</span><br><span class="line">s, <span class="built_in">len</span>(x), <span class="built_in">cap</span>(x), x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">printSlice(<span class="string">"a"</span>, a)</span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">printSlice(<span class="string">"b"</span>, b)</span><br><span class="line">c := b[:<span class="number">2</span>]</span><br><span class="line">printSlice(<span class="string">"c"</span>, c)</span><br><span class="line">d := c[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">printSlice(<span class="string">"d"</span>, d)</span><br><span class="line">｝</span><br><span class="line">  </span><br><span class="line">output:</span><br><span class="line">a <span class="built_in">len</span>=<span class="number">5</span> <span class="built_in">cap</span>=<span class="number">5</span> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">b <span class="built_in">len</span>=<span class="number">0</span> <span class="built_in">cap</span>=<span class="number">5</span> []</span><br><span class="line">c <span class="built_in">len</span>=<span class="number">2</span> <span class="built_in">cap</span>=<span class="number">5</span> [<span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">d <span class="built_in">len</span>=<span class="number">3</span> <span class="built_in">cap</span>=<span class="number">3</span> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>向slice的末尾添加元素是一种常见的操作，使用函数<code>append(s []T, vs ...T)[]T</code>，第一个参数s是一个类型为T的slice，其余类型为T的值会附加到该slice的末尾，返回一个包含原slice所有元素加上新添加的元素的slice。如果s的底层数组太小，而不能容纳所有值时，会分配一个更大的数组，返回的slice会指向这个新分配的数组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s <span class="keyword">string</span>, x []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s len=%d cap=%d %v\n"</span>,</span><br><span class="line">s, <span class="built_in">len</span>(x), <span class="built_in">cap</span>(x), x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a []<span class="keyword">int</span></span><br><span class="line">  printSlice(<span class="string">"a"</span>, a)</span><br><span class="line">  a = <span class="built_in">append</span>(a, <span class="number">0</span>)</span><br><span class="line">  printSlice(<span class="string">"a"</span>, a)</span><br><span class="line">  a = <span class="built_in">append</span>(a, <span class="number">1</span>)</span><br><span class="line">  printSlice(<span class="string">"a"</span>, a)</span><br><span class="line">  a = <span class="built_in">append</span>(a, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">  printSlice(<span class="string">"a"</span>, a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">a <span class="built_in">len</span>=<span class="number">0</span> <span class="built_in">cap</span>=<span class="number">0</span> []</span><br><span class="line">a <span class="built_in">len</span>=<span class="number">1</span> <span class="built_in">cap</span>=<span class="number">2</span> [<span class="number">0</span>]</span><br><span class="line">a <span class="built_in">len</span>=<span class="number">2</span> <span class="built_in">cap</span>=<span class="number">2</span> [<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line">a <span class="built_in">len</span>=<span class="number">5</span> <span class="built_in">cap</span>=<span class="number">8</span> [<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br></pre></td></tr></table></figure></li><li><p><code>for</code>循环的<code>range</code>格式可以对slice或者map进行迭代循环。当使用<code>for</code>循环遍历一个slice时，每次迭代<code>range</code>将返回两个值，一个是当前下标，一个是该下标所对应元素的一个拷贝。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">var</span> pow = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span> ,<span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> i, v := <span class="keyword">range</span> pow &#123;</span><br><span class="line">      fmt.Printf(<span class="string">"2**%d = %d\n"</span>, i, v)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="number">2</span>**<span class="number">0</span> = <span class="number">1</span></span><br><span class="line"><span class="number">2</span>**<span class="number">1</span> = <span class="number">2</span></span><br><span class="line"><span class="number">2</span>**<span class="number">2</span> = <span class="number">4</span></span><br><span class="line"><span class="number">2</span>**<span class="number">3</span> = <span class="number">8</span></span><br><span class="line"><span class="number">2</span>**<span class="number">4</span> = <span class="number">16</span></span><br><span class="line"><span class="number">2</span>**<span class="number">5</span> = <span class="number">32</span></span><br><span class="line"><span class="number">2</span>**<span class="number">6</span> = <span class="number">64</span></span><br><span class="line"><span class="number">2</span>**<span class="number">7</span> = <span class="number">128</span></span><br></pre></td></tr></table></figure><p>练习：slice</p><blockquote><p>实现Pic。返回一个长度为dy的slice，其中每个元素是一个长度为dx且元素类型为8位无符号整数的slice。在运行程序时，它会将每个整数作为对应像素的灰度值，并显示这个slice所对应的图像。</p><p>计算每个像素的灰度值的方法由你决定；几个有意思的选择包括 <code>(x+y)/2</code>、<code>x*y</code> 和 <code>x^y</code> 。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"golang.org/x/tour/pic"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pic</span><span class="params">(dx, dy <span class="keyword">int</span>)</span> [][]<span class="title">uint8</span></span> &#123;</span><br><span class="line">    result := <span class="built_in">make</span>([][]<span class="keyword">uint8</span>, dy)</span><br><span class="line">    <span class="keyword">for</span> i:= <span class="number">0</span> ; i &lt; dy ; i++ &#123;</span><br><span class="line">          result[i] = <span class="built_in">make</span>([]<span class="keyword">uint8</span>, dx)</span><br><span class="line">          <span class="keyword">for</span> j := <span class="number">0</span> ;j &lt; dx ; j++ &#123;</span><br><span class="line">              result[i][j] = <span class="keyword">uint8</span>(i*j)</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">pic.Show(Pic)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>map</code>映射键到值，使用<code>make</code>函数来创建，值为<code>nil</code>的map是空的，并且不能对其赋值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span>&#123;</span><br><span class="line">  Lat, Long <span class="keyword">float64</span></span><br><span class="line">&#125;<span class="comment">//经纬度结构体</span></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex　<span class="comment">//string到struct的映射</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Vertex)</span><br><span class="line">  m[<span class="string">"Bell Labs"</span>] = Vertex&#123;</span><br><span class="line">      <span class="number">40.68433</span>, <span class="number">-74.39967</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(m[<span class="string">"Bell Labs"</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">&#123;<span class="number">40.68433</span> <span class="number">-74.39967</span>&#125;</span><br></pre></td></tr></table></figure><p>map的文法与struct类似，但是必须要有键名。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span>&#123;</span><br><span class="line">  Lat, Long <span class="keyword">float64</span></span><br><span class="line">&#125;<span class="comment">//经纬度结构体</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex&#123;</span><br><span class="line">  <span class="string">"Bell Labs"</span> : Vertex&#123;</span><br><span class="line">      <span class="number">40.68433</span>, <span class="number">-74.39967</span>,<span class="comment">//逗号不可少</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"Google"</span> : Vertex&#123;</span><br><span class="line">       <span class="number">37.42202</span>, <span class="number">-122.08408</span>,<span class="comment">//逗号不可少</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Println(m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="keyword">map</span>[Bell Labs:&#123;<span class="number">40.68433</span> <span class="number">-74.39967</span>&#125; Google:&#123;<span class="number">37.42202</span> <span class="number">-122.08408</span>&#125;]</span><br></pre></td></tr></table></figure><p>顶级类型只是一个类型名，可以在文法的元素中省略它。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span>&#123;</span><br><span class="line">  Lat, Long <span class="keyword">float64</span></span><br><span class="line">&#125;<span class="comment">//经纬度结构体</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex&#123;</span><br><span class="line">  <span class="string">"Bell Labs"</span> : &#123;<span class="number">40.68433</span>, <span class="number">-74.39967</span>&#125;,</span><br><span class="line">  <span class="string">"Google"</span>:    &#123;<span class="number">37.42202</span>, <span class="number">-122.08408</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Println(m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="keyword">map</span>[Bell Labs:&#123;<span class="number">40.68433</span> <span class="number">-74.39967</span>&#125; Google:&#123;<span class="number">37.42202</span> <span class="number">-122.08408</span>&#125;]</span><br></pre></td></tr></table></figure><p>在map中插入，删除元素，检测元素是否存在。当从map中读取某个不存在的键时，结果是map的元素类型的零值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">m[<span class="string">"Answer"</span>] = <span class="number">42</span></span><br><span class="line">fmt.Println(<span class="string">"The value:"</span>, m[<span class="string">"Answer"</span>])</span><br><span class="line">m[<span class="string">"Answer"</span>] = <span class="number">48</span></span><br><span class="line">fmt.Println(<span class="string">"The value:"</span>, m[<span class="string">"Answer"</span>])</span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">"Answer"</span>)</span><br><span class="line">fmt.Println(<span class="string">"The value:"</span>, m[<span class="string">"Answer"</span>])</span><br><span class="line">v, ok := m[<span class="string">"Answer"</span>]</span><br><span class="line">fmt.Println(<span class="string">"The value:"</span>, v, <span class="string">"Present?"</span>, ok)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">The value: <span class="number">42</span></span><br><span class="line">The value: <span class="number">48</span></span><br><span class="line">The value: <span class="number">0</span></span><br><span class="line">The value: <span class="number">0</span> Present? <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>练习：map</p><blockquote><p>实现WordCount。它应当返回一个含有 <code>s</code> 中每个 “词” 个数的 map。函数 <code>wc.Test</code> 针对这个函数执行一个测试用例，并输出成功还是失败。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"golang.org/x/tour/wc"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WordCount</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">int</span></span> &#123;</span><br><span class="line"> result := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">     words := strings.Fields(s)</span><br><span class="line">     <span class="keyword">for</span> _, word := <span class="keyword">range</span> words &#123;</span><br><span class="line">          result[word]++</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wc.Test(WordCount)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">PASS</span><br><span class="line"> f(<span class="string">"I am learning Go!"</span>) = </span><br><span class="line">  <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"I"</span>:<span class="number">1</span>, <span class="string">"am"</span>:<span class="number">1</span>, <span class="string">"learning"</span>:<span class="number">1</span>, <span class="string">"Go!"</span>:<span class="number">1</span>&#125;</span><br><span class="line">PASS</span><br><span class="line"> f(<span class="string">"The quick brown fox jumped over the lazy dog."</span>) = </span><br><span class="line">  <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"dog."</span>:<span class="number">1</span>, <span class="string">"the"</span>:<span class="number">1</span>, <span class="string">"quick"</span>:<span class="number">1</span>, <span class="string">"brown"</span>:<span class="number">1</span>, <span class="string">"fox"</span>:<span class="number">1</span>, <span class="string">"jumped"</span>:<span class="number">1</span>, <span class="string">"over"</span>:<span class="number">1</span>, <span class="string">"lazy"</span>:<span class="number">1</span>, <span class="string">"The"</span>:<span class="number">1</span>&#125;</span><br><span class="line">PASS</span><br><span class="line"> f(<span class="string">"I ate a donut. Then I ate another donut."</span>) = </span><br><span class="line">  <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"donut."</span>:<span class="number">2</span>, <span class="string">"Then"</span>:<span class="number">1</span>, <span class="string">"another"</span>:<span class="number">1</span>, <span class="string">"I"</span>:<span class="number">2</span>, <span class="string">"ate"</span>:<span class="number">2</span>, <span class="string">"a"</span>:<span class="number">1</span>&#125;</span><br><span class="line">PASS</span><br><span class="line"> f(<span class="string">"A man a plan a canal panama."</span>) = </span><br><span class="line">  <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"canal"</span>:<span class="number">1</span>, <span class="string">"panama."</span>:<span class="number">1</span>, <span class="string">"A"</span>:<span class="number">1</span>, <span class="string">"man"</span>:<span class="number">1</span>, <span class="string">"a"</span>:<span class="number">2</span>, <span class="string">"plan"</span>:<span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>函数也是值。可以像其他值一样传递，比如函数值可以作为函数的参数或者返回值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//函数作为参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compute</span><span class="params">(fn <span class="keyword">func</span>(<span class="keyword">float64</span>, <span class="keyword">float64</span>)</span> <span class="title">float64</span>) <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> fn(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">//函数作为返回值</span></span><br><span class="line">hypot := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(x*x + y*y)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(hypot(<span class="number">5</span>, <span class="number">12</span>))<span class="comment">//求平方和</span></span><br><span class="line">fmt.Println(compute(hypot))<span class="comment">//求平方和</span></span><br><span class="line">fmt.Println(compute(math.Pow))<span class="comment">//求3的4次方</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">81</span></span><br></pre></td></tr></table></figure><p>在Go中，函数可以是一个闭包，闭包是一个函数值，它引用函数体之外的变量。这个函数可以对该引用的变量进行访问和赋值，换句话说，这个函数被绑定在这个变量上。例如下例中，函数<code>adder</code>返回一个闭包，每个返回的闭包都被绑定到其各自的sum变量上。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">//返回值为函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span><span class="title">int</span></span>&#123;</span><br><span class="line">  sum := <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">      sum += x</span><br><span class="line">      <span class="keyword">return</span> sum</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  pos, neg := adder(), adder()</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++ &#123;</span><br><span class="line">      fmt.Println(</span><br><span class="line">        pos(i),</span><br><span class="line">         neg(<span class="number">-2</span>*i),</span><br><span class="line">        )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">-2</span></span><br><span class="line"><span class="number">3</span> <span class="number">-6</span></span><br><span class="line"><span class="number">6</span> <span class="number">-12</span></span><br><span class="line"><span class="number">10</span> <span class="number">-20</span></span><br><span class="line"><span class="number">15</span> <span class="number">-30</span></span><br><span class="line"><span class="number">21</span> <span class="number">-42</span></span><br><span class="line"><span class="number">28</span> <span class="number">-56</span></span><br><span class="line"><span class="number">36</span> <span class="number">-72</span></span><br><span class="line"><span class="number">45</span> <span class="number">-90</span></span><br></pre></td></tr></table></figure><p>练习：斐波那契闭包</p><blockquote><p>实现一个 <code>fibonacci</code> 函数，返回一个函数（一个闭包）可以返回连续的斐波纳契数。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">// fibonacci 函数会返回一个返回 int 的函数。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">num1 := <span class="number">0</span> </span><br><span class="line"> num2 := <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">      sum := num1 + num2</span><br><span class="line">      num1 = num2</span><br><span class="line">      num2 = sum</span><br><span class="line">      <span class="keyword">return</span> sum</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f := fibonacci()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(f())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">34</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="方法和接口"><a href="#方法和接口" class="headerlink" title="方法和接口"></a>方法和接口</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ol><li><p>Go中没有类的概念，但是仍然可以在结构体类型上定义方法。方法接收者位于<code>func</code>关键字和方法名之间的参数中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span>&#123;</span><br><span class="line">  X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> math.Sqrt(v.X * v.X + v.Y * v.Y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  v := &amp;Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">  fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p>此外，可以对包中的任意类型定义任何方法，而不仅仅是结构体类型。但是不能对来自其他包的的类型或者基础类型定义方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="keyword">float64</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>　f &lt; <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">float64</span>(-f)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  f:= MyFloat(-math.Sqrt(<span class="number">2</span>))</span><br><span class="line">  fmt.Println(f.Abs())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="number">1.4142135623730951</span></span><br></pre></td></tr></table></figure><p>方法可以与命名类型或者命名类型的指针关联。以上的两个例子中，一个是在<code>*Vertex</code>指针类型上，一个是在<code>MyFloat</code>值类型上。有两个原因需要使用指针接收者：① 避免在每个方法调用中拷贝值(如果值类型是大的结构体的话更有效率)；② 方法可以修改接收者指向的值。在下面的例子中，如果在<code>Scale</code>方法中使用<code>Vertex</code>代替<code>* Vertex</code>作为接收者。当<code>v</code>是<code>Vertex</code>的时候<code>Scale</code>方法不会有任何作用，其看到的只是<code>Vertex</code>的副本，而无法修改原始值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Scale</span><span class="params">(f <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">v.X = v.X * f</span><br><span class="line">v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := &amp;Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">"Before scaling: %+v, Abs: %v\n"</span>, v, v.Abs())</span><br><span class="line">v.Scale(<span class="number">5</span>)</span><br><span class="line">fmt.Printf(<span class="string">"After scaling: %+v, Abs: %v\n"</span>, v, v.Abs())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">Before scaling: &amp;&#123;X:<span class="number">3</span> Y:<span class="number">4</span>&#125;, Abs: <span class="number">5</span></span><br><span class="line">After scaling: &amp;&#123;X:<span class="number">15</span> Y:<span class="number">20</span>&#125;, Abs: <span class="number">25</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ol><li><p>接口类型是一组方法定义的组合，其类型的值可以存放实现这些方法的任何值。下面的示例中，接口<code>Abser</code>中声明了一个方法<code>Abs</code>，而后给出<code>Abs</code>的两种定义实现，一个是针对<code>*Vertex</code>指针类型，一个是针对<code>MyFloat</code>值类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123;</span><br><span class="line">Abs() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="keyword">float64</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">float64</span>(-f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a Abser</span><br><span class="line">f := MyFloat(-math.Sqrt2)</span><br><span class="line">a = f<span class="comment">// a MyFloat 实现了 Abser</span></span><br><span class="line">fmt.Println(a.Abs())</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">a = &amp;v <span class="comment">// a *Vertex 实现了 Abser</span></span><br><span class="line">fmt.Println(a.Abs())</span><br><span class="line"><span class="comment">// 下面一行，v 是一个 Vertex（而不是 *Vertex）</span></span><br><span class="line"><span class="comment">// 所以没有实现 Abser。</span></span><br><span class="line"><span class="comment">//a = v</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="number">1.4142135623730951</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure></li><li><p>类型通过实现那些方法实现接口，没有显示声明的必要；所以就没有关键字implements。隐式接口解耦了实现接口的包和定义接口的包：互补依赖。因此，也就无需在每一个实现上新增新的接口名称，这样同时也鼓励了明确的接口定义。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span>&#123;</span><br><span class="line">  Read(b []<span class="keyword">byte</span>)(n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span>&#123;</span><br><span class="line">  Write(b []<span class="keyword">byte</span>)(n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ReaderWriter <span class="keyword">interface</span>&#123;</span><br><span class="line">  Reader</span><br><span class="line">  Writer</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> w Writer</span><br><span class="line">  w = os.Stdout <span class="comment">// os.Stdout 实现了 Writer</span></span><br><span class="line">  fmt.Fprintf(w, <span class="string">"hello, writer\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">hello, writer</span><br></pre></td></tr></table></figure></li><li><p>一个普遍存在的接口是<code>fmt</code>包中定义的<code>Stringer</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span>&#123;</span><br><span class="line">  String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Stringer</code>是一个可以用字符串描述自己的类型。<code>fmt</code>包(还有许多其他包)使用这个来进行输出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123;</span><br><span class="line">  Name <span class="keyword">string</span></span><br><span class="line">  Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%v (%v years"</span>, p.Name, p.Age)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  a := Person&#123;<span class="string">"Xiaotong Wang"</span>, <span class="number">23</span>&#125;</span><br><span class="line">  z := Person&#123;<span class="string">"Feng Zhu"</span>, <span class="number">24</span>&#125;</span><br><span class="line">  fmt.Println(a, z)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">Xiaotong Wang (<span class="number">23</span> years) Feng Zhu (<span class="number">24</span> years)</span><br></pre></td></tr></table></figure><p>练习：Stringers</p><blockquote><p>让IPAddr类型实现fmt.Stringer以便用点分格式输出地址。</p><p>例如，IPAddr{1, 2, 3, 4}应当输出”1.2.3.4”。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">type</span> IPAddr [<span class="number">4</span>]<span class="keyword">byte</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Add a "String() string" method to IPAddr.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ip IPAddr)</span><span class="title">String</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">"%v.%v.%v.%v"</span>,ip[<span class="number">0</span>],ip[<span class="number">1</span>],ip[<span class="number">2</span>],ip[<span class="number">3</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">addrs := <span class="keyword">map</span>[<span class="keyword">string</span>]IPAddr&#123;</span><br><span class="line"><span class="string">"loopback"</span>:  &#123;<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line"><span class="string">"googleDNS"</span>: &#123;<span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> n, a := <span class="keyword">range</span> addrs &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%v: %v\n"</span>, n, a)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">loopback: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">googleDNS: <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><ol><li><p>在Go中程序使用 <code>error</code>值来表示错误状态。与 <code>fmt.Stringer</code> 类似， <code>error</code>类型也是一个内建接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span>&#123;</span><br><span class="line">  Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常，函数会返回一个<code>error</code>值，调用它的代码应当判断这个错误是否等于<code>nil</code>，来进行错误处理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i, err := strconv.Atoi(<span class="string">"42"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">    fmt.Printf(<span class="string">"couldn't convert number: %v\n"</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"Converted integer:"</span>, i)</span><br></pre></td></tr></table></figure><p><code>error</code> 为 nil 时表示成功；非 nil 的 <code>error</code> 表示错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span>&#123;</span><br><span class="line">  When time.Time</span><br><span class="line">  What <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e MyError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">"at %v, %s"</span>, e.When, e.What)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span> <span class="title">error</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> MyError&#123;</span><br><span class="line">      time.Now(),</span><br><span class="line">      <span class="string">"it didn't work"</span>.</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> err:= run;err != <span class="literal">nil</span>&#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">at <span class="number">2009</span><span class="number">-11</span><span class="number">-10</span> <span class="number">23</span>:<span class="number">00</span>:<span class="number">00</span> +<span class="number">0000</span> UTC, it didn<span class="string">'t work</span></span><br></pre></td></tr></table></figure><p>练习：错误</p><blockquote><p>从先前的练习中复制 <code>Sqrt</code> 函数，并修改使其返回 <code>error</code>值。</p><p>由于不支持复数，当 <code>Sqrt</code> 接收到一个负数时，应当返回一个非 nil 的错误值。</p><p>创建一个新类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">type</span> ErrNegativeSqrt <span class="keyword">float64</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>为其实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">func</span> <span class="params">(e ErrNegativeSqrt)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line"><span class="function">&gt;</span></span><br></pre></td></tr></table></figure><p>使其成为一个 error， 该方法就可以让 ErrNegativeSqrt(-2).Error() 返回 <code>&quot;cannot Sqrt negative number: -2&quot;</code>。<br><em>注意：</em> 在 Error 方法内调用 fmt.Sprint(e) 将会让程序陷入死循环。可以通过先转换 e 来避免这个问题：fmt.Sprint(float64(e))。请思考这是为什么呢？<br>修改 Sqrt 函数，使其接受一个负数时，返回 ErrNegativeSqrt 值。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> ErrNegativeSqrt <span class="keyword">float64</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e ErrNegativeSqrt)</span><span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">"cannot Sqrt negtive number: %v"</span>,<span class="keyword">float64</span>(e))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sqrt</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="params">(<span class="keyword">float64</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, ErrNegativeSqrt(x)</span><br><span class="line">&#125;</span><br><span class="line">z := <span class="keyword">float64</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i:= <span class="number">0</span> ; i&lt; <span class="number">10</span> ;i++ &#123;</span><br><span class="line">z = z - (z*z-x)/(<span class="number">2</span>*z)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> z, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(Sqrt(<span class="number">2</span>))</span><br><span class="line">fmt.Println(Sqrt(<span class="number">-2</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="number">1.414213562373095</span> &lt;<span class="literal">nil</span>&gt;</span><br><span class="line"><span class="number">0</span> cannot Sqrt negtive number: <span class="number">-2</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="Readers"><a href="#Readers" class="headerlink" title="Readers"></a>Readers</h3><ol><li><p><code>io</code> 包指定了 <code>io.Reader</code> 接口，它表示从数据流结尾读取。Go标准库包含了这个接口的许多实现，包括文件、网络连接、压缩、加密等。 <code>io.Reader</code> 接口有一个 <code>Read</code>方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(T)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span><span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure><p><code>Read</code> 用数据填充指定的字节slice，返回填充的字节数和错误信息。在遇到数据流结尾时，返回<code>io.EOF</code>错误。下面的例子中创建了一个<code>strings.Reader</code>，每次以8字节的速度读取输出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  r := strings.NewReader(<span class="string">"Hello, Reader!"</span>)</span><br><span class="line">  b:= <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">8</span>)</span><br><span class="line">  <span class="keyword">for</span>&#123;</span><br><span class="line">    n, err := r.Read(b)</span><br><span class="line">    fmt.Printf(<span class="string">"n = %v err = %v b = %v\n"</span>,n, err, b)</span><br><span class="line">    fmt.Printf(<span class="string">"b[:n] = %q\n"</span>, b[:n])</span><br><span class="line">    <span class="keyword">if</span> err == io.EOF&#123;</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">n = <span class="number">8</span> err = &lt;<span class="literal">nil</span>&gt; b = [<span class="number">72</span> <span class="number">101</span> <span class="number">108</span> <span class="number">108</span> <span class="number">111</span> <span class="number">44</span> <span class="number">32</span> <span class="number">82</span>]</span><br><span class="line">b[:n] = <span class="string">"Hello, R"</span></span><br><span class="line">n = <span class="number">6</span> err = &lt;<span class="literal">nil</span>&gt; b = [<span class="number">101</span> <span class="number">97</span> <span class="number">100</span> <span class="number">101</span> <span class="number">114</span> <span class="number">33</span> <span class="number">32</span> <span class="number">82</span>]</span><br><span class="line">b[:n] = <span class="string">"eader!"</span></span><br><span class="line">n = <span class="number">0</span> err = EOF b = [<span class="number">101</span> <span class="number">97</span> <span class="number">100</span> <span class="number">101</span> <span class="number">114</span> <span class="number">33</span> <span class="number">32</span> <span class="number">82</span>]</span><br><span class="line">b[:n] = <span class="string">""</span></span><br></pre></td></tr></table></figure><p>练习：Reader</p><blockquote><p>实现一个Reader类型，它不断生成ASCII字符‘A’的流。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"golang.org/x/tour/reader"</span></span><br><span class="line"><span class="keyword">type</span> MyReader <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Add a Read([]byte) (int, error) method to MyReader.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r MyReader)</span><span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span><span class="params">(n <span class="keyword">int</span>, err error)</span></span>&#123;</span><br><span class="line">b[<span class="number">0</span>] = <span class="string">'A'</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">reader.Validate(MyReader&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">OK!</span><br></pre></td></tr></table></figure><p>练习：rot13Reader</p><blockquote><p>一个常见的模式是 <code>io.Reader</code>包裹另一个 <code>io.Reader</code>，然后通过某种形式修改数据流。例如 <code>gzip.NewReader</code>函数接受 <code>io.Reader</code>(压缩的数据流)，并且返回同样实现了 <code>io.Reader</code>的 <code>*gzip.Reader</code>（解压后的数据流）。</p><p>编写一个实现了 <code>io.Reader</code>的 <code>rot13Reader</code>，并从一个 <code>io.Reader</code>读取，利用rot13代换密码对数据流进行修改。</p><p>已经帮你构造了 <code>rot13Reader</code>类型。通过实现 <code>Read</code>方法使其匹配 <code>io.Reader</code>。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> rot13Reader <span class="keyword">struct</span> &#123;</span><br><span class="line">r io.Reader</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rot rot13Reader)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span><span class="params">(n <span class="keyword">int</span>, err error)</span></span>&#123;</span><br><span class="line">rot.r.Read(b)</span><br><span class="line">length := <span class="built_in">len</span>(b)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span> ; i&lt; length; i++ &#123;</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> b[i] &gt;= <span class="string">'a'</span> &amp;&amp; b[i] &lt; <span class="string">'n'</span>:</span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> b[i] &gt;= <span class="string">'A'</span> &amp;&amp; b[i] &lt; <span class="string">'N'</span>:</span><br><span class="line">b[i] = b[i] + <span class="number">13</span></span><br><span class="line"><span class="keyword">case</span> b[i] &gt;= <span class="string">'n'</span> &amp;&amp; b[i] &lt;= <span class="string">'z'</span>:</span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> b[i] &gt;= <span class="string">'N'</span> &amp;&amp; b[i] &lt;= <span class="string">'Z'</span>:</span><br><span class="line">b[i] = b[i] - <span class="number">13</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> length, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := strings.NewReader(<span class="string">"Lbh penpxrq gur pbqr!"</span>)</span><br><span class="line">r := rot13Reader&#123;s&#125;</span><br><span class="line">io.Copy(os.Stdout, &amp;r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h3><ol><li><p>包 <code>http</code>通过任何实现了 <code>http.Handler</code> 的值来响应HTTP请求：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> http</span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span>&#123;</span><br><span class="line">  ServeHTTP(w ResponserWriter, r *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在下面例子中，类型 <code>Hello</code> 实现了 <code>http.Handler</code> 。访问 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 会看到来自程序的问候。需要注意的是，这个例子无法在基于web的指南用户界面运行。为了编写web服务器，可能需要安装Go。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"log"</span></span><br><span class="line">  <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Hello <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Hello)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponserWirter, r *http.Request)</span></span>&#123;</span><br><span class="line">  fmt.Fprint(w, <span class="string">"Hello!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> h Hello</span><br><span class="line">  err := http.ListenAndServe(<span class="string">"localhost:4000"</span>,h)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">     log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>练习：HTTP处理</p><blockquote><p>实现下面的类型，并在其上定义ServeHTTP方法。在web服务器中注册它们来处理指定的路径。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">type</span> String <span class="keyword">string</span></span><br><span class="line">&gt; <span class="keyword">type</span> Struct <span class="keyword">struct</span>&#123;</span><br><span class="line">&gt;   Greeting <span class="keyword">string</span></span><br><span class="line">&gt;   Punct <span class="keyword">string</span></span><br><span class="line">&gt;   Who <span class="keyword">string</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>例如，可以使用如下方式注册处理方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; http.Handle(<span class="string">"/string"</span>, String(<span class="string">"I'm a frayed knot."</span>))</span><br><span class="line">&gt; http.Handle(<span class="string">"/struct"</span>, &amp;Struct(<span class="string">"Hello"</span>,<span class="string">":"</span>,<span class="string">"Gophers!"</span>))</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>在启动你的http服务器后，你将能够访问：</p><p><a href="http://localhost:4000/string" target="_blank" rel="noopener">http://localhost:4000/string</a> 和 <a href="http://localhost:4000/struct" target="_blank" rel="noopener">http://localhost:4000/struct</a></p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"log"</span></span><br><span class="line">  <span class="string">"net/http"</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> String <span class="keyword">string</span></span><br><span class="line"><span class="keyword">type</span> Struct <span class="keyword">struct</span>&#123;</span><br><span class="line">  Greeting <span class="keyword">string</span></span><br><span class="line">  Punct <span class="keyword">string</span></span><br><span class="line">  Who <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s String)</span><span class="title">ServeHTTP</span><span class="params">(w http.ResponserWirter, r *http.Request)</span></span>&#123;</span><br><span class="line">  fmt.Fprint(w, s) </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sttruct)</span><span class="title">ServeHTTP</span><span class="params">(w http.ResponserWirter, r *http.Request)</span></span>&#123;</span><br><span class="line">  fmt.Fprint(w, s) </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  http.Handle(<span class="string">"/string"</span>, String(<span class="string">"I'm a frayed knot."</span>))</span><br><span class="line">http.Handle(<span class="string">"/struct"</span>, &amp;Struct(<span class="string">"Hello"</span>,<span class="string">":"</span>,<span class="string">"Gophers!"</span>))</span><br><span class="line">  log.Fatal(http.ListenAndServe(<span class="string">"localhost:4000"</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><ol><li><p><code>Package image</code>定义了 <code>Image</code> 接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> image</span><br><span class="line"><span class="keyword">type</span> Image <span class="keyword">interface</span>&#123;</span><br><span class="line"> ColorModel() color.model</span><br><span class="line"> Bounds() Rectangle</span><br><span class="line"> At(x, y <span class="keyword">int</span>) color.Color</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意， <code>Bounds</code> 方法的 <code>Rectangle</code> 返回值其实是一个 <code>image.Rectangle</code>，其定义在 <code>image</code>包中。 <code>color.Color</code>和 <code>color.Model</code>也是接口，但是通常因为直接使用预定义的实现<code>image.RGBA</code>和<code>image.RGBAModel</code>而被忽视了。这些接口和类型由<code>image/color</code>包定义。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"image"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  m := image.NewRGBA(image.Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>))</span><br><span class="line">  fmt.Println(m.Bounds())</span><br><span class="line">  fmt.Println(m.At(<span class="number">0</span>, <span class="number">0</span>).RGBA())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">(<span class="number">0</span>,<span class="number">0</span>)-(<span class="number">100</span>,<span class="number">100</span>)</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>练习：</p><blockquote><p>还记得之前编写的图片生成器吗？现在来另外编写一个，不过这次将会返回 <code>image.Image</code> 来代替 slice 的数据。</p><p>自定义的 <code>Image</code> 类型，要实现必要的方法，并且调用<code>pic.ShowImage</code>。</p><p><code>Bounds</code> 应当返回一个 <code>image.Rectangle</code>，例如 <code>image.Rect(0, 0, w, h)</code>。</p><p><code>ColorModel</code> 应当返回 <code>color.RGBAModel</code>。</p><p><code>At</code> 应当返回一个颜色；在这个例子里，在最后一个图片生成器的值 <code>v</code> 匹配 <code>color.RGBA{v, v, 255, 255}</code>。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">"golang.org/x/tour/pic"</span></span><br><span class="line">  <span class="string">"image/color"</span></span><br><span class="line">  <span class="string">"image"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Image <span class="keyword">struct</span>&#123;</span><br><span class="line">  Width <span class="keyword">int</span></span><br><span class="line">  Height <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i Image)</span> <span class="title">Bounds</span><span class="params">()</span> <span class="title">image</span>.<span class="title">Rectangle</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> image.Rect(<span class="number">0</span>, <span class="number">0</span>, i.Width, i.Height)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i Image)</span> <span class="title">ColorModel</span><span class="params">()</span> <span class="title">color</span>.<span class="title">Model</span></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> color.RGBAModel</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i Image)</span> <span class="title">At</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">color</span>.<span class="title">Color</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> color.RGBA&#123;<span class="keyword">uint8</span>(x), <span class="keyword">uint8</span>(y), <span class="number">255</span>, <span class="number">255</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> m := Image&#123;Width:<span class="number">100</span>, Height:<span class="number">100</span>&#125;</span><br><span class="line">pic.ShowImage(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h3><ol><li><p><code>goroutine</code>是由Go运行时环境管理的轻量级线程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> f(x, y ,z)</span><br></pre></td></tr></table></figure><p>开启一个新的goroutine执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(x, y ,z)</span><br></pre></td></tr></table></figure><p>f, x, y 和 z是当前goroutine中定义的，但是在新的goroutine中运行f。goroutine在相同的地址空间中运行，因此访问共享内存必须进行同步。<a href="https://go-zh.org/pkg/sync/" target="_blank" rel="noopener"><code>sync</code></a> 提供了这种可能，不过在Go中并不经常用到，因为有其他的办法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">(s <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span> ; i &lt; <span class="number">5</span> ; i++ &#123;</span><br><span class="line">      time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">      fmt.Println(s)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">go</span> say(<span class="string">"world"</span>)</span><br><span class="line">  say(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">world</span><br><span class="line">hello</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">world</span><br><span class="line">hello</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">world</span><br><span class="line">hello</span><br></pre></td></tr></table></figure></li><li><p>channel是有类型的管道，可以用channel操作符 <code>&lt;-</code> 对其发送或者接收值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- v <span class="comment">//　将v送人channel ch</span></span><br><span class="line">v := &lt;-ch <span class="comment">//从ch接收，并赋值给v</span></span><br></pre></td></tr></table></figure><p>箭头就是数据流入的方法</p><p>和map和slice一样，channel在使用前必须创建：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><p>默认情况下，在另一端准备好之前，发送和接收都会阻塞。这使得goroutine可以在没有明确锁或竞态变量的情况下进行同步。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a []<span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">  sum := <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">      sum += v</span><br><span class="line">  &#125;</span><br><span class="line">  c &lt;- sum <span class="comment">//将和送入c</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  a := []<span class="keyword">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line">  c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">  <span class="keyword">go</span> sum(a[:<span class="built_in">len</span>(a)/<span class="number">2</span>],c)</span><br><span class="line"> <span class="keyword">go</span> sum(a[<span class="built_in">len</span>(a)/<span class="number">2</span>:],c)</span><br><span class="line">  x, y := &lt;-c, &lt;-c <span class="comment">//从c中获取</span></span><br><span class="line"> fmt.Println(x, y ,x+y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="number">-5</span> <span class="number">17</span> <span class="number">12</span></span><br></pre></td></tr></table></figure><p>channel是可以带缓冲的。为<code>make</code>提供第二个参数作为缓冲长度来初始化一个缓冲channel：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><p> 向带缓冲的channel发送数据的时候，只有在缓冲区满的时候才会阻塞。而当缓冲区为空的时候接收操作会阻塞。而当缓冲区为空时，接收操作会阻塞。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line">  ch &lt;- <span class="number">1</span></span><br><span class="line">  ch &lt;- <span class="number">2</span></span><br><span class="line">  fmt.Println(&lt;-ch)</span><br><span class="line">  fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>若修改上面这个例子，使得缓冲区被填满，则会报错：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line">  ch &lt;- <span class="number">1</span></span><br><span class="line">  ch &lt;- <span class="number">2</span></span><br><span class="line"> ch &lt;- <span class="number">1</span></span><br><span class="line">  fmt.Println(&lt;-ch)</span><br><span class="line">  fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [<span class="keyword">chan</span> send]:</span><br><span class="line">main.main()</span><br><span class="line">/tmp/sandbox402344606/main.<span class="keyword">go</span>:<span class="number">9</span> +<span class="number">0x100</span></span><br></pre></td></tr></table></figure><p>发送者可以 <code>close</code> 一个channel来表示再没有值会被发送了。接收者可以通过赋值语句的第二个参数来测试channel是否被关闭：当没有值可以接收并且channel已经被关闭，那么经过</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v, ok := &lt;-ch</span><br></pre></td></tr></table></figure><p>之后， <code>ok</code> 会被设置为false。</p><p>循环 <code>for i := range c</code>会不断从channel接收值，<strong>直到它被关闭</strong>。需要注意的是，<strong>只有发送者才能关闭channel</strong>，而不是接收者。 向一个已经关闭的channel发送数据会引起panic。channel与文件不同，通常情况下不需要关闭它们，只有在需要告诉接收者没有更过的数据的时候才有必要进行关闭，例如中断一个range。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">  x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span> ; i &lt; n ; i++ &#123;</span><br><span class="line">c -&lt; x</span><br><span class="line">      x, y = y, x+y</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">  <span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c),c)</span><br><span class="line">  <span class="keyword">for</span> i := <span class="keyword">range</span> c&#123;</span><br><span class="line">      fmt.Println(i)</span><br><span class="line">  &#125;</span><br><span class="line">  c &lt;- <span class="number">2</span> <span class="comment">// panic</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">34</span></span><br><span class="line"><span class="built_in">panic</span>: send on closed channel</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [running]</span><br><span class="line">main.main()</span><br><span class="line">/tmp/sandbox910931553/main.<span class="keyword">go</span>:<span class="number">22</span> +<span class="number">0x160</span></span><br></pre></td></tr></table></figure></li><li><p><code>select</code>语句使得一个goroutine在多个通讯操作上等待。 <code>select</code>会阻塞，直到条件分支中的某个可以继续执行，这时会执行那个条件分支。当多个都准备好的时候，会随机选择一个。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(c, quit <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">     x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">     <span class="keyword">for</span>&#123;</span><br><span class="line">         <span class="keyword">select</span>&#123;</span><br><span class="line">            <span class="keyword">case</span> c &lt;- x:</span><br><span class="line">              x, y = y, x+y</span><br><span class="line">            <span class="keyword">case</span> &lt;- quit:</span><br><span class="line">              fmt.Println(<span class="string">"quit"</span>)</span><br><span class="line">              <span class="keyword">return</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">     quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">     <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span> ; i&lt; <span class="number">10</span>; i++&#123;</span><br><span class="line">         fmt.Println(&lt;-c)</span><br><span class="line">        &#125;</span><br><span class="line">         quit &lt;- <span class="number">0</span> </span><br><span class="line">     &#125;()</span><br><span class="line">     fibonacci(c, quit)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">34</span></span><br><span class="line">quit</span><br></pre></td></tr></table></figure><p>当<code>select</code> 中的其他条件分支都没有准备好的时候，<code>default</code>分支会被执行。为了非阻塞的发送或者接收，可使用<code>default</code>分支：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>&#123;</span><br><span class="line"> <span class="keyword">case</span> i := &lt;-c:</span><br><span class="line">         <span class="comment">//使用i</span></span><br><span class="line">     <span class="keyword">default</span>:</span><br><span class="line">         <span class="comment">//从c读取会阻塞</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">"fmt"</span></span><br><span class="line">     <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  tick := time.Tick(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">  boom := time.After(<span class="number">500</span> * time.Millisecond)</span><br><span class="line">  <span class="keyword">for</span>&#123;</span><br><span class="line">     <span class="keyword">select</span>&#123;</span><br><span class="line">          <span class="keyword">case</span> &lt;- tick:</span><br><span class="line">             fmt.Println(<span class="string">"tick."</span>)</span><br><span class="line">          <span class="keyword">case</span> &lt;- boom:</span><br><span class="line">             fmt.Println(<span class="string">"boom!"</span>)</span><br><span class="line">             <span class="keyword">return</span></span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">             fmt.Println(<span class="string">"    ."</span>)</span><br><span class="line">             time.Sleep(<span class="number">50</span> * time.Millisecond)</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">tick.</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">tick.</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">tick.</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">tick.</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">tick.</span><br></pre></td></tr></table></figure><p>练习：等价二叉树</p><blockquote><p>可以用多种不同的二叉树的叶子节点存储相同的数列值。用于检查两个二叉树村出了相同的序列的函数在多数语言中都是相当复杂的。这里将使用Go的并发和channel来编写一个简单的解法。这个例子使用了 <code>tree</code> 包，定义了类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">type</span> Tree <span class="keyword">struct</span>&#123;</span><br><span class="line">&gt;   Left *Tree</span><br><span class="line">&gt;   Value <span class="keyword">int</span></span><br><span class="line">&gt;   Right *Tree</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><ol><li><p>实现Walk函数。</p></li><li><p>测试Walk函数。函数 <code>tree.New(k)</code> 构造了一个随机结构的二叉树，保存了值 <code>k</code>，<code>2k</code>，<code>3k</code>，…，<code>10k</code>。创建一个新的channel <code>ch</code> 并对其进行步进：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;    <span class="keyword">go</span> Walk(tree.New(<span class="number">1</span>), ch)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><p>&gt;</p><blockquote><p>   然后从channel 中读取并打印10个值。应当是1，2，3 ，…，10。</p><ol><li><p>用 <code>Walk</code> 实现 <code>Same</code> 函数来检测是否 <code>t1</code> 和 <code>t2</code> 存储了相同的值。</p></li><li><p>测试 <code>Same</code> 函数。</p><p><code>Same(tree.New(1), tree.New(1))</code>应当返回true，而<code>Same(tree.New(1), tree.New(２))</code>应当返回false。</p></li></ol></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"golang.org/x/tour/tree"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Walk</span><span class="params">(t *tree.Tree, ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> t == <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    Walk(t.Left, ch)</span><br><span class="line">    ch &lt;- t.Value</span><br><span class="line">    Walk(t.Right, ch)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Same</span><span class="params">(t1, t2 *tree.Tree)</span><span class="title">bool</span></span>&#123;</span><br><span class="line">    ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Walk(t1, ch1)</span><br><span class="line">        ch1 &lt;- <span class="number">0</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Walk(t2, ch2)</span><br><span class="line">        ch2 &lt;- <span class="number">0</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span>&#123;</span><br><span class="line">        t1 := &lt;- ch1</span><br><span class="line">        t2 := &lt;- ch2</span><br><span class="line">        <span class="keyword">if</span> t1 == <span class="number">0</span> &amp;&amp; t2 == <span class="number">0</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> t1 == t2 &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Walk(tree.New(<span class="number">1</span>), ch)</span><br><span class="line">        ch &lt;- <span class="number">0</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span>&#123;</span><br><span class="line">        t := &lt;- ch</span><br><span class="line">        <span class="keyword">if</span> t == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(t)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(Same(tree.New(<span class="number">2</span>), tree.New(<span class="number">2</span>)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="sync-Mutex"><a href="#sync-Mutex" class="headerlink" title="sync.Mutex"></a>sync.Mutex</h3><ol><li><p>我们已经看到 <code>channel</code> 用在各个goroutine间进行通信是非常合适的了。但是如果我们不需要进行通信呢？比如说，如果我们只想保证在每个时刻，只有一个goroutine能访问一个共享的变量从而避免冲突？这里涉及的概念叫做互斥。通常使用互斥锁<code>mutex</code>来提供这个限制。Go标准库中提供了  <code>sync.Mutex</code>类型及其两个方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Lock</span><br><span class="line">Unlock</span><br></pre></td></tr></table></figure><p>我们可以通过在代码前调用 <code>Lock</code> 方法，在代码后调用 <code>Unlock</code>方法来保证一段代码的互斥执行。我们也可以用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"sync"</span></span><br><span class="line">  <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// SafeCounter的并发使用是安全的</span></span><br><span class="line"><span class="keyword">type</span> SafeCounter <span class="keyword">struct</span>&#123;</span><br><span class="line">  v <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">  mux sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Inc增加给定key的计数器的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(c *SafeCounter)</span> <span class="title">Inc</span><span class="params">(key <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">  c.mux.Lock()</span><br><span class="line">  c.v[key]++</span><br><span class="line">  c.mux.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Value返回给定key的计数器的当前值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">string</span>)</span><span class="title">int</span></span>&#123;</span><br><span class="line">  c.mux.Lock()</span><br><span class="line">  <span class="keyword">defer</span> c.mux.Unlock()</span><br><span class="line">  <span class="keyword">return</span> c.v[key]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> c := SafeCounter&#123;v: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]iint)&#125;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span> ; i &lt; <span class="number">1000</span> ; i++&#123;</span><br><span class="line">      <span class="keyword">go</span> c.Inc(<span class="string">"somekey"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  time.Sleep(time.Second)</span><br><span class="line">  fmt.Println(c.Value(<span class="string">"somekey"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="number">1000</span></span><br></pre></td></tr></table></figure><p>练习：Web爬虫</p><blockquote><p>在这个练习中，将会用Go的并发特性来并行执行web爬虫。修改 <code>Crawl</code>函数来并行抓取URLs，并且保证不重复。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> crawled = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span><br><span class="line"><span class="keyword">var</span> crawledMutex sync.Mutex</span><br><span class="line"><span class="keyword">type</span> fakeFetcher <span class="keyword">map</span>[<span class="keyword">string</span>]*fakeResult</span><br><span class="line"><span class="keyword">type</span> fakeResult <span class="keyword">struct</span> &#123;</span><br><span class="line">     body <span class="keyword">string</span></span><br><span class="line">     urls     []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Fetcher <span class="keyword">interface</span>&#123;</span><br><span class="line">  <span class="comment">//Fetch返回URL的body内容，并且将在这个页面上找到的URL放到一个slice中</span></span><br><span class="line">  Fetch(url <span class="keyword">string</span>)(body <span class="keyword">string</span>, urls []<span class="keyword">string</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *fakeFetcher)</span> <span class="title">Fetch</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, []<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">     <span class="keyword">if</span> res, ok := (*f)[url]; ok &#123;</span><br><span class="line">          <span class="keyword">return</span> res.body, res.urls, <span class="literal">nil</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="string">""</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">"not found: %s"</span>, url)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Crawl使用fetcher从某个url开始递归地爬取页面，直到达到最大深度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Crawl</span><span class="params">(url <span class="keyword">string</span>, depth <span class="keyword">int</span>, fetcher Fetcher, out <span class="keyword">chan</span> <span class="keyword">string</span>, end <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span>&#123;</span><br><span class="line">  <span class="comment">//并行抓取URL</span></span><br><span class="line">  <span class="comment">//不重复抓取页面</span></span><br><span class="line">  <span class="keyword">if</span> depth &lt;= <span class="number">0</span>&#123;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">if</span> _, ok := crawled[url];ok&#123;</span><br><span class="line">      end &lt;- <span class="literal">true</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line"> &#125;</span><br><span class="line">  crawledMutex.Lock()</span><br><span class="line">  crawled[url] = <span class="literal">true</span></span><br><span class="line">  crawledMutex.Unlock()</span><br><span class="line">  body, urls, err := fetcher.Fetch(url)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">      fmt.Println(err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  out &lt;- fmt.Sprintf(<span class="string">"found: %s %q\n"</span>, url, body)</span><br><span class="line">  subEnd := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">  <span class="keyword">for</span> _, u := <span class="keyword">range</span> urls&#123;</span><br><span class="line">      <span class="keyword">go</span> Crawl(u, depth<span class="number">-1</span>, fetcher, out, subEnd)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span> ; i &lt; <span class="built_in">len</span>(urls); i++&#123;</span><br><span class="line">      &lt;- subEnd</span><br><span class="line">  &#125;</span><br><span class="line">end &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    end := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">  <span class="keyword">go</span> Crawl(<span class="string">"http://golang.org/"</span>,<span class="number">4</span>,fetcher,out, end)</span><br><span class="line">  <span class="keyword">for</span>&#123;</span><br><span class="line">     <span class="keyword">select</span>&#123;</span><br><span class="line">          <span class="keyword">case</span> t := &lt;-out:</span><br><span class="line">          fmt.Print(t)</span><br><span class="line">          <span class="keyword">case</span> &lt;- end:</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      最近在自学MIT6.824的分布式系统课程，实验部分使用的语言是Go，所以根据Go指南，手动实现了所有的教程。
    
    </summary>
    
      <category term="Go" scheme="http://tankcat2.com/categories/Go/"/>
    
    
      <category term="Go" scheme="http://tankcat2.com/tags/Go/"/>
    
      <category term="MIT6.824" scheme="http://tankcat2.com/tags/MIT6-824/"/>
    
  </entry>
  
  <entry>
    <title>再见我的暴力女王</title>
    <link href="http://tankcat2.com/2017/02/27/evil/"/>
    <id>http://tankcat2.com/2017/02/27/evil/</id>
    <published>2017-02-27T12:11:31.000Z</published>
    <updated>2017-05-05T11:27:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>初二的时候，老妈同事的儿子来我家排练吹笛子，给我讲了生化危机3，当时没记住名字；</p><p>后来在家里的电脑上翻到了，还是没字幕英文版的，就这样看完了；</p><a id="more"></a><p>到了高二，周末回家，把第一部第二部给补完了，没看过瘾，导致后来第二部反复拿出来看，可能看了有十多遍了，里面的角色很鲜明，很喜欢吉尔，喜欢短发帅气的她；</p><p>没过多久，第四部就上映了，在网上看过一遍之后才去老文化馆那边的电影院再看一遍，记得那次的3D眼睛还是硬纸片做的；第五部也是在网上看的枪版，越来越没趣。</p><p>今天，和实验室的小伙伴一起看了终章，看完有点失落，追了这么多年的欧美暴力女王，就这么结束了。我不说这是情怀，有点装逼，但可能也是因为生化3，开始了我喜欢丧尸类型片子之路。等网上出了终章的未删减版，我要再刷一波。</p><p>最后，刚刚在知乎上看到“如何评价生化危机6”里面有个回答说，我觉得最大的彩蛋是我旁边的哥们儿看到女主骑着摩托绝尘而去的时候，突然说了一句，她真该进复联。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;初二的时候，老妈同事的儿子来我家排练吹笛子，给我讲了生化危机3，当时没记住名字；&lt;/p&gt;
&lt;p&gt;后来在家里的电脑上翻到了，还是没字幕英文版的，就这样看完了；&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://tankcat2.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="生化危机" scheme="http://tankcat2.com/tags/%E7%94%9F%E5%8C%96%E5%8D%B1%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Kafka快速入门</title>
    <link href="http://tankcat2.com/2017/02/27/kafka_quickstart/"/>
    <id>http://tankcat2.com/2017/02/27/kafka_quickstart/</id>
    <published>2017-02-27T12:11:31.000Z</published>
    <updated>2017-07-20T00:48:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>翻译自kafka documentation的quick start 部分。</p><ol><li><p>下载Zookeeper</p><p>我使用的是<a href="http://mirrors.hust.edu.cn/apache/zookeeper/zookeeper-3.4.6/zookeeper-3.4.6.tar.gz" target="_blank" rel="noopener">zookeeper-3.4.6</a>版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -xvzf zookeeper-3.4.6.tgz</span><br><span class="line">cd zookeeper-3.4.6/conf</span><br></pre></td></tr></table></figure><p>将<code>zoo_example.cfg</code>改名为<code>zoo.cfg</code>，并在<code>/etc/profile</code>中设置环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line">export ZK_HOME=/home/admin/zookeeper-3.4.6</span><br><span class="line">export PATH=$PATH:$ZK_HOME/bin:$ZK_HOME/conf</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><ol><li><p>下载Kafka</p><p>我使用的是<a href="https://www.apache.org/dyn/closer.cgi?path=/kafka/0.10.2.1/kafka_2.10-0.10.2.1.tgz" target="_blank" rel="noopener">kafka_2.10-0.10.2.1</a>版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -xvzf kafka_2.10-0.10.2.1</span><br><span class="line">cd kafka_2.10-0.10.2.1/config</span><br></pre></td></tr></table></figure><p>接下来进行参数配置：<code>server.properties</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vim server.properties</span><br><span class="line">...</span><br><span class="line"><span class="meta">#</span> 修改broker.id,全局唯一</span><br><span class="line"><span class="meta">#</span> 修改zookeeper.connect，形式为host:port，多个数据项用逗号分隔</span><br><span class="line">zookeeper.connect=192.168.115:2181</span><br><span class="line"><span class="meta">#</span> 设置话题的删除,默认值为false</span><br><span class="line">delete.topic.enable=true</span><br><span class="line"><span class="meta">#</span> 设置数据日志路径</span><br><span class="line">log.dirs=/home/admin/kafka_2.10-0.10.2.1/kafka-logs</span><br></pre></td></tr></table></figure></li><li><p>启动</p><p>Kafka使用Zookeeper，所以需要先启动Zookeeper，我没有使用Kafka内置的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zkServer.sh start</span><br></pre></td></tr></table></figure><p>接着启动Kafka:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-server-start.sh config/server.properties</span><br></pre></td></tr></table></figure></li><li><p>创建topic</p><p>使用下面的命令创建名为<code>single_node</code>的topic，副本数为1，分区数为1，命令执行结束后，<code>kafka-logs</code>路径下就会生成一个<code>single_node-0</code>的文件夹。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.h --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic single_node</span><br></pre></td></tr></table></figure></li><li><p>发布与消耗数据</p><p>执行下面的命令创建producer进程，从标准输入中获取数据，并发送到Kafka集群中的single_node这个topic中，默认地，每一行将作为单独的一条信息发送出去。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-producer.sh --broker-list localhost:9092 --topic single_node</span><br><span class="line">wxt</span><br><span class="line">zf</span><br><span class="line">i love u</span><br></pre></td></tr></table></figure><p>执行下面的命令创建consumer进程，消耗指定topic的数据，这里就是标准输出的数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic single_node --from-beginning</span><br><span class="line">wxt</span><br><span class="line">zf</span><br><span class="line">i love u</span><br></pre></td></tr></table></figure></li></ol><p>以上均是单机版的Kafka配置与使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;翻译自kafka documentation的quick start 部分。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;下载Zookeeper&lt;/p&gt;
&lt;p&gt;我使用的是&lt;a href=&quot;http://mirrors.hust.edu.cn/apache/zookeeper/zookeeper-3.4.6/zookeeper-3.4.6.tar.gz&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;zookeeper-3.4.6&lt;/a&gt;版本&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;tar -xvzf zookeeper-3.4.6.tgz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd zookeeper-3.4.6/conf&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;将&lt;code&gt;zoo_example.cfg&lt;/code&gt;改名为&lt;code&gt;zoo.cfg&lt;/code&gt;，并在&lt;code&gt;/etc/profile&lt;/code&gt;中设置环境变量：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;vim /etc/profile&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;export ZK_HOME=/home/admin/zookeeper-3.4.6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;export PATH=$PATH:$ZK_HOME/bin:$ZK_HOME/conf&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Kafka文档" scheme="http://tankcat2.com/categories/Kafka%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="kafka" scheme="http://tankcat2.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>Robust and Skew-resistant Parallel Joins in Shared-Nothing Systems</title>
    <link href="http://tankcat2.com/2017/01/17/Robust%20and%20Skew-resistant%20Parallel%20Joins%20in%20Shared-Nothing%20Systems/"/>
    <id>http://tankcat2.com/2017/01/17/Robust and Skew-resistant Parallel Joins in Shared-Nothing Systems/</id>
    <published>2017-01-17T05:11:31.000Z</published>
    <updated>2017-05-05T11:28:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="并行连接处理的两种基本框架"><a href="#并行连接处理的两种基本框架" class="headerlink" title="并行连接处理的两种基本框架"></a>并行连接处理的两种基本框架</h2><a id="more"></a><ul><li><p><strong>hash-based</strong> 基于哈希，如下图所示，分为四个步骤：</p><ol><li>partition划分，将原先每个节点上存储的$R_i$和$S_i$按照连接属性键的哈希值进行划分，比如图中，将第一个节点(大的实线矩形)中的$R_1$和$S_1$分别划分为k个子集；</li><li>distribution分发，根据连接属性键的哈希值，将上面的子集分发到另外一个空闲节点上，比如图中，将每个节点中的第k个子集$R<em>{ik}$ 和 $S</em>{ik}$ 同时分发到一个空闲节点上，那么这个空闲节点存储的数据为$R<em>k=\bigcup</em>{i=1}^{n}R_{ik}$,$S<em>k=\bigcup</em>{i=1}^{n}S_{ik}$;</li><li>build构建，在空闲节点中，对数据集$R_k$进行扫描，并对它构建一个存储在内存中的哈希表；</li><li>prob检测，在空闲节点中，对数据集$S_k$进行遍历，判断每一条数据的键值是否存在于上面构建的哈希表中，并输出连接结果.</li></ol><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/hash-based.png" alt="hash-based"></p></li><li><p><strong>duplication-based</strong> 基于副本，如下图所示，分为三个步骤：</p><ol><li>duplication复制，针对每个节点，将其中存储的数据集$R_i$广播到其他所有并行节点上(不是空余节点)，这样在广播操作结束后，所有节点上的数据集$R<em>k=\bigcup</em>{i=1}^{n}R_i=R$即为全集R；</li><li>build构建，构建哈希表，与hash-based相似；</li><li>prob检测，遍历另外一个数据集，输出连接结果，与hash-based相似.</li></ol></li></ul><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/duplicated-based.png" alt="duplicated-based"></p><h2 id="PRPD连接算法"><a href="#PRPD连接算法" class="headerlink" title="PRPD连接算法"></a>PRPD连接算法</h2><ol><li><p>PRPD定义：partial redistribution &amp; partition duplication，即将hash-based和duplication-based相结合.</p></li><li><p>处理流程，如下图所示：处理数据集R和S的连接，假设R是均匀分布，S是倾斜分布. 将每个节点中存储的S划分为两部分，$S<em>{loc}$是倾斜数据子集，$S</em>{redis}$是剩余的非倾斜数据子集.前者保留才原节点中不动，后者需要根据连接键值重新分发到一个空余节点中，类似与hash-based中的distribution操作. 同样，将每个节点中存储的R划分为两部分，$R<em>{dup}$是与$S</em>{loc}$连接键值相同的数据子集，$R<em>{redis}$是剩余的数据子集. 前者需要广播到其余所有的原节点中，类似于duplication-based中的duplication操作，后者需要根据连接键值重新分发到空余节点中，按照hash-based的最后两步，与$S</em>{redis}$进行连接.</p><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/PRPD.jpg" alt="PRPD"></p></li><li><p>存在的问题：</p><ul><li>global skew，涉及到的对数据集S和R的划分需要预先获取每个节点上的倾斜键值的分布；</li><li>broadcasting，数据子集R的广播操作对网络负载施压，并且广播量将随着节点数量的增加而增加.</li></ul></li></ol><h2 id="本文提出算法"><a href="#本文提出算法" class="headerlink" title="本文提出算法"></a>本文提出算法</h2><p>PRPQ是基于两个可有效处理数据倾斜的分布式连接算法，semijoin-based和query-based. 基于这两者，提出改进.</p><h3 id="Semijoin-based-连接"><a href="#Semijoin-based-连接" class="headerlink" title="Semijoin-based 连接"></a>Semijoin-based 连接</h3><ol><li><p>semi-join的定义：半连接，从一个表中返回的行与另一个表中数据进行<strong>不完全</strong>连接查询，即查找到匹配的数据行就返回，不再继续查找.</p></li><li><p>semijoin-based连接，如下图所示. 数据集R和S在各自的属性a和b上做连接操作，分为以下四步骤：</p><ol><li>类似于hash-based中的第1,2两步，将各个节点中的数据集$R_i$按照连接属性的哈希值进行切分，再将元组分发到各自对应的空闲计算节点中(图中的红色虚线);</li><li>对各个节点中的数据集$S_i$在属性b上做投影操作得到$\pi_b(S_i)$，根据哈希值将这些属性b的unique key分发到计算节点中；</li><li>每个计算节点k收到数据集S的key 子集$\pi<em>b(S</em>{ik})$，和数据集R的子集$R<em>k=\bigcup</em>{i=1}^nR_{ik}$，对这两个子集做连接操作，将能连接上的R元组回发到各自的原节点i上(图中的③号线)；</li><li>各个原节点接收到retrieval返回的R集元组，与本地存储的S集元组做最后实际的连接操作，输出结果.</li></ol><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/semijoin.png" alt="semijoin"></p></li><li><p>特点：</p><ul><li>由于<strong>投影</strong>操作，S数据集只考虑unique key，而不考虑key的粒度，因此可以<strong>解决数据倾斜</strong>；</li><li>第2和第3步骤，只传输key和能连接上的元组，因此<strong>减轻了网络传输代价</strong>.</li><li>对于高选择性的连接，第2步和第3步中，S集的key和retrieval的R集元组交叠的数据量较大，仍然可能带来很大的网络通信量.</li></ul></li></ol><h3 id="Query-based-连接"><a href="#Query-based-连接" class="headerlink" title="Query-based 连接"></a>Query-based 连接</h3><ol><li><p>根据semijoin-based的第三个特点(存在的问题)，对第3和第4步进行改进，则有query-based连接算法.改进如下：</p><ol><li>若存在连接上的key和R集元组，则只返回value，而不是整个元组；若没有数据能连接上，则返回值为null的value；</li><li>返回的value和本地的S数据集做最后的实际连接操作，输出连接结果.</li></ol></li><li><p>特点：</p><ul><li>对于高选择性的连接处理，优势大，减轻网络通信负载；</li><li>对于低选择性的连接处理，存在问题，对于第3步没有能连接上的key，需要给返回的value赋值为null，以保证<key,value>的序列以便最后的连接处理，因此可能降低处理速度.</key,value></li></ul></li><li><p>折中综合：通过一个<strong>计数器</strong>来统计第3步骤中null出现的比例，从而动态地选择适合的方法，即当null比例较低时，使用query-based，否则使用semijoin-based.</p><h3 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h3><p>本文比较推崇直接在内存中进行连接计算，而不使用基于磁盘的计算框架比如MapReduce. 因此网络通信成本至关重要.当处理大规模的连接操作，上述两种方法都可能遭遇无法接受的网络通信负荷.</p><h3 id="PRPQ连接算法"><a href="#PRPQ连接算法" class="headerlink" title="PRPQ连接算法"></a>PRPQ连接算法</h3><ol><li><p>PRPQ定义：partial redistribution &amp; partial query，将hash-based和query-based相结合，如下图所示，分为四步骤：</p><ol><li><p>R distribution，与hash-based类似，将各个节点i上存储的数据集$R_i$根据连接属性a的哈希值，重新分发到一个空余计算节点上(图中红色虚线①)；</p></li><li><p>Push query keys，将各个节点i上存储的数据集$S_i$划分为两部分，低数据倾斜部分$S_i^{‘}$和高数据倾斜部分$h_i$. 根据连接属性b的哈希值，同时将$S_i^{‘}$的元组和$h_i$的投影unique key集合$\pi_b(h)$重新分发到对应的计算节点上(图中紫色虚线②)；</p></li><li>Return queried values，在每个计算节点k上，与hash-based的第3步类似，对集合$R<em>k=\bigcup</em>{i=1}^{n}R<em>{ik}$建立哈希表，(1). 对接收到的集合$\bigcup</em>{i=1}^{n}S_{ik}^{’}$进行遍历，并查找哈希表，直接输出连接结果；(2). 对接收到的key集合$\pi<em>b(h</em>{ik})$也遍历并查找路由表，如果没有匹配的key，则将retrieval的value置为null，若有匹配的key，则返回对应R的value.所有返回的value和节点k接收到key的顺序一致，并返回发送到原节点i；</li><li>Result lookup，接收到计算节点返回的value集合之后，在原节点中遍历value，并和本地存储的数据集S的高倾斜部分h进行连接，输出连接结果：若value为null，则继续扫描下一个；若不为空，则必定存在一个R和S的元组能连接上. 因此，最终的连接结果是第3步骤的部分结果$\bigcup$第4部分的连接结果.</li></ol><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/PRPQ.png" alt="PRPQ"></p></li><li><p>特点：</p><ul><li>与query-based算法相比<ol><li>当处理的数据集包含大量倾斜程度低的数据时，在网络上传送的query key以及对应的value的规模将相当小. 在倾斜程度为0的情况下，即为hash-based算法的实现.因此，PRPQ算法有效地弥补了query-based算法的缺点，提高了鲁棒性.</li><li>继承了query-based算法的优点，处理倾斜程度高的数据集时，大大减少网络通信量，因为高倾斜的元组并没有直接在网络上传输，而仅仅传输其unique key. </li></ol></li><li>与PRPD算法相比<ol><li>最主要的区别在于，使用query而不是duplication操作.</li><li>PRPQ涉及到的数据划分(第2步骤对S数据集进行倾斜程度的划分)，只定性分析局部的倾斜度，而不需要全局的；而PRPD需要获取全局数据集S的倾斜分布信息.关于如何定义全局倾斜，PRPD在连接操作之前将倾斜程度高的元组均匀分发到所有节点上.这个预处理操作会带来额外的通信代价.</li><li>对于倾斜程度中等mid-skew的元组，如何确定问题，PRPD使用广播的操作，可能导致节点负荷超载.</li></ol></li></ul></li></ol></li></ol><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p>每个节点上skew元组的提取是基于局部倾斜量化，因此引入一个阈值参数，即当一个key出现的次数超过该阈值，则视这个key为skewed. 下面先整理如何处理阈值参数，再整理PRPQ算法的具体实现.</p><h3 id="局部数据倾斜"><a href="#局部数据倾斜" class="headerlink" title="局部数据倾斜"></a>局部数据倾斜</h3><p>有很多方法可实现局部数据倾斜的快速监测，比如采样，扫描等.但是这些与本文的思路无关，所以本文仅仅在每个节点中对key的出现次数进行<strong>计数</strong>，按照降序排列，并保存到文件中. 在每一次的参数测试中，每个节点预先读取出现次数超过t的key，写入一个ArrayList中，并视它们为skew key.</p><h3 id="PRPQ具体实现"><a href="#PRPQ具体实现" class="headerlink" title="PRPQ具体实现"></a>PRPQ具体实现</h3><p>具体算法和前面的四个步骤一一对应，如下：</p><ol><li><p>在每个原节点中，将所有的元组读取到一个ArrayList中，处理数据集R的元组. 首先初始化一个R_c，用于收集分组的元组，R_c的初始化大小为计算节点的数量.接着，各个线程读取ArrayList中的R集元组，根据连接key的哈希值对元组进行分组.最后，将分好组的元组分发到对应的计算节点中(算法中的here表示当前计算节点的id).</p><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/RDistribution.png" alt="RDistribution"></p></li><li><p>根据给定的阈值参数t，对数据集S进行划分，倾斜的key被读入一个hashset，并且所有对应的元组被存储到一个hashmap中，剩余的非倾斜元组存储到一个$S^{’}_c$中.接着对hashmap进行投影操作，将所有的unique keys保存到key_c中.最后将key_c和$S^{’}_c$按照key的哈希值分发到对应的计算节点上.</p><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/PushQueryKey.png" alt="PushQueryKey"></p></li><li><p>在计算节点中，对接收到的R集元组建立一个哈希表T’，对数据集$S’$元组进行遍历，并查找哈希表，若有匹配的key，则输出连接结果.同时遍历key集key_c，并查找哈希表，若不存在匹配的key，则返回值为null的value到对应的原节点，否则返回实际key对应的value.</p><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/ReturnQueryValue.png" alt="ReturnQueryValue"></p></li><li><p>倾斜元组的连接结果可以通过遍历查询返回的value集合，若value为null，则不存在能连接上的S集元组，否则输出最终连接结果.</p><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/ResultLookup.png" alt="ResultLookup"></p></li></ol><h2 id="实验对比"><a href="#实验对比" class="headerlink" title="实验对比"></a>实验对比</h2><p>数据集的选取：用作基准的数据集模仿决策支援系统下的连接操作.数据集R的cardinality为64M，数据集S的cardinality为1GB.由于数据仓储中数据一般以面向列的形式存储，所以实验中将数据格式设置为<key,value>的键值对，其中key和value均是8字节整型.</key,value></p><p>工作负载的选取：设置数据集R和S之间存在外键的关系，保持R的主键的unique，而在S中为对应的外键增加skew.除此之外，若S是统一分布的，它们中的每一个以相同的概率匹配关系R中的元组.对于倾斜的元组，它们的unique key在节点间均匀分布，并且每一个均能与R匹配上.下表给出了数据集S的分布情况.</p><table><thead><tr><th>S</th><th>key distribution</th><th>Partition</th><th>Size</th></tr></thead><tbody><tr><td>Zipf</td><td>skew=0,1,1.4</td><td>均匀evenly</td><td>512M</td></tr><tr><td>Linear</td><td>f(r)=46341-r,23170</td><td>排序范围sort-range</td><td>1GB,2GB</td></tr></tbody></table><p>Zipf分布中，skew=0表示统一分布，skew=1表示排名前十的key占据总量14%，skew=1.4表示排名前十的key占据总量68%.线性分布中，使用f(r)来描述key的分布情况，其中f(r)=46341-r表示频率最高的key出现46341次，频率第二的key出现46340次.使用该函数生成的数据集可以看作low-skewed的数据集.f(r)=23170表示所有的key都是均匀分布的，但是重复次数较高.f(r)对应的两个数据集均为1GB的大小，有46341个unique key.</p><p>R和S在计算节点中的分布情况：R均匀分布在所有的节点上，而S使用均匀和排序范围分布.均与分布保证每个计算节点上skewed元组的数量相同；排序范围分布是先将所有的元组按照键的频率排序，然后等分成大小一样的块，再将块按照次序分配到每个计算节点上.因此每个节点上skewed元组的数量差距可能会比较大.</p><p>实验共从运行时间、网络通信、负载均衡、可扩展性四个方面来进行比较.这里只就运行时间稍作整理.</p><h3 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h3><p>记录Hash-based算法、PRPD、PRPQ和query-based算法的运行时间，如下图所示.当S是均匀分布(第一组数据skew=0)，Hash、PRPD和PRPQ算法的性能相近，远远优于Query算法；当S是low skewed时，PRPD和PRPQ均比另外两种算法快；当S是high skewed时，Hash算法性能最差，而其余三种性能相近，则可得出结论，其余PRPD、PRPQ和Query可以较好地处理数据倾斜.随着skew程度的增加，Hash算法的执行时间增长剧烈，而Query算法呈现下降趋势.而PRPD和PRPQ算法呈现平稳的下降趋势.</p><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/Runtime.png" alt="Runtime"></p><p>上图展示是选择最佳频率阈值t的性能，原文中关于不同阈值的实验这里不再整理，基本情况是无论t值如何变化以及分区计划如何，PRPQ的运行时间是低于PRPD的.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;并行连接处理的两种基本框架&quot;&gt;&lt;a href=&quot;#并行连接处理的两种基本框架&quot; class=&quot;headerlink&quot; title=&quot;并行连接处理的两种基本框架&quot;&gt;&lt;/a&gt;并行连接处理的两种基本框架&lt;/h2&gt;
    
    </summary>
    
      <category term="论文阅读" scheme="http://tankcat2.com/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="data skew" scheme="http://tankcat2.com/tags/data-skew/"/>
    
      <category term="parallel join" scheme="http://tankcat2.com/tags/parallel-join/"/>
    
  </entry>
  
  <entry>
    <title>使用Storm遇到的问题以及解决方案</title>
    <link href="http://tankcat2.com/2016/12/30/stormproblems/"/>
    <id>http://tankcat2.com/2016/12/30/stormproblems/</id>
    <published>2016-12-30T05:45:31.000Z</published>
    <updated>2017-01-17T12:32:46.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>集群中有3台服务器执行 storm supervisor命令后自动退出，supervisor起不来，后来在 logs目录下的supervisor.log日志文件中查到以下报错：</li></ol><a id="more"></a>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">12</span>-<span class="number">30</span> <span class="number">12</span>:<span class="number">41</span>:<span class="number">17.269</span> b.s.event [ERROR] Error when processing event</span><br><span class="line">java.lang.RuntimeException: java.lang.RuntimeException: java.io.FileNotFoundException: File <span class="string">'/home/admin/stormdata/data/supervisor/localstate/1480504905565'</span> does not exist</span><br><span class="line">at backtype.storm.utils.LocalState.partialSnapshot(LocalState.java:<span class="number">118</span>) ~[storm-core-<span class="number">0.10</span>.0.jar:<span class="number">0.10</span>.0]</span><br><span class="line">at backtype.storm.utils.LocalState.get(LocalState.java:<span class="number">126</span>) ~[storm-core-<span class="number">0.10</span>.0.jar:<span class="number">0.10</span>.0]</span><br><span class="line">at backtype.storm.local_state$ls_local_assignments.invoke(local_state.clj:<span class="number">83</span>) ~[storm-core-<span class="number">0.10</span>.0.jar:<span class="number">0.10</span>.0]</span><br><span class="line">at backtype.storm.daemon.supervisor$sync_processes.invoke(supervisor.clj:<span class="number">321</span>) ~[storm-core-<span class="number">0.10</span>.0.jar:<span class="number">0.10</span>.0]</span><br><span class="line">at clojure.lang.AFn.applyToHelper(AFn.java:<span class="number">154</span>) ~[clojure-<span class="number">1.6</span>.0.jar:?]</span><br><span class="line">at clojure.lang.AFn.applyTo(AFn.java:<span class="number">144</span>) ~[clojure-<span class="number">1.6</span>.0.jar:?]</span><br><span class="line">at clojure.core$apply.invoke(core.clj:<span class="number">626</span>) ~[clojure-<span class="number">1.6</span>.0.jar:?]</span><br><span class="line">at clojure.core$partial$fn__4228.doInvoke(core.clj:<span class="number">2468</span>) ~[clojure-<span class="number">1.6</span>.0.jar:?]</span><br><span class="line">at clojure.lang.RestFn.invoke(RestFn.java:<span class="number">397</span>) ~[clojure-<span class="number">1.6</span>.0.jar:?]</span><br><span class="line">at backtype.storm.event$event_manager$fn__7258.invoke(event.clj:<span class="number">40</span>) [storm-core-<span class="number">0.10</span>.0.jar:<span class="number">0.10</span>.0]</span><br><span class="line">at clojure.lang.AFn.run(AFn.java:<span class="number">22</span>) [clojure-<span class="number">1.6</span>.0.jar:?]</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">744</span>) [?:<span class="number">1.7</span>.0_45]</span><br></pre></td></tr></table></figure><p>   找不到’/home/admin/stormdata/data/supervisor/localstate/1480504905565’这个文件夹，网上找了下原因，给出的答案是<strong>stop the server without previously stop the supervisor</strong>，就是说可能是由于不正常关机造成状态不一致，具体原因不知，解决方案是<strong>删除stormdata/data/supervisor整个目录即可</strong>.</p><ol><li><p>在集群环境下日志清理，自己写了一个脚本clear-log.sh，主要是删除apache-storm-XXX下的logs文件里的日志文件，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">STORM_HOME=/home/admin/apache-storm-0.10.0　</span><br><span class="line">HOSTS_FILE=/home/admin/hosts.txt</span><br><span class="line">cat $HOSTS_FILE | while read line</span><br><span class="line">do</span><br><span class="line">ssh $line "rm -rf $STORM_HOME/logs/*" &lt; /dev/null</span><br><span class="line">done</span><br><span class="line">echo "remove log files...done"</span><br></pre></td></tr></table></figure></li></ol><p>其中STORM_HOME是storm的安装路径，hosts.txt是集群中各个节点的地址，我自己的配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">admin@10.11.1.53</span><br><span class="line">admin@10.11.1.40</span><br><span class="line">admin@10.11.1.41</span><br><span class="line">admin@10.11.1.42</span><br><span class="line">admin@10.11.1.45</span><br><span class="line">admin@10.11.1.46</span><br><span class="line">admin@10.11.1.51</span><br><span class="line">admin@10.11.1.53</span><br><span class="line">admin@10.11.1.54</span><br><span class="line">admin@10.11.1.55</span><br><span class="line">admin@10.11.1.56</span><br><span class="line">admin@10.11.1.58</span><br><span class="line">admin@10.11.1.60</span><br><span class="line">admin@10.11.1.64</span><br></pre></td></tr></table></figure><p>编辑完之后执行<code>chmod +x clear-log.sh</code>命令使得该文件获得可执行权限，再执行<code>./clear-log.sh</code>运行该脚本即可.</p>]]></content>
    
    <summary type="html">
    
      本文是我在使用Storm的过程中遇到的各种问题以及对应的解决方案，有些问题可能无法给出理由，不定期更新.
    
    </summary>
    
      <category term="Storm学习之路" scheme="http://tankcat2.com/categories/Storm%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Storm" scheme="http://tankcat2.com/tags/Storm/"/>
    
      <category term="日志" scheme="http://tankcat2.com/tags/%E6%97%A5%E5%BF%97/"/>
    
      <category term="环境配置" scheme="http://tankcat2.com/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>关于苏打绿的题库</title>
    <link href="http://tankcat2.com/2016/10/26/knowledgebase/"/>
    <id>http://tankcat2.com/2016/10/26/knowledgebase/</id>
    <published>2016-10-26T08:26:31.000Z</published>
    <updated>2016-10-26T10:53:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-团队成员"><a href="#1-团队成员" class="headerlink" title="1.团队成员"></a>1.团队成员</h1><p> 6个人。<br> 吴青峰：主唱，1982.8.30，台湾台北，国立政治大学中文系，钢琴、口琴、口风琴、打击乐器、长笛<br> 谢馨仪：贝斯手，1982.4.16，台湾台北，国立政治大学科技管理研究所，贝斯、钢琴、摇滚吉他、古筝<br> 史俊威：鼓手，1979.8.26，台湾，国立政治大学社会系，吉他、鼓、口琴<br> <a id="more"></a><br> 龚钰祺：键盘手+中提琴手,1980.12.16，台湾，国立台北艺术大学音乐研究所，中提琴、钢琴、电子琴<br> 刘家凯：电子吉他手，1982.2.5，台湾台北，国立政治大学心理系、国立阳明大学脑科学研究所，吉他<br> 何景扬：木吉他手，1982.4.4，台湾，国立政治大学公共行政研究所，吉他、乌克丽丽</p><h1 id="2-重要时间节点"><a href="#2-重要时间节点" class="headerlink" title="2. 重要时间节点"></a>2. 重要时间节点</h1><p> 2001年成立于校园，2003年确立6人阵容，2004年5月，苏打绿正式出道，发行第一张单曲《空气中的视听与幻觉》。<br> 2005年，苏打绿发行了《SodaGreen》。<br> 2006年，苏打绿发行专辑《小宇宙》。<br> 2007年11月，苏打绿发行专辑《无与伦比的美丽》。<br> 2008年5月，苏打绿发行专辑《陪我歌唱》。<br> 韦瓦第计划：2009年5月8日，苏打绿发行了第五张专辑《春·日光》；2009年9月11日，苏打绿发行专辑《夏·狂热》；2013年9月18日，苏打绿发行专辑《秋：故事》，该专辑成为2013年度iTunes Store最受欢迎专辑；2015年9月23日，苏打绿发行专辑《冬·未了》。<br> 2011年<br> 2011年11月11日，苏打绿发行专辑《你在烦恼什么》。<br> 2014年，苏打绿开始了十周年世界巡回演唱会。</p><h1 id="3-唱片公司"><a href="#3-唱片公司" class="headerlink" title="3. 唱片公司"></a>3. 唱片公司</h1><p> 2004-2009，林浩哲音乐社；<br> 2009-至今，环球唱片</p><h1 id="4-“游乐园鱼丁糸”比赛题"><a href="#4-“游乐园鱼丁糸”比赛题" class="headerlink" title="4. “游乐园鱼丁糸”比赛题"></a>4. “游乐园鱼丁糸”比赛题</h1><h2 id="第一轮"><a href="#第一轮" class="headerlink" title="第一轮"></a>第一轮</h2><p> 单选题（以下各题四个选项中,只有一个选项正确）：</p><ol><li>EP《空气中的视听与幻觉》碟的颜色为：D<br>A、白B、红C、蓝D、墨绿</li><li>迄今为止仍未引进内地的苏打绿正式专辑是：A<br>A、无与伦比的美丽 B、小宇宙 C、同名专辑 D、陪我歌唱</li><li>青峰创作的第一首歌是：D<br>A、空气中的视听与幻觉 B、降落练习存在孪生基因 C、后悔莫及 D、窥</li><li>03年海洋音乐祭时，谁迟到了？C<br>A、家凯 B、阿福 C、小威D、青峰 </li><li>家凯、林暐哲法国街头赛跑谁赢了？A<br>A、家凯B、林暐哲C、都赢D、无法评判</li><li>图片题（见附件）：这张是苏打绿在大陆第一场演唱会（615北京场）的新闻图片，请问方框里面的人是谁？C<br>A、茶水 B、lfxfox C、博博鱼 D、和尚</li><li>苏打绿第一任的团长是谁？A<br>A.小威 B.阿福 C.馨仪 D.青峰 </li><li>苏打绿第一张同名专辑共有几首歌？D<br>A、2  B、3  C、10  D、11</li><li>苏打绿一共来过上海几次？B<br>A、1  B、2  C、3  D、4</li><li>苏打绿的第三张单曲是：C<br>A、空气中的视听与幻觉  B、飞鱼  C、Believe in music  D、迟到千年</li><li>苏打绿成军时间：B<br>A、2000  B、2001  C、2004  D、2005</li><li>“我想到你离开了以後，我们的城市好寂寞”选自苏打绿的哪首歌曲？B<br>A、无与伦比的美丽  B、雨中的操场  C、相信  D、城市</li><li>单曲《飞鱼》中有几首歌？D<br>A、1  B、2  C、3  D、4</li><li>苏打绿首次来内地时青峰裤子上的油漆是怎么来的：C<br>A、裤子本身印有的 B、被团员泼的 C、自己粉刷房间墙壁弄的D、不知道</li><li>以下苏打绿未上过的台湾综艺节目是：B<br>A、娱乐百分百 B、康熙来了 C、国光帮帮忙 D、大学生了没</li><li>第18届金曲奖最佳作曲人奖是因为哪首歌？B<br>A、小宇宙   B、小情歌   C、频率    D、飞鱼</li><li>红包场中，谁是王子造型的？D<br>A、青峰   B、家凯    C、阿龚    D、馨仪</li><li>小情歌是为了哪个艺人的唱片公司收歌而写？C<br>A、刘若英  B、江美琪  C、徐若瑄  D、杨乃文</li><li>《爱人动物》是以下哪部电影的主题曲？B<br>A、情非得已之生存之道  B、Juno  C、囧男孩  D、海角七号</li><li>「无与伦比的美丽」小巨蛋演唱会是几月几号？C<br>A、2007.11.1  B、2007.11.2  C、2007.11.3   D、2007.11.13</li></ol><h2 id="第二轮"><a href="#第二轮" class="headerlink" title="第二轮"></a>第二轮</h2><p> <img src="http://7xwggp.com1.z0.glb.clouddn.com/w0gab4.jpg" alt="高级题"><br> 单选题：<br> 1~5 BDB(D)CD<br> 6~10 CCCCB<br> 11~15DCCBC<br> 16~2 0ABADD<br> 多选题：<br> 1.BDEF<br> 2.CD<br> 3.BCDE<br> 4.AC<br> 5.ACD<br> 6.BCD<br> 7.ABC<br> 8.ABC<br> 9.ACD<br> 10.DE </p><h2 id="第三轮"><a href="#第三轮" class="headerlink" title="第三轮"></a>第三轮</h2><p> <img src="http://7xwggp.com1.z0.glb.clouddn.com/8zpkk9.jpg" alt="高级题"></p><h2 id="模拟题1"><a href="#模拟题1" class="headerlink" title="模拟题1"></a>模拟题1</h2><p>单选题：</p><ol><li>王菀之的首张国语创作专辑中多少首歌是由青峰作词？C<br>A、3  B、4   C、5  D、6</li><li>615北京演唱会开场歌曲是什么？A<br>A、无与伦比的美丽  B、小宇宙  C、小情歌  D、白日出没的月球</li><li>1224广州演唱会最后一首歌曲是：D<br>A、频率  B、小情歌  C、这天  D、陪我歌唱</li><li>苏打绿夺得了第几届海洋音乐祭的陪审团大奖？B<br>A、4  B、5  C、6  D、7</li><li>家凯是因为想参加什么音乐节而加入苏打绿的？B<br>A、春浪 B、春天呐喊 C、海洋音乐祭 D、简单生活</li><li>第一期空气中的视听与幻觉广播是06年几月几号？B<br>A、0906  B、1007  C、1017  D、1104</li><li>苏打绿的第一首抒情歌是：A<br>A、    频率  B、无言歌  C、背着你  D、小情歌</li><li>以下哪首是政大吉他社社歌？ C<br>A、天天想你 B、我的未来不是梦 C、我呼吸我感觉我存在 D、和天一样高</li><li>除了小巨蛋演唱会之外，哪一个影像保存了苏打绿《是我的海》的live演出？D<br>A、好友音乐会    B、周日狂热夜    C、摇滚风城音乐祭    D、 Taiwan Roc</li><li>在小巨蛋DVD中，青峰一共talking了多少次（不包括唱歌中以及预报下一首歌）？B<br>A、4次     B、5次     C、6次      D、7次</li><li>《Air》里的Bass是谁弹的？D<br>A、家凯     B、馨怡     C、阿福    D、阿龚</li><li>《搜包包》中谁全程站在家凯的面前？A<br>A、tirtir   B、小威   C、青峰   D、将将</li><li>《当代歌坛》第一次出现专写苏打绿的文章是哪一期？C<br>A、342期B、370期C、363期D、389期</li><li>创作给别人的歌中，青峰最喜欢哪首？A<br>A、女爵B、多希望你在C、穿墙人D、爱与奇异果</li><li>苏打绿中谁一直没有拿到高中毕业证书：D<br>A、家凯 B、阿龚 C、阿福 D、小威</li><li>在豆瓣公开现身过的苏打绿团员是：C<br>A、家凯 B、阿龚 C、阿福 D、小威</li><li>苏打绿现在的六人编制的第一次演出是在哪里？B<br>A、春天呐喊 B、政大金旋奖 C、西门町 D、海洋音乐祭</li></ol><p>多选题：</p><ol><li>下面不属于919上海演唱会安可曲目的是：DE<br>A、相信  B、这天  C、女爵  D、是我的海》  E、白日出没的月球</li><li>“搁浅”一词出现在以下哪些歌曲中：ABCE<br>A、吵  B、迟到千年  C、蓝眼睛 D、无与伦比的美丽  E、漂浮</li><li>青峰曾为以下哪些艺人写歌？ACDE<br>A、左光平  B、尚雯婕  C、张韶涵  D、刘若英  E、王菀之</li></ol><p>填空（每题5分，共5题）</p><ol><li>“各站停靠”演唱会上，作为舞台背景的钟显示的时间是<strong><strong>22:15__</strong></strong></li><li>2010年青峰和小威一起庆生时，其他团员送他们的礼物是<strong>_小时候照片拼贴出来的相框__</strong></li><li>阿福在自由发挥的歌曲<strong>_欢迎光临__</strong>的MV中客串演出了一个角色</li><li>各站停靠台中场的小礼物是<strong>_阿福面纸__</strong></li><li>苏打绿出道时候的第一支广告是<strong>_<em>蔡康永</em></strong>推荐的广播广告</li></ol><h2 id="模拟题2"><a href="#模拟题2" class="headerlink" title="模拟题2"></a>模拟题2</h2><p> 单选（以下各题，只有一个正确选项。每题5分，共10题）</p><ol><li>苏打绿二度踏上小巨蛋举办“日光狂热”演唱会前，媒体特地准备多样运动器材帮忙训练体力。结果，阿福在哪样器械上竟然输给了馨仪？C<br>A.滚轮  B.握力棒 C.哑铃 D.铁饼</li><li>青峰对自己人生过程进行总结的歌是 D<br>A.交响梦    B.融雪之前    C.相信    D.近未来</li><li>苏打绿、王菀之、方大同合作的903拉阔演唱会上，他们约定好各自代表的颜色，分别是 D<br>A.黑、白、绿        B.黑、绿、白<br>C.绿、黑、白        D.绿、白、黑</li><li>被媒体拍到跟青峰一起看电影，并且对镜头比中指的女友人是 A<br>A.小兔    B.张悬    C.娃娃    D.阿纯</li><li>歌词本的字型让“吴青峰写到手心手背都是肉”的专辑是 C<br>A. 苏打绿同名  B.春•日光  C.陪我歌唱   D.无与伦比的美丽</li><li>这是2010年5月苏打绿参加利物浦音乐节的返国记者会照片。请问青峰的这件衬衫，还在以下哪场公开表演中穿过？D<br>A.成都热波音乐节 B.北京原创A8颁奖礼 C.西安草莓音乐节 D.西湖音乐节</li><li>在《日光》MV中，和大家一起采茶的团员是：A<br>A.阿龚    B.小威    C.馨仪    D.家凯</li><li>来源于青峰日记的歌词是:C<br>A.近未来    B.女爵    C.困在    D.早点回家</li><li>苏打绿一共参与过几次简单生活节:C<br>A.1次    B.2次    C.3次    D.4次</li><li><p>阿福入伍前的饯别仪式上，第一个给阿福剪头发的团员是:A<br>A.青峰    B.馨仪    C.小威    D.家凯    </p><p>多选（以下各题有两个或两个以上的正确选项，多选、漏选、错选均不得分。每题5分，共5题）</p></li><li>在“最会睡”系列中，暐哲老师睡觉的地点有：ABCDE<br>A.馨仪家    B.伦敦录音室    C.草地     D.公司地板     E.会议室沙发</li><li>The Wall“多希望你在”系列演出的歌单中包含：ABCE<br>A.疼惜我的吻 B.吵 C.我在欧洲打电话给你 D.寂寞拥挤E.再见</li><li>“维瓦第计划”的歌词中，没有出现的意象是:BC<br>A.萤火虫    B.羔羊   C.海豚    D.白鸽    E.落叶</li><li>以下歌曲中，苏打绿有公开表演多个语言版本的是ACE<br>A.Oh Oh Oh Oh    B.飞鱼    C.无眠    D.日光    E.小情歌</li><li>游乐园的官方周边包括BCDE<br>A. .海报B.T恤 C.贴纸 D.徽章 E.年历</li></ol><p>填空题</p><ol><li>《小宇宙》这首歌标题的灵感来自<strong><strong>陈黎的《小宇宙》_</strong></strong>。</li><li>《小情歌》在被徐若瑄拒绝后，又被<strong><em>江美琪</em></strong>拒绝。</li><li><em>2005</em>年<strong>9_月</strong>3_日发行首张同名专辑《苏打绿》及进行全省签唱会表演。</li><li>青峰的小学时期，每天早上跟着跳的早操音乐是 我的未来不是梦。</li><li>无美丽电台的封面除了苏打绿六个人外还有谁？ 将将</li></ol><h1 id="5-获奖情况"><a href="#5-获奖情况" class="headerlink" title="5.获奖情况"></a>5.获奖情况</h1><ul><li>2016    第27届台湾金曲奖    最佳国语专辑奖     冬未了    （获奖）    </li><li>2016    第27届台湾金曲奖    最佳乐团奖    （获奖）    </li><li>2016    第27届台湾金曲奖    最佳编曲人奖    痛快的哀艳    （获奖）    </li><li>2015    第五届阿比鹿音乐奖    最受欢迎唱片    冬未了     （获奖）    </li><li>2014    第36届十大中文金曲    全年最高销量歌手    秋:故事    （获奖）    </li><li>2013    第7届无线咪咕汇音乐盛典    年度最受欢迎组合    韦瓦第计划    （获奖）    </li><li>2012    Hito流行音乐奖    hito乐团    （获奖）    </li><li>2011    第1届全球流行音乐金榜    年度最佳乐团    （获奖）    </li><li>2011    第1届全球流行音乐金榜    年度20大金曲    十年一刻    （获奖）    </li><li>2010    第10届华语音乐传媒大奖    最佳乐队    春·日光、夏/狂热    （获奖）    </li><li>2010    MusicRadio中国TOP排行榜    年度最受欢迎乐团    （获奖）    </li><li>2010    MusicRadio中国TOP排行榜    年度最佳乐团    （获奖）    </li><li>2010    新加坡金曲奖    最佳创作歌手    夏/狂热    （获奖）    </li><li>2010    新加坡金曲奖    最佳乐团    （获奖）    </li><li>2010    第21届金曲奖    最佳音乐录像带奖    日光    （获奖）    </li><li>2010    第21届金曲奖    最佳编曲人    日光    （提名）    </li><li>2010    第21届金曲奖    最佳乐团    春·日光    （提名）    </li><li>2010    第21届金曲奖    最佳乐团    夏/狂热    （提名）    </li><li>2009    第32届香港十大中文金曲颁奖典礼    全国最佳组合    （获奖）    </li><li>2009    MY Astro 至尊流行榜颁奖典礼    至尊组合/乐团    （获奖）    </li><li>2009    MY Astro 至尊流行榜颁奖典礼    至尊金曲20    狂热    （获奖）    </li><li>2009    第4届A8原创中国音乐盛典    年度最佳原创乐团    （获奖）    </li><li>2009    MUSIC RADIO中国TOP排行榜    港台年度最佳乐团    （获奖）    </li><li>2009    全球华语歌曲排行榜    地区杰出歌手奖    春·日光    （获奖）    </li><li>2009    全球华语歌曲排行榜    年度20大金曲    春·日光    （获奖）    </li><li>2009    全球华语歌曲排行榜    最佳编曲人    春·日光    （获奖）    </li><li>2009    全球华语歌曲排行榜    最佳乐团    春·日光    （获奖）    </li><li>2009    新城国语力颁奖礼    国语力亚洲乐团    （获奖）    </li><li>2009    新城国语力颁奖礼    国语力歌曲    日光    （获奖）    </li><li>2009    新城国语力颁奖礼    国语力乐团    （获奖）    </li><li>2009    新浪网络盛典    年度最佳乐团    （获奖）    </li><li>2008    第8届华语音乐传媒大奖    年度国语专辑    无与伦比的美丽    （获奖）    </li><li>2008    第8届华语音乐传媒大奖    最佳编曲人    白日出没的月球    （获奖）    </li><li>2008    第8届华语音乐传媒大奖    最佳乐队    无与伦比的美丽    （获奖）    </li><li>2008    香港新城国语颁奖礼    新城国语歌曲    陪我歌唱    （获奖）    </li><li>2008    香港新城国语颁奖礼    国语乐团    （获奖）    </li><li>2008    第9届CCTV/MTV音乐盛典    港台年度最佳组合    （获奖）    </li><li>2008    新城劲爆颁奖礼    新城全国乐迷投选劲爆突破表现大奖    （获奖）    </li><li>2008    新加坡金曲奖    最佳乐团    无与伦比的美丽    （获奖）    </li><li>2008    第19届金曲奖    最佳音乐录影带导演奖    左边    （提名）    </li><li>2008    第19届金曲奖    最佳年度歌曲    无与伦比的美丽    （提名）    </li><li>2008    第19届金曲奖    最佳编曲人    无与伦比的美丽    （提名）    </li><li>2008    第19届金曲奖    最佳乐团    无与伦比的美丽    （获奖）    </li><li>2007    新加坡金曲奖    最佳乐团    小宇宙    （获奖）    </li><li>2007    第44届金马奖    最佳原创电影歌曲    小情歌    （提名）    </li><li>2007    第18届金曲奖    最佳年度歌曲    小情歌    （提名）    </li><li>2007    第18届金曲奖    最佳国语专辑    小宇宙    （提名）    </li><li>2007    第18届金曲奖    最佳乐团    小宇宙    （获奖）    </li><li>2006    第17届金曲奖    最佳编曲人    Oh Oh Oh Oh    （提名）    </li><li>2004    MTV百万乐团挑战赛    网路最佳人气乐团    （获奖）    </li><li>2004    第5届海洋音乐祭    评审团大赏    （获奖）    </li><li>2002    政大第19届金旋奖    乐团组冠军    空气中的视听与幻觉    （获奖）    </li><li>2001    政大第18届金旋奖    乐团组最佳人气奖    （获奖）    <h1 id="6-老吴写给别人的歌"><a href="#6-老吴写给别人的歌" class="headerlink" title="6. 老吴写给别人的歌"></a>6. 老吴写给别人的歌</h1><h3 id="那英"><a href="#那英" class="headerlink" title="那英"></a>那英</h3>我的幸福刚刚好</li></ul><h3 id="林忆莲"><a href="#林忆莲" class="headerlink" title="林忆莲"></a>林忆莲</h3><p> 寂寞拥挤</p><h3 id="张惠妹"><a href="#张惠妹" class="headerlink" title="张惠妹"></a>张惠妹</h3><p> 掉了，你和我的时光</p><h3 id="李玟"><a href="#李玟" class="headerlink" title="李玟"></a>李玟</h3><p> 想你的夜</p><h3 id="莫文蔚"><a href="#莫文蔚" class="headerlink" title="莫文蔚"></a>莫文蔚</h3><p> 看着，老掉牙</p><h3 id="容祖儿"><a href="#容祖儿" class="headerlink" title="容祖儿"></a>容祖儿</h3><p> 在时间面前</p><h3 id="江蕙"><a href="#江蕙" class="headerlink" title="江蕙"></a>江蕙</h3><p> 你讲的话</p><h3 id="刘若英"><a href="#刘若英" class="headerlink" title="刘若英"></a>刘若英</h3><p> 没道理</p><h3 id="陶晶莹"><a href="#陶晶莹" class="headerlink" title="陶晶莹"></a>陶晶莹</h3><p> 翔</p><h3 id="蔡依林"><a href="#蔡依林" class="headerlink" title="蔡依林"></a>蔡依林</h3><p> 彩色相片，栅栏间隙偷窥你，迷幻</p><h3 id="杨丞琳"><a href="#杨丞琳" class="headerlink" title="杨丞琳"></a>杨丞琳</h3><p> 带我走，少年维特的烦恼，下个转弯是你吗，被自己绑架，一小节休息</p><h3 id="张韶涵"><a href="#张韶涵" class="headerlink" title="张韶涵"></a>张韶涵</h3><p> 最近好吗，刺情，蓝眼睛</p><h3 id="王心凌"><a href="#王心凌" class="headerlink" title="王心凌"></a>王心凌</h3><p> 从未到过的地方</p><h3 id="范玮琪"><a href="#范玮琪" class="headerlink" title="范玮琪"></a>范玮琪</h3><p> 坏了良心</p><h3 id="范晓萱"><a href="#范晓萱" class="headerlink" title="范晓萱"></a>范晓萱</h3><p> 开机关机</p><h3 id="杨乃文"><a href="#杨乃文" class="headerlink" title="杨乃文"></a>杨乃文</h3><p> 女爵</p><h3 id="许茹芸"><a href="#许茹芸" class="headerlink" title="许茹芸"></a>许茹芸</h3><p> 爱人动物，飞行时光，I will be with you，最难的是相遇，现在该怎么好，我留下的一个生活</p><h3 id="蔡健雅"><a href="#蔡健雅" class="headerlink" title="蔡健雅"></a>蔡健雅</h3><p> 极光，费洛蒙</p><h3 id="周笔畅"><a href="#周笔畅" class="headerlink" title="周笔畅"></a>周笔畅</h3><p> 别忘了</p><h3 id="谢安琪"><a href="#谢安琪" class="headerlink" title="谢安琪"></a>谢安琪</h3><p> 再见</p><h3 id="张悬"><a href="#张悬" class="headerlink" title="张悬"></a>张悬</h3><p> 两者</p><h3 id="徐佳莹"><a href="#徐佳莹" class="headerlink" title="徐佳莹"></a>徐佳莹</h3><p> 乐园</p><h3 id="魏如萱"><a href="#魏如萱" class="headerlink" title="魏如萱"></a>魏如萱</h3><p> 被雨伤透，困在，开机关机</p><h3 id="尚雯婕"><a href="#尚雯婕" class="headerlink" title="尚雯婕"></a>尚雯婕</h3><p> 什么？什么！</p><h3 id="吉克隽逸"><a href="#吉克隽逸" class="headerlink" title="吉克隽逸"></a>吉克隽逸</h3><p> 我唱故我在</p><h3 id="袁泉"><a href="#袁泉" class="headerlink" title="袁泉"></a>袁泉</h3><p> 等</p><h3 id="吴映洁"><a href="#吴映洁" class="headerlink" title="吴映洁"></a>吴映洁</h3><p> 一直</p><h3 id="刘容嘉"><a href="#刘容嘉" class="headerlink" title="刘容嘉"></a>刘容嘉</h3><p> 没有人爱</p><h3 id="潘玮仪"><a href="#潘玮仪" class="headerlink" title="潘玮仪"></a>潘玮仪</h3><p> 不同</p><h3 id="路嘉欣"><a href="#路嘉欣" class="headerlink" title="路嘉欣"></a>路嘉欣</h3><p> 穿墙人，当我继续唱</p><h3 id="王菀之"><a href="#王菀之" class="headerlink" title="王菀之"></a>王菀之</h3><p> 学会，迷湖，冬梦，是爱，爱与奇异果</p><h3 id="旅行团"><a href="#旅行团" class="headerlink" title="旅行团"></a>旅行团</h3><p> Bye Bye</p><h3 id="VOX玩声乐团"><a href="#VOX玩声乐团" class="headerlink" title="VOX玩声乐团"></a>VOX玩声乐团</h3><p> 让我做你的家，朱古力</p><h3 id="TFBOYS"><a href="#TFBOYS" class="headerlink" title="TFBOYS"></a>TFBOYS</h3><p> 小精灵</p><h3 id="谭咏麟"><a href="#谭咏麟" class="headerlink" title="谭咏麟"></a>谭咏麟</h3><p> 超越，糖衣陷阱，蓝侬梦，魔毯，算爱，未知</p><h3 id="张信哲"><a href="#张信哲" class="headerlink" title="张信哲"></a>张信哲</h3><p> 柔软</p><h3 id="陈奕迅"><a href="#陈奕迅" class="headerlink" title="陈奕迅"></a>陈奕迅</h3><p> 放弃治疗，这样的一个麻烦，谋情害命</p><h3 id="林俊杰"><a href="#林俊杰" class="headerlink" title="林俊杰"></a>林俊杰</h3><p> 独舞，爱的鼓励，裂缝中的阳光，不存在的情人</p><h3 id="萧敬腾"><a href="#萧敬腾" class="headerlink" title="萧敬腾"></a>萧敬腾</h3><p> 以爱之名，多希望你在</p><h3 id="杨宗纬"><a href="#杨宗纬" class="headerlink" title="杨宗纬"></a>杨宗纬</h3><p> 想对你说</p><h3 id="萧煌奇"><a href="#萧煌奇" class="headerlink" title="萧煌奇"></a>萧煌奇</h3><p> 下个街角</p><h3 id="信"><a href="#信" class="headerlink" title="信"></a>信</h3><p> 你存在，我记得，给自己的信</p><h3 id="左光平"><a href="#左光平" class="headerlink" title="左光平"></a>左光平</h3><p> 心里有鬼</p>]]></content>
    
    <summary type="html">
    
      AfterSummer抢票的关键呀~~第三轮答题木有找到答案！求神助攻！！！
    
    </summary>
    
      <category term="随笔" scheme="http://tankcat2.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="苏打绿" scheme="http://tankcat2.com/tags/%E8%8B%8F%E6%89%93%E7%BB%BF/"/>
    
  </entry>
  
  <entry>
    <title>遇见小公举</title>
    <link href="http://tankcat2.com/2016/10/23/jielun/"/>
    <id>http://tankcat2.com/2016/10/23/jielun/</id>
    <published>2016-10-23T13:21:31.000Z</published>
    <updated>2016-10-23T13:29:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>周杰伦是身边很多同龄人的偶像，他们应该从小学或者初中的时候就开始追他。同时期的还有蔡依林、张韶涵、林俊杰那些人，很奇怪当时我顶多是对他们的几首歌感兴趣，比如欧若拉，曹操，并没有萌生追星的概念。<br><a id="more"></a><br>我记不得听周杰伦的第一首歌是什么。小学六年级的时候我妈同事的女儿买了一个MP3,需要分外安电池的那种，里面有两首杰伦的歌，一首发如雪，一首夜曲。我借过来听，很喜欢这两首歌的旋律，后来搜到了歌词，就经常买花花绿绿的本子抄写歌词。到了初中，很多我很不喜欢的男生疯狂地迷恋周杰伦，可能因为女孩子成熟得早，特别反感他们自以为帅气的非主流风格（还有一个原因是很多喜欢周杰伦的人同时喜欢着许嵩）。本来因为杰伦不清楚的发音，我对他是无感的，但是因为一些烦人的粉丝，对歌手本人也没什么好感。后来到了大学，某个逗比室友对此和我惊人的相似。初中的时候我可能更多的是在追日漫，喜欢主题曲，还记得初二家里买电脑之前，星空卫视每天晚上6点放犬夜叉，我就拿着复读机录那首change the world。<br>到了高一，学校是明令禁止使用电子产品的，我用充饭卡的钱偷偷买了一个mp3,列了一个歌单让前桌的男生回家帮我下点歌，哪知道他全给我下的周杰伦。很幸运的是，他给我下的都是一些慢节奏情歌，最长的电影，给我一首歌的时间，甜甜的，说好的幸福呢，彩虹，七里香之类的。但也没有因为这些歌而粉上杰伦，还是听歌不看人的状态。<br>后来的后来，杰伦当了好声音的导师，看了一两期，发现他其实很个很可爱的人。再到现在，他的新专辑床边故事，那首前世情人，告白气球和now you see me，让我感觉，这就是从前那个酷酷的杰伦呀，那种我以前不屑的风格原来这么奇妙。于是一点没犹豫地在网易云上买了数字专辑。<br>今天大老远从上海跑到合肥听周杰伦的演唱会，虽然位子很不好，看不到人也算了，屏幕也看不到；虽然室外的音响效果也有点让人失望，那些快歌基本听不清歌词；虽然排队很长，座位坐得很乱…但是那些我自己很熟悉的旋律响起的时候，所有的举动只剩下舞动荧光棒，跟着一起唱。<br>让我印象很最深刻的是点歌环节，点到的第三个女孩子，杰伦问她是和谁一起来的，她说她一个人来的。当时杰伦愣了一下，然后安慰她说，全场的观众都是她的朋友，都陪着她听唱歌。当时我特别想去拥抱那个女生。一个人去看演唱会，身边都是情侣或者闺蜜团。你的注意力本该只放在爱豆身上，可无法避免的，有些场景，有些歌词就是会触动你内心那块最柔软的地方。这种经历我体验过。<br>错过了可以有多一点杰伦的年少时光有些遗憾，但也很幸运，我开始路转粉了，未来的路，还可以相伴而行。💗💗💗<br>ps:当然啦，如果能遇见一个喜欢人的一起去苏打绿的after summer，那么会更加幸运~~~</p>]]></content>
    
    <summary type="html">
    
      尽管是说遇见，其实连个大屏幕上的人脸都木有看到呀。。。
    
    </summary>
    
      <category term="随笔" scheme="http://tankcat2.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="周杰伦" scheme="http://tankcat2.com/tags/%E5%91%A8%E6%9D%B0%E4%BC%A6/"/>
    
  </entry>
  
</feed>
