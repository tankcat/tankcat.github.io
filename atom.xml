<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tankcat</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://tankcat2.com/"/>
  <updated>2017-12-24T03:20:35.312Z</updated>
  <id>http://tankcat2.com/</id>
  
  <author>
    <name>Tankcat</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Algorithm Specialization I-VI QuickSort Algorithm Analysis</title>
    <link href="http://tankcat2.com/2017/12/24/Course1-VI/"/>
    <id>http://tankcat2.com/2017/12/24/Course1-VI/</id>
    <published>2017-12-24T03:20:00.000Z</published>
    <updated>2017-12-24T03:20:35.312Z</updated>
    
    <content type="html"><![CDATA[<p>这一章节的课程是证明随机选择pivot的快速排序算法的其平均运行时间是$O(nlogn)$，证明过程如同算法本身是巧妙的，基于一个在随机算法分析中很有用的“分解原理”。</p><p>首先定义：</p><ol><li>输入数组A的长度为n</li><li>样本空间$\Omega=$快排中所有可能的随机选择，即<strong>一组pivot序列</strong></li><li>随机变量$C(\delta)=$对于一组pivot序列$\delta$，元素比较的总次数</li></ol><p>有一个重要的结论是，快排的运行时间取决于元素比较的次数。可以证明的是，存在一个常数c，对于所有可能的pivot序列，有$RT(\delta)\leq c\cdot C(\delta)$。因此接下来的目标就是证明$E(C)=O(nlogn)$。如果想先通过递归关系理论来探讨$C(\delta)$是比较困难负责的，因此可以利用<strong>分解原理</strong>，将复杂的$C_(\delta)$分解成若干个简单的随机变量之和。</p><p>接下来定义基础构建：这里不能利用Master method，因为在快排中子问题的大小是随机变化的。定义$z_i$是输入数组A中第i小的元素。对于$\delta\in\Omega$，当$i&lt;j$时，定义$X_{ij}=$第i小的元素与第j小的元素的比较次数。根据快排的ChoosePivot子程序中的Partition操作可知，元素的比较操作只会存在于pivot和其他元素之间，的=只有当$z_i和z_j$中有一个是pivot时，比较次数为1，其他情况都为0。因此有$C(\delta)=\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}X_{ij}(\delta)$。接着利用线性期望，可得$E(C)=\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}E(X_{ij})$，其中$E(X_{ij})=0\cdot P(X_{ij}=0)+1\cdot P(X_{ij}=1)$，则$E(C)=\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}P(X_{ij}=1)$。</p><p>下面是求$P(X_{ij}=1)$，即给定pivot序列，则输入数组中第i小与第j小的元素被比较的概率。对于$z_i,z_j$且$i&lt;j$，它们之间还存在其他元素，即有$z_i,z_{i+1},…,z_{j-1},z_{j}$，有一个结论是，如果选择的pivot是$z_i$或者$z_j$，则它们会被比较；反之，如果选择的pivot是$z_i$和$z_j$之间的元素，则它们不会被比较，因为它们会被pivot左右两边各自的递归继续调用。因此，而每个元素被选中为pivot的概率都是$\frac{1}{j-i+1}$，因此$P(X_{ij}=1)=\frac{2}{j-i+1}$。因此$E(C)=\sum_{i=1}^{n-1}\sum_{j=1}^{n}\frac{2}{j-i+1}$。</p><p>最后问题就归结为证明$\sum_{i=1}^{n-1}\sum_{j=1}^{n}\frac{2}{j-i+1}=O(nlogn)$。先分析$\sum_{j=1}^{n}\frac{2}{j-i+1}=\frac{1}{2}+\frac{1}{3}+…=\sum_{k=2}^n\frac{1}{k}$，根据下图可知，$\sum_{k=2}^n\frac{1}{k}\leq\int_{1}^n\frac{1}{x}dx=lnx|_{1}^n=ln$。因此，$E(C)\leq 2\cdot n\cdot ln n$。</p><a id="more"></a><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/logn.png" alt=""></p><p>ps: 撇开快排的证明，下面总结一下分解原理的通常步骤。</p><ol><li>确定好真正关心的随机变量Y</li><li>将复杂的随机变量Y分解为若干个简单的随机变量indicator(仅仅取值0或者1)之和，即$Y=\sum_{l=1}^mX_e$</li><li>最后利用线性期望来求得$E(Y)=\sum_{l=1}^mP(X_e=1)$</li></ol>]]></content>
    
    <summary type="html">
    
      Coursera上学习“Algorithm专项课程”中的第一课程，主要涉及渐近表示法(大O表示法)，排序与搜索算法，分治算法(主项定理、整数与矩阵乘法、最近点对问题)，以及随机算法(快速排序、最小割集收缩算法)。这是Course I中介绍QuickSort Algorithm证明分析的笔记。
    
    </summary>
    
      <category term="Techniques" scheme="http://tankcat2.com/categories/Techniques/"/>
    
    
      <category term="Algorithm Specialization" scheme="http://tankcat2.com/tags/Algorithm-Specialization/"/>
    
      <category term="Course I" scheme="http://tankcat2.com/tags/Course-I/"/>
    
  </entry>
  
  <entry>
    <title>十二月的第四周</title>
    <link href="http://tankcat2.com/2017/12/23/diary1223/"/>
    <id>http://tankcat2.com/2017/12/23/diary1223/</id>
    <published>2017-12-23T02:30:00.000Z</published>
    <updated>2017-12-24T03:21:30.896Z</updated>
    
    <content type="html"><![CDATA[<p>上周周末去了对象老家，回到上海的时候已经是晚上七八点了。从黄桥坐车到南京，在换成高铁回上海，几乎是坐了一下午的车，很累，索性就略过了上周的周记。</p><h3 id="工作日的日常"><a href="#工作日的日常" class="headerlink" title="工作日的日常"></a>工作日的日常</h3><p>周一上午9点半和振杰老师、Tom电话会议，讲了一下survey的进展。还是老样子，很多概念我还是糊里糊涂的，没讲明白，所以本周的工作除了修改demo论文之外就是继续把之前没读懂的paper再翻出来仔细看看。上周遗留的不少Algorithm Specialization的课程，周一周二花时间补上了。现在已经能做到跟得上英文字幕就能看懂在讲什么，暂停的次数也渐渐减少。总结了一点，看视频的时候不用急着把知识点立刻完完整整地记录下来，可以直接拿张草稿纸，记录一些关键词就可以，等整个视频学习完后再对照slide、或者根据字幕定位到没看懂的视频部分来整理最终的笔记，这样效率会更高一点。本周的课程学习得差不多了，提前把作业写完，这次编码作业是写快排并统计compare次数，第一次真正理解了快排的思想，没有借助任何网上别人写好的代码。由于到了订阅的免费体验截至日期，不续费后面的课程只能看视频，不能获取作业，考虑到作业本身是对学习的巩固，我还是咬咬牙续费了。还真不便宜，一个月40多刀。或者这能push我每周加快学习的进度吧。关于Demo论文的修改，周五的版本算是差不多接近终稿了。提交的时候出现了一个乌龙，官方给定的demo track 提交链接登陆进去居然没有提交按钮，空荡荡的一个页面，发邮件问了chair，周五下午其中一个chair给了回复，说他刚旅行回来周末来看看这个问题=。。=看了chair邮箱的名称，原来也是个中国人，哎，又是两个中国人还英文交流。周六周日继续看paper和survey。</p><h3 id="实验室外的闲暇时光"><a href="#实验室外的闲暇时光" class="headerlink" title="实验室外的闲暇时光"></a>实验室外的闲暇时光</h3><p>上周就周一跑步了3公里，然后一直拖到这周周三，被减肥群里的妹子说得我很羞愧，于是傍晚时刻换上装备慢跑了4公里。之前收藏的一个瘦肚子5分钟干货视频，终于让它不再尘封。9组动作虽然各自只有30秒，其实还蛮累的，周三开始每天做两次，头两天腹部酸痛，不知道是不是心里效应，感觉肚子上的肉紧致了一些。上周周末在对象老家吃得比较嗨，所以本周头三天控制了一下，但是临近周末，抑制不住想吃美食的欲望，尤其是三文鱼刺身，周五晚上发现大悦城新开始了一家座头市居酒屋，于是下午五点就步行过去吃了。我到的时候店里没有顾客，点了三文鱼刺身、特色沙拉、串烤猪颈肉和猪骨汤拉面，总共100出头，量还是很足的，口味也不错。隔壁的星巴克也还开着，就去买了中杯半糖的太妃榛果。在出门之前缓存了一半《追龙》，可能是喝了咖啡，晚上12点多还不困，索性把追龙剩余部分继续看掉。王晶也不是总拍烂片嘛，这部港匪片还是可以的，只是跛豪的老婆孩子和兄弟们都接连为了他死去，有点于心不忍啊。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>这周就记录这些吧，写周日的习惯还是要继续保持，不能浑浑噩噩地过日子，总得用文字或者照片记录点什么，等老了回头翻看这些文字，说不定会心一笑呢。2017年就剩下最后一周了，2018年的第一天是我跟对象一周年纪念日，好期待他会怎么安排那一天呀。先提前给自己列几个新年新计划吧：2018年要每两周至少一本书，少去电影院看快餐电影，好好利用腾讯会员，多刷一点豆瓣高分；继续健身，体脂降低到21%，体重减到47.5kg。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      一周的流水线，只是记录，文笔很差。
    
    </summary>
    
      <category term="Jottings" scheme="http://tankcat2.com/categories/Jottings/"/>
    
    
      <category term="周记" scheme="http://tankcat2.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="自省" scheme="http://tankcat2.com/tags/%E8%87%AA%E7%9C%81/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm Specialization I-VII Probability Review</title>
    <link href="http://tankcat2.com/2017/12/22/Course1-VII/"/>
    <id>http://tankcat2.com/2017/12/22/Course1-VII/</id>
    <published>2017-12-22T14:10:00.000Z</published>
    <updated>2017-12-24T03:15:54.564Z</updated>
    
    <content type="html"><![CDATA[<p>这一章节的课程分了两个视频，首先回顾了离散概率、样本空间、事件、随机变量、期望值的概念，其次主要介绍条件概率与独立事件。学习这些是为后续随机压缩算法的分析做准备。</p><h2 id="Sample-spaces-样本空间"><a href="#Sample-spaces-样本空间" class="headerlink" title="Sample spaces / 样本空间"></a>Sample spaces / 样本空间</h2><p>样本空间$\Omega$表示所有可能发生的结果，在算法设计中，$\Omega$通常是有限的。对于样本空间中的每一个结果i，其发生概率$p(i)\geq0$，且所有结果发生概率之和$\sum_{i\in\Omega}p(i)=1$。</p><p>样本空间举例：</p><ol><li>掷两个六面骰子，则$\Omega=\{(1,1),(1,2),…,(6,5),(6,6)\}$，共有36个结果</li><li>一次QuickSort调用中的pivot选择，$\Omega=\{1,2,…,n\},p(i)=\frac{1}{n}$</li></ol><h2 id="Events-事件"><a href="#Events-事件" class="headerlink" title="Events / 事件"></a>Events / 事件</h2><p>事件$E$表示一个样本空间的子集，即$E\in\Omega$，事件E发生的概率是其拥有所有结果的发生概率之和，即$P(E)=\sum_{i\in E}p(i)$。</p><p>事件举例：</p><ol><li><p>掷两个六面骰子，则点数之和为7的事件概率是多少？</p><p>枚举可知$E=\{(1,6),(6,1),(2,5),(5,2),(3,4),(4,3)\}$，则$P(E)=\frac{6}{36}=\frac{1}{6}$</p></li><li><p>一次QuickSort调用ChoosePivot，则将输入数组划分成比25-75更好的划分事件概率是多少？</p><p>可知E={第$(\frac{n}{4}+1)^{th}$小元素，…，第$(\frac{3n}{4})^{th}$小元素}，则$P(E)=\frac{1}{2}$</p></li></ol><h2 id="Random-Variables-随机变量"><a href="#Random-Variables-随机变量" class="headerlink" title="Random Variables / 随机变量"></a>Random Variables / 随机变量</h2><p>随机变量$X$是一个实数函数，即$X:\Omega\rightarrow R$</p><h2 id="Expectation-期望值"><a href="#Expectation-期望值" class="headerlink" title="Expectation / 期望值"></a>Expectation / 期望值</h2><p>期望就是随机变量$X$的平均值，使用$E(X)$表示，有$E(X)=\sum_{i\in\Omega}X(i)\cdot p(i)$</p><h2 id="Linearity-of-Expectation-线性期望"><a href="#Linearity-of-Expectation-线性期望" class="headerlink" title="Linearity of Expectation / 线性期望"></a>Linearity of Expectation / 线性期望</h2><p>令$X_1,X_2,…,X_n$是定义在样本空间$\Omega$上的一组随机变量，则有$E[\sum_{j=1}^{n}X_j]=\sum_{j=1}^{n}E[X_j]$。这里对随机变量没有要求，即它们未必是独立的，这个结论在任何情况下都成立。</p><p>线性期望举例：掷骰子，令$X_1$表示第一个骰子的点数，$X_2$表示第二个骰子的点数，则两个骰子的点数之和的期望$E(X_1+X_2)=E(X_1)+E(X_2)$,而$E(X_1)=E(X_2)=\frac{1}{6}\cdot(1+2+3+4+5+6)=3.5$，则$E(X_1+X_2)=7$</p><a id="more"></a><p>线性期望证明：$\sum_{j=1}^{n}E[X_j]=\sum_{j=1}^n\sum_{i\in\Omega}X_j(i)p(i)=\sum_{i\in\Omega}\sum_{j=1}^nX_j(i)p(i)=\sum_{i\in\Omega}p(i)\sum_{j=1}^{n}X_j(i)=E[\sum_{j=1}^nX_j]$，如下图所示，每个单元的求和就是结果，区别就在于$\sum_{j=1}^n\sum_{i\in\Omega}X_j(i)p(i)$是先求每列的值，再把每列的值相加；而$\sum_{i\in\Omega}\sum_{j=1}^nX_j(i)p(i)$是先求每行的值，再把每行的值相加。</p><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/linearity_expectation.png" alt=""></p><h2 id="Load-balancing-负载均衡示例"><a href="#Load-balancing-负载均衡示例" class="headerlink" title="Load balancing / 负载均衡示例"></a>Load balancing / 负载均衡示例</h2><p>通过一个例子把前面所有的知识点串联起来。</p><p>场景：将n个进程分配到n个服务器上。</p><p>解决方案：将每个进程随机指派到一个服务器上。</p><p>问题：一个服务器被分配到进程数量的期望？</p><p>样本空间$\Omega$是所有$n^2$种分配可能情况，每一种发生的概率相同。</p><p>令$Y$为指派到第一台服务器上的进程的总数量，目标是求$E(Y)$。</p><p>令$X_j=\begin{cases}1 &amp; 如果第j个进程指派给该服务器\ 0&amp;其他情况\end{cases}$</p><p>则有$Y=\sum_{j=1}^nX_j$，利用线性期望可得$E(Y)=E(\sum_{j=1}^nX_j)=\sum_{j=1}^nE(X_j)=\sum_{j=1}^nP(X_j=0)\cdot 0+P(X_j=1)\cdot 1=\sum_{j=1}^n\frac{1}{n}=1$</p><h2 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h2><p>令$X,Y\in\Omega$为两个事件，它们的关系如下图所示，则在已知事件Y发生概率P(Y)的情况下，事件X的发生概率$P(X|Y)=\frac{P(X\cap Y)}{P(Y)}$。</p><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/conditional_probability.png" alt=""></p><p>条件概率示例：掷两个六面骰子，在给定两个骰子点数之和为7的前提下，至少有一个骰子的点数为1的概率是多大？设事件E为“至少有一个骰子的点数为1”，事件Y为“两个骰子的点数之和为7”，则有$Y=\{(1,6),(6,1),(2,5),(5,2),(3,4),(4,3)\}$,$X\cap Y=\{(1,6),(6,1)\}$，因此$P(X|Y)=\frac{P(X\cap Y)}{P(Y)}=\frac{2/36}{6/36}=\frac{1}{3}$.</p><h2 id="独立与独立的随机变量"><a href="#独立与独立的随机变量" class="headerlink" title="独立与独立的随机变量"></a>独立与独立的随机变量</h2><p>令$X,Y\in\Omega$为两个事件，则当且仅当$P(X\cap Y)=P(X)\cdot P(Y)$时事件X与Y是相互独立的。相互独立这个概念是比较微妙的，有的时候你觉得两个事件是相互独立的，但是直觉未必是正确的！</p><p>随机变量的独立定义是：假设A和B是定义在样本空间$\Omega$上的两个随机变量，当且仅当对于所有$A=a$和$B=b$都有$P(A=a \cap B=b)=P(A=a)\cdot P(B=b)$时，A与B是相互独立的。关于相互独立的两个随机变量有一个结论，即$E(AB)=E(A)\cdot E(B)$，证明如下：</p><p>$E(AB)=\sum_{a,b}(a\cdot b)\cdot P(A=a \cap B=b)=\sum_{a,b}(a\cdot b)\cdot P(A=a)\cdot P(B=b)=(\sum_{a}a\cdot P(A=a))\cdot (\sum_{b}b\cdot P(B=b)=E(A)\cdot E(B)$.</p><p>独立的随机变量示例：令$X_1,X_2\in \{0,1\},X_3=X_1 xor X_2$,则样本空间$\Omega=\{000,101,011,110\}$，每一个发生结果等概率。则事件$X_1$与$X_3$显然是相互独立的随机变量，而$X_1\cdot X_3$与$X_2$不是，因为$E(X_1X_2X_3)=0$,而$E(X_1X_3)\cdot E(X_2)=E(X_1)\cdot E(X_3)\cdot E(X_2)=\frac{1}{8}$。</p>]]></content>
    
    <summary type="html">
    
      Coursera上学习“Algorithm专项课程”中的第一课程，主要涉及渐近表示法(大O表示法)，排序与搜索算法，分治算法(主项定理、整数与矩阵乘法、最近点对问题)，以及随机算法(快速排序、最小割集收缩算法)。这是Course I中回顾概率论知识点的笔记。
    
    </summary>
    
      <category term="Techniques" scheme="http://tankcat2.com/categories/Techniques/"/>
    
    
      <category term="Algorithm Specialization" scheme="http://tankcat2.com/tags/Algorithm-Specialization/"/>
    
      <category term="Course I" scheme="http://tankcat2.com/tags/Course-I/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm Specialization I-V QuickSort Algorithm</title>
    <link href="http://tankcat2.com/2017/12/20/Course1-V/"/>
    <id>http://tankcat2.com/2017/12/20/Course1-V/</id>
    <published>2017-12-20T14:50:00.000Z</published>
    <updated>2017-12-23T04:35:32.877Z</updated>
    
    <content type="html"><![CDATA[<p>这一章节的课程主要是关于快速排序，它是一个经典的随机算法，会介绍伪码、如何以线性的时间以及最小的额外空间来围绕一个pivot对一个数组进行划分、不同pivot的选择对性能的影响以及阐述算法是如何运行的。</p><h2 id="Quick-Sort-overview-快速排序简介"><a href="#Quick-Sort-overview-快速排序简介" class="headerlink" title="Quick Sort overview / 快速排序简介"></a>Quick Sort overview / 快速排序简介</h2><p>QuickSort快速排序是一个很经典、著名的算法，很实用，是由图灵奖获得者Hoare提出的，在现实应用中经常比Merge Sort更加高效。它是一个很巧妙的算法，它的代码言简意赅。可以通过数学分析来解释为什么Quick Sort可以运行得很快，它的平均运行时间是$O(nlogn)$。和Merge Sort不同的是，QuickSort直接在原始数组的位置上重复地进行swap操作，只需要很少的额外空间。</p><p>首先回顾一下排序问题，假设不包含重复数字：</p><ul><li>输入是包含n个无序数字的数组</li><li>输出是包含n个递增有序数字的数组</li></ul><p>QuickSort的关键子程序是“围绕一个pivot对数组进行划分”，即从数组中选择一个数字作为pivot(后面会介绍选择哪一个数字作为pivot)，然后把所有小于pivot的数字放置在pivot左边，所有大于pivot的数字放置在pivot右边，这样就把数组划分为两个bucket。如下图所示，选择第一个数字3作为pivot，重新排序数组，使得所有小于3的数字位于左边，所有大于3的数字位于右边。在这一阶段，不关注bucket内部是否是有序的。所以划分操作的直接目的是<strong>把pivot放置在正确的位置上</strong>，最终目的是排序。</p><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/pivot.png" alt=""></p><p>关于划分操作，有两个结论：</p><ol><li>这个操作的运行时间是线性的$O(n)$，且不需要额外的空间</li><li>这个操作减少了problem size，能够继续使用分治算法来进行排序</li></ol><p>最后介绍Quick Sort的整体处理流程，输入数组A以及长度n：</p><ol><li><p>如果数组A只包含一个元素，则直接返回</p></li><li><p>调用ChoosePivot(A，n)选择pivot p</p></li><li><p>以p为分界点将A进行划分，如下图所示，左半部分的元素都小于p，右半部分的元素都大于p</p><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/partition.png" alt=""></p></li><li><p>递归对左半部分子数组进行QuickSort</p></li><li><p>递归对右半部分子数组进行QuickSort</p></li></ol><a id="more"></a><h2 id="Partitioning-around-a-pivot-以pivot为分界点划分"><a href="#Partitioning-around-a-pivot-以pivot为分界点划分" class="headerlink" title="Partitioning around a pivot / 以pivot为分界点划分"></a>Partitioning around a pivot / 以pivot为分界点划分</h2><p>这一节课程主要讲Paritioning around a pivot的具体实现，这里不考虑pivot是如何挑选的，为了方便，选择数组的第一个元素为pivot。pivot左边或者右边的元素暂时不需要有序，只要求左边的元素均比pivot小，右边的元素均比pivot大。</p><p>关于这个Partition操作，上一节课程介绍了两个结论，其中一个是说这个操作的运行时间是线性的O(n)，且操作是in-place的，不需要额外的空间。假设现在允许使用额外的线性空间，就能够事先分配一个长度为n的数组B，接着直接扫描输入数组A，把比pivot小的元素从B头部往后插入，把比pivot大的元素从B尾部往前插入，如下图所示。</p><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/non-in-place.png" alt=""></p><p>In-place的Partition实现：假设pivot是输入数组的第一个元素(如果不是，可以通过将pivot和第一个元素交换一下，就能继续使用下面讲的方法)。由于这个Partition操作是对输入数组进行一次扫描，所以在这个过程中，需要追踪已经扫描到的数据和未扫描到的数据的分界，如下图所示。已经扫描到的数据表示已经进行了Parititon，且该部分数据以pivot为分界点进行了划分。</p><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/high-level-idea.png" alt=""></p><p>下面通过一个具体的示例来更直观地介绍Paritition处理流程。首先维护两个index，j表示已经扫描到和未扫描到的分界，i表示已经扫描到中小于pivot与大于pivot的分界。初始时i和j都指向pivot后一个元素。</p><ul><li><p>当前元素为8，大于pivot，单独构成partitioned部分，j后移，i不变</p></li><li><p>当前元素为2，小于pivot，交换i与j当前指向的元素，即交换8和2，j与i同时后移，2和8构成partitioned，剩余的为unpartitioned</p></li><li><p>当前元素为5，大于pivot，2、8和5构成partitioned，剩余的为unpartitioned，j后移，i不变</p></li><li><p>当前元素为1，小于pivot，交换当前i与j指向的元素，即交换8和1，j和i同时后移，2、1、5和8构成partitioned，剩余的为unpartitioned</p></li><li><p>…(4、7和6均同8、5的处理相同)</p></li><li><p>最后，交换pivot和i-1指向的元素</p><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/partition_example.png" alt=""></p></li></ul><p>最后给出Partition操作的伪码，输入数组为A，l和r分别是A的首尾边界：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Partiton(A, l, r)</span><br><span class="line">  p = A[l]</span><br><span class="line">  i = l + <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> j = l + <span class="number">1</span> to r </span><br><span class="line">  <span class="keyword">if</span> A[j] &lt; p</span><br><span class="line">    swap A[j] <span class="keyword">and</span> A[i]</span><br><span class="line">      i++</span><br><span class="line">  swap A[i<span class="number">-1</span>] <span class="keyword">and</span> A[l]</span><br></pre></td></tr></table></figure><p>分析一下其运行时间，由于$n=r-l+1$是输入数组的长度，且每个元素的工作量是O(1)，并且处理是in-place的，所以总的运行时间是O(n)线性的。</p><h2 id="Correctness-of-QuickSort-快速排序的正确性"><a href="#Correctness-of-QuickSort-快速排序的正确性" class="headerlink" title="Correctness of QuickSort / 快速排序的正确性"></a>Correctness of QuickSort / 快速排序的正确性</h2><p>这一节课程的目的是证明QuickSort算法是正确的。虽然遇到一个问题，能够设计出一个分治算法来解决它比较困难，但是我们也总希望自己能理解为什么它这么做是正确的，有的时候需要证明自己的直觉。这里以QuickSort为例来证明，首先pivot的选择只会影响算法的性能，不会影响想法的正确性。利用归纳假设法来证明。归纳假设里的P(n)在QuickSort中是指”对于任意长度n的输入数组，QuickSort总能正确地对其进行排序”。归纳假设证明分两步：</p><ol><li><p>当n=1时，输入数组只有一个元素，显然已经是有序的，因此QuickSort是正确的</p></li><li><p>当$n\geq 2$时，假设$P(k)$对于所有$k&lt;n$是成立的，则要证明$P(n)$也是正确的。回顾QuickSort首次围绕pivot p将输入数组A划分成两部分，如下图所示。划分操作完之后，pivot就位于最终有序的位置上了，令$k_1$和$k_2$分为是两个划分子数组的长度，有了”P(k)对于所有k&lt;n都成立”的假设，则递归调用后，pivot左边的子数组是有序的，pivot右边的子数组也是有序的，加上pivot比左半子数组所有元素都大，且比右半子数组所有元素都小，因此最终的数组时有序的，即证明了P(n)成立。</p><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/partition.png" alt=""></p></li></ol><h2 id="Choose-a-good-pivot-pivot的选择"><a href="#Choose-a-good-pivot-pivot的选择" class="headerlink" title="Choose a good pivot / pivot的选择"></a>Choose a good pivot / pivot的选择</h2><p>QuickSort的第一步是选择输入数组的pivot，并以此为分界点进行划分。QuickSort的运行时间取决于所选pivot的质量。质量较高的pivot意味着以此为分界点可以将输入数组划分成较为均等的两个子数组；而质量较低的pivot意味着以此为分界点会将输入数组划分成两个极不均衡的子数组。举个例子，如果输入数组是有序的，QuickSort总是选择第一个元素为pivot，则运行时间是$\Theta(n^2)$。如下图所示，由于输入数组本身是有序的，所以以第一个元素为分界点进行划分，左半数组大小为0，右半数组大小为n-1；以此类推，每次Partition的工作量是至少输入数组的长度，则总工作量$\geq n+(n-1)+(n-2)+…+1=\Theta(n^2)$，因此这种情况下QuickSort性能是最差的。</p><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/worst_quicksort.png" alt=""></p><p>最好的情况是每次选择的pivot是输入数组的中位数，这样每次将数组划分成均等的子数组，这种情况下，运行时间$T(n)\leq 2\cdot T(\frac{1}{2}n)+\Theta(n)$，利用Master Method可知$T(n)=\Theta(nlogn)$。</p><p>问题的关键是，不可能每次选中的pivot都是中位数。则解决方案是随机选择一个元素作为pivot。我们希望的是随机选择的pivot<strong>足够好</strong>。Randomization是算法设计的一个成功突破，利用随机，可以让算法更加巧妙，更加简单，更易于编码实现，性能更快，或者说，不使用随机可能很难简单地设计出来一个算法出来。后续课程会给出数学分析，证明关于QuickSort的一个定理：对于每次长度为n的输入数组，随机选取pivot，QuickSort的平均运行时间是$O(nlogn)$。这个定理适用于任何输入，没有对输入数据的假设；Average是针对算法的随机决策而言。</p>]]></content>
    
    <summary type="html">
    
      Coursera上学习“Algorithm专项课程”中的第一课程，主要涉及渐近表示法(大O表示法)，排序与搜索算法，分治算法(主项定理、整数与矩阵乘法、最近点对问题)，以及随机算法(快速排序、最小割集收缩算法)。这是Course I中介绍QuickSort Algorithm的笔记。
    
    </summary>
    
      <category term="Techniques" scheme="http://tankcat2.com/categories/Techniques/"/>
    
    
      <category term="Algorithm Specialization" scheme="http://tankcat2.com/tags/Algorithm-Specialization/"/>
    
      <category term="Course I" scheme="http://tankcat2.com/tags/Course-I/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm Specialization I-IV The Master Method</title>
    <link href="http://tankcat2.com/2017/12/19/Course1-IV/"/>
    <id>http://tankcat2.com/2017/12/19/Course1-IV/</id>
    <published>2017-12-19T00:29:00.000Z</published>
    <updated>2017-12-23T04:36:19.770Z</updated>
    
    <content type="html"><![CDATA[<p>这一章节的课程主要介绍Master method，一种通用的分析分治算法运行时间的数学工具，先给出motivation，再介绍形式化描述，接着讲解6个示例，最后讨论Master method的证明。</p><h2 id="Motivation-动机"><a href="#Motivation-动机" class="headerlink" title="Motivation / 动机"></a>Motivation / 动机</h2><p>潜在有用的算法通常需要数学分析来评估其性能，回顾小学时期的整数相乘算法使用$\Theta(n^2)$的运行时间来计算两个n位整数的乘积$x\times y$。递归算法是将x分解为$x=10^{\frac{1}{2}n}a+b$，将y分解为$y=10^{\frac{1}{2}n}c+d$，则$x\times y = 10^nac+10^{\frac{1}{2}n}(ad+bc)+bd$。即递归计算$ac,ad,bc,bd$的乘积即可。令T(n)表示计算两个n位整数乘积过程中操作的数量，基线条件是$T(1)\leq $常数，对于$n\geq 1$，有$T(n)\leq 4T(\frac{1}{2}n)+O(n)$。此外，一个更好的递归算法是减少一次递归调用，只计算ac,bd与(a+b)(c+d)，而ad+bc=(a+b)(c+d)-ac-bd。这样，对于$n\geq1$，有$T(n)\leq3T(\frac{1}{2}n)+O(n)$。</p><h2 id="Formal-statement-形式化叙述"><a href="#Formal-statement-形式化叙述" class="headerlink" title="Formal statement / 形式化叙述"></a>Formal statement / 形式化叙述</h2><p>这一节课程视频主要介绍Master method的形式化叙述，可以理解为解决递归问题的一个black box，有一个前提假设，即所有的子问题拥有相同的size。其形式化表述如下：</p><ol><li><p>首先是基线条件Base Case：当n足够小时，T(n)为常数</p></li><li><p>通常递归调用的情况下，对于较大的n，假设有$T(n)\leq a\cdot T(\frac{n}{b})+O(n^d)$，其中a、b、d都是常数，与n大小无关</p><ul><li>a是递归调用的次数($\geq 1$)</li><li>b是输入大小收缩系数($&gt; 1$)</li><li>d是“合并阶段”运行时间的指数($\geq 0$)</li></ul><p>则有$ T(n)=\begin{cases}O(n^dlogn) &amp;a = b^d \ O(n^d) &amp; a &lt; b^d \\O(n^{log_ba}) &amp; a &gt; b^d  \end{cases}​$</p><p>需要注意的是，当$a=b^d$时，big-O里面的log基数省略没写，这是因为基数具体为哪个值并不重要，不同基数带来的变化是常量级别的；而当$a&gt;b^d$时，由于log是在指数的位置，所以基数是哪个值就很重要了，不能忽略。</p></li></ol><h2 id="Examples-示例"><a href="#Examples-示例" class="headerlink" title="Examples / 示例"></a>Examples / 示例</h2><p>这一节课程主要是利用6个具体示例来说明Master method。</p><h3 id="示例1：Merge-sort"><a href="#示例1：Merge-sort" class="headerlink" title="示例1：Merge sort"></a>示例1：Merge sort</h3><p>首先确定a、b、d的数值：</p><ul><li>a=2</li><li>b=2</li><li>d=1</li></ul><p>满足$a=b^d$，因此Merge sort的$T(n)=O(n^dlogn)=O(nlogn)$</p><h3 id="示例2：有序数组的二分查找"><a href="#示例2：有序数组的二分查找" class="headerlink" title="示例2：有序数组的二分查找"></a>示例2：有序数组的二分查找</h3><p>首先确定a、b、d的数值：</p><ul><li>a=1</li><li>b=2</li><li>d=0</li></ul><p>和Merge sort不同，只需要将要查找的数与中间元素比较，如果小于中间元素，则递归调用左半部分，否则调用右半部分，所以a的值为1；递归之外的操作就是元素的比较，因此d的值为0。由于满足$a=b^d$，因此有序数组的二分查找的$T(n)=O(n^dlogn)=O(logn)$</p><h3 id="示例3：整数相乘的递归算法I"><a href="#示例3：整数相乘的递归算法I" class="headerlink" title="示例3：整数相乘的递归算法I"></a>示例3：整数相乘的递归算法I</h3><p>首先确定a、b、d的数值：</p><ul><li>a=4</li><li>b=2</li><li>d=1</li></ul><p>整数相乘的基础递归算法总共有4次调用，所以a=4；每一次调用的整数位数是原来的一半，所以b=2；递归调用之外的加操作是线性的，所以d=1。由于满足$a&gt;b^d$，因此整数相乘的基础递归算法的$T(n)=O(n^{log_ba})=O(n^2)$</p><h3 id="示例4：整数相乘的递归算法II"><a href="#示例4：整数相乘的递归算法II" class="headerlink" title="示例4：整数相乘的递归算法II"></a>示例4：整数相乘的递归算法II</h3><p>首先确定a、b、d的数值：</p><ul><li>a=3</li><li>b=2</li><li>d=1</li></ul><p>整数相乘的改进递归算法总共有3次调用，所以a=3；每一次调用的整数位数是原来的一半，所以b=2；递归调用之外的加操作是线性的，所以d=1。由于满足$a&gt;b^d$，因此整数相乘的基础递归算法的$T(n)=O(n^{log_ba})=O(n^{log_23})=O(n^{1.59})$</p><h3 id="示例5：Strassen矩阵乘法"><a href="#示例5：Strassen矩阵乘法" class="headerlink" title="示例5：Strassen矩阵乘法"></a>示例5：Strassen矩阵乘法</h3><p>首先确定a、b、d的数值：</p><ul><li>a=7</li><li>b=2</li><li>d=2</li></ul><p>Strassen矩阵乘法是递归调用7次$P_1$~$P_7$加减操作，所以a=7；$P_1$~$P_7$子矩阵的规模是原始矩阵的一半，所以b=2；递归调用之外的加操作规模是子矩阵的大小，因此d=1。由于满足$a&gt;b^d$，因此整数相乘的基础递归算法的$T(n)=O(n^{log_ba})=O(n^{log_27})=O(n^{2.81})$</p><h3 id="示例6：Fictitious-recurrence-for-a-lt-b-d"><a href="#示例6：Fictitious-recurrence-for-a-lt-b-d" class="headerlink" title="示例6：Fictitious recurrence for $a&lt;b^d$"></a>示例6：Fictitious recurrence for $a&lt;b^d$</h3><p>假设a、b、d的数值：</p><ul><li>a=2</li><li>b=2</li><li>d=2</li></ul><p>由于满足$a&lt;b^d$，因此$T(n)=O(n^d)=O(n^2)$</p><a id="more"></a><h2 id="Proof-I-证明-I"><a href="#Proof-I-证明-I" class="headerlink" title="Proof I / 证明 I"></a>Proof I / 证明 I</h2><p>这一节课程主要是介绍Master method的证明。这个证明是概念性层面上的，理解Master method的三种case的概念性意义以及对于的recursion tree是有很大帮助的。如果理解了，就不用对Master method的三种case进行死记硬背。</p><p>证明的前提假设如下：</p><ol><li>$T(1)\leq c$</li><li>$T(n)\leq a\cdot T(\frac{n}{b})+c\cdot n^d$</li><li>n是b的幂次方</li></ol><p>按照Merge sort讲解recursion tree的思路，在第j层，有$a^j$次方个子问题，且每个子问题的输入规模是$\frac{n}{b^j}$。层数j的取值范围是[0,1,…,$log_bn$]。分析第j层的总工作量为$\leq a^j\cdot c\cdot [\frac{n}{b^j}]^d=c\cdot n^d\cdot (\frac{a}{b^d})^j$，其中$(\frac{n}{b^j})^d$是第j层每个子问题的总工作量，对公式进行化简整理，使得与j相关、无关的变量分离。对所以层的工作量求和，即$\leq c\cdot n^d\cdot \sum_{j=0}^{log_bn}(\frac{a}{b^d})^j$。后续视频会讲解这个式子与Master method的三种case之间的关联。</p><h2 id="Interpretation-of-the-3-cases-3种情况的演绎"><a href="#Interpretation-of-the-3-cases-3种情况的演绎" class="headerlink" title="Interpretation of the 3 cases / 3种情况的演绎"></a>Interpretation of the 3 cases / 3种情况的演绎</h2><p>上一节课程已经介绍了第j层的工作量上界是$c\cdot n^d\cdot(\frac{a}{b^d})^j$。令a为子问题增生的速率RSP，$b^d$是每个子问题工作量的收缩速率RWS，有下面三种结论：</p><ol><li>如果RSP&lt;RWS，则每一层工作量随着层数j而递减，recursion tree根节点处的工作量更多，起决定性作用，而根节点的输入规模是n，因此$T(n)=O(n^d)$</li><li>如果RSP&gt;RWS，则每一层工作量随着层数j而递增，recursion tree叶子节点处的工作量更多，起决定性作用</li><li>如果RSP=RWS，则每一层的工作量是相同的，而层数规模是$O(logn)$，每一层的工作量为$O(n^d)$，因此$T(n)=O(n^dlogn)$</li></ol><h2 id="Proof-II-证明-II"><a href="#Proof-II-证明-II" class="headerlink" title="Proof II / 证明 II"></a>Proof II / 证明 II</h2><p>前面的两节课程分别分析了recursion tree的工作量(放大聚焦于给定的第j层工作量，然后对所有层的工作量求和)，以及赋予它三种直观语义。这一节课程继续完成Master method的精确证明。</p><p>首先回顾一下总工作量：$\leq c\cdot n^d\cdot \sum_{j=0}^{log_bn}(\frac{a}{b^d})^j \star$</p><ol><li><p>当$a=b^d$时，$\star=c\cdot n^d (log_bn+1)=O(n^dlogn)$</p></li><li><p>在讨论另外两种语义时，先回顾一下等比数列求和，当$r\neq1$时，我们有$1+r+r^2+…+r^k=\frac{r^{k+1}-1}{r-1}$。当$r<1$时，$r^{k+1}$趋近于0，因此和趋近于$\frac{1}{1-r}$是一个常数；当$r>1$时，和$\leq r^k(1+\frac{1}{r-1})$</1$时，$r^{k+1}$趋近于0，因此和趋近于$\frac{1}{1-r}$是一个常数；当$r></p><ul><li>当$a&lt;b^d$，即$r&lt;1$，则$\star=O(n^d)$</li><li>当$a&gt;b^d$，即$r&gt;1$，则$\star=O(n^d\cdot(\frac{a}{b^d})^{log_bn})$，由于$b^{-dlog_bn}=(b^{log_bn})^-d=n^{-d}$，所以$\star=O(n^d\cdot a^{log_bn}\cdot n^{-d})$，而$a^{log_bn}$是recursion tree叶子节点的规模，且$a^{log_bn}=n^{log_ba}$(左右两边同时取对数logb)，所以$\star=O(n^{log_ba})$</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      Coursera上学习“Algorithm专项课程”的第一课程，主要涉及渐近表示法(大O表示法)，排序与搜索算法，分治算法(主项定理、整数与矩阵乘法、最近点对问题)，以及随机算法(快速排序、最小割集收缩算法)。这是Course I中介绍Master method及其证明的笔记。
    
    </summary>
    
      <category term="Techniques" scheme="http://tankcat2.com/categories/Techniques/"/>
    
    
      <category term="Algorithm Specialization" scheme="http://tankcat2.com/tags/Algorithm-Specialization/"/>
    
      <category term="Course I" scheme="http://tankcat2.com/tags/Course-I/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm Specialization I-III Dive and Conquer Algorithms</title>
    <link href="http://tankcat2.com/2017/12/18/Course1-III/"/>
    <id>http://tankcat2.com/2017/12/18/Course1-III/</id>
    <published>2017-12-18T09:05:00.000Z</published>
    <updated>2017-12-23T04:37:45.098Z</updated>
    
    <content type="html"><![CDATA[<p>这一章节的课程围绕Divide and conquer分治算法的思想，讨论三个比较有意思的例子，分别是：</p><ol><li>找出给定数组中的逆序对，这个问题和计算两个排名表的相似度有关，因此又与推荐算法中的协同过滤有关</li><li>矩阵乘法，利用Strassen提出的递归算法</li><li>在给定平面中找出最近点对，三个问题中最具挑战性的一个</li></ol><h2 id="Counting-inversions-I-统计逆序对I"><a href="#Counting-inversions-I-统计逆序对I" class="headerlink" title="Counting inversions I/ 统计逆序对I"></a>Counting inversions I/ 统计逆序对I</h2><p>这节课的视频复习了分治思想的paradigm，即先将大问题分解为小问题，再递归求解小问题，最后合并每个小问题的求解结果。此外，继续给出一个具体的问题：找出一个数组中所有的逆序对。逆序对的定义是：数据对(i,j)，使得$i<j$且$a[i]>A[j]$。给定输入数组[1,3,5,2,4,6]，可以看出其中逆序对为(3,2)，(5,2)和(5,4)。可以通过如右图所示的连线方法来求解逆序对的数量，第一行是有序，第二行是原序，将数字相同的连接起来，则交叉点的数量就是逆序对的个数。有个题外话，为什么要计算逆序对？其实它的应用场景可以是两个排名list的相似度计算，比如协同过滤。</j$且$a[i]></p><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/inversions.png" alt=""></p><p>逆序对求解，这里只讲两种方法，暴力求解与分治求解。</p><ol><li><p>暴力求解：直接嵌套循环，逐个判断，时间复杂度是$O(n^2)$</p></li><li><p>递归求解：先定义inversion，分为三种，如下图所示。求解过程就是先递归对左半数组求解left inversion的数量x，再递归对右半数组求解right inversion的数量y，然后求解split inversion的数量z，最后返回$x+y+z$之和就是最终结果了。这节课视频暂时没有讲解计算split inversion的实现，但是目标是以线性时间的复杂度$O(n)$来实现。</p><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/inversions_type.png" alt=""></p></li></ol><h2 id="Counting-inversions-II-统计逆序-II"><a href="#Counting-inversions-II-统计逆序-II" class="headerlink" title="Counting inversions II/ 统计逆序 II"></a>Counting inversions II/ 统计逆序 II</h2><p>这一节课的视频主要解决上一个视频中遗留下来的问题，即如何统计split inversions。关键点在于利用Merge sort的思路，在递归调用时，除了统计左右半数组的left inversion和right inversion外，还需要顺便对左右半数据进行排序。这就是在递归时多做一点工作来简化split inversion的统计。为什么这么做呢？因为可以发现Merge sort的merge步骤可以自然地用来统计split inversion数量。</p><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/sort_and_count.png" alt=""></p><p>如果左半数组B中的所有元素都小于右半数组C中的元素，那么split inversion的个数就是0。按照下图所示的merge操作，可以总结出一个结论，如果右半数组中的元素y比左半数组中的某个元素x小，则x之后剩余的所有元素都能和y组成逆序对。这是显然的，因为左右半数组前提已经是有序的了。这个统计split inversion的运行时间也是线性的，因为前面的课程已经分析了merge操作是$O(n)$，统计求和本身也是$O(n)$，则$O(n)+O(n)=O(n)$。递归调用和Merge sort一样，则找出数组中的逆序对，这个问题的总运行时间是$O(n\cdot log n)$。</p><a id="more"></a><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/sort_and_count_example.png" alt=""></p><h2 id="Strassen’s-subcubic-matrix-multiplication-algorithm"><a href="#Strassen’s-subcubic-matrix-multiplication-algorithm" class="headerlink" title="Strassen’s subcubic matrix multiplication algorithm"></a>Strassen’s subcubic matrix multiplication algorithm</h2><p>这一节课的视频讲解了利用分治思想来求解矩阵乘法，先定义了问题是什么，然后讲了最naivee的求解方法，接着讲了基础分治算法，最后引出1969年的Strassen矩阵乘积算法。</p><ol><li><p>Naivee：先假设涉及的矩阵维度都是n，$X\cdot Y=Z$，$Z_{i,j}=\sum_{k=1}^{n}X_{i,k}\times Y_{k,j}$，即结果矩阵Z的第i行第j列的元素是矩阵X的第i行与矩阵Y的第j列的点积，如下图所示。求点积的运行时间是$\Theta(n)$，因此利用矩阵乘法的定义求解乘积的运行时间是$\Theta(n^3)$。</p><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/matrix_multiplication.png" alt=""></p></li><li><p>分治求解：思想是将X划分成四个子矩阵ABCD，将Y划分成四个子矩阵EFGH，因此A-H都是$\frac{1}{2}n\times \frac{1}{2}n$的矩阵。这样，$X\cdot Y=\left\{\begin{matrix}AE+BG&amp; AF+BH\ CE+DG &amp; CF+DH\end{matrix} \right\}$。因此，求解过程可以分为两部：</p><ul><li>Step-1，递归计算出上面8个子矩阵乘积</li><li>Step-2，求和，这一步的运行时间为$\Theta(n^2)$</li></ul><p>实际上，这个算法的运行时间仍然是$\Theta(n^3)$，但是这不是坏事，回顾之前利用分治思想计算整数乘积，其中有一个步骤是减少一次递归调用。按照这个想法，引出下面要讲的Strassen算法。</p></li><li><p>Strassen求解：这是一个经典的算法，1969年提出的，它只递归求解7个子矩阵乘积，虽然只少了一个，但是运行时间却是sub-cubic的。求解过程和分治求解一致，稍微不同的就是step-1只求解7个，step-2除了addition还有一部分substraction操作。那么，7个子矩阵乘积是什么？利用$P_1-P_7$表示如下。</p><ul><li>$P_1=A(F-H)$</li><li>$P_2=(A+B)H$</li><li>$P_3=(C+D)E$</li><li>$P_4=D(C+E)$</li><li>$P_5=(A+D)(E+H)$</li><li>$P_6=(B-D)(G+H)$</li><li>$P_7=(A-C)(E+F)$</li></ul><p>则利用下面的方法可以得出$X\cdot Y=\left\{\begin{matrix}AE+BG&amp; AF+BH\ CE+DG &amp; CF+DH\end{matrix} \right\}=\left\{\begin{matrix}P_5+P_4-P_2+P_6 &amp; P_1+P_2\ P_3+P_4 &amp; P_1+P_5-P_3-P_2\end{matrix}\right\}$</p><p>关于后面的公式如何得到的，Strassen是如何想到这个方法的，以及它的时间复杂度分析，后续课程将给出！</p></li></ol><h2 id="Closest-pair-I-最近点对问题-I"><a href="#Closest-pair-I-最近点对问题-I" class="headerlink" title="Closest pair I / 最近点对问题 I"></a>Closest pair I / 最近点对问题 I</h2><p>这节课的视频讲解的是最近点对问题，要求找出给定平面上距离最近的两个点。这个问题是分治求解问题的经典算法之一，在其他应用领域也会经常遇到这个问题，比如计算机图形学、机器人等。</p><p>首先是问题的形式化定义：给定一个平面内的若干个点，每个点由其横坐标x与纵坐标y的序列定义。两个点的距离是指欧氏距离(坐标差的平方和开根号)。最近点对问题就是要求找出一对点，使得它们的距离是所有点对中最小的。</p><p>求解的前提假设：不存在ties，即所有端点的x坐标不同，y坐标也不同。没有这个前提假问题也能解决，这里只是为了方便算法的论述。</p><p>沿袭前面的课程统计数组中的inversion求解过程：如果允许平方的运行时间，依旧可以利用暴力求解找出最近点对，即嵌套循环遍历所有不同的点对，计算各自的距离，最终找出最短的。但是，是否存在与counting inversion一样O(nlogn)的求解？在1-dimension的情况下，所有点在一条坐标轴上，可以先排序O(nlogn)，再遍历一遍找出最短的O(n)。</p><p>2-dimension情况下O(nlogn)的high-level求解：</p><ol><li>Preprocessing：对输入点集按照x坐标排序得到点集$P_x$，再根据y坐标排序得到点集$P_y$</li><li>利用分治求解</li></ol><p>2-dimension情况下O(nlogn)的具体求解ClosestPair($P_x，P_y$)：</p><ol><li>根据x坐标把原始点集划分成左右两部分，Q与R，再利用Preprocessing分别得到x与y轴有序的点集$Q_x，Q_y，R_x，R_y$</li><li>递归调用ClosestPair($Q_x，Q_y$)=$(p_1,q_1)$得到左半点集中的最近点对</li><li>递归调用ClosestPair($R_x，R_y$)=$(p_2，q_2)$得到右半点集中的最近点对</li><li>$\delta=min(d(p_1,q_1)，d(p_2,q_2))$</li><li>调用CloestSplitPair($P_x，P_y，\delta$)得到最近点对($p_3，q_3$)，因为两个点可能各自位于Q与R两个点集中，这一步的运行时间是O(n)线性的</li><li>返回$min(d(p_1,q_1)，d(p_2,q_2)，d(p_3,q_3))$</li></ol><p>求解Split closest pair的subroutine要求：O(n)线性运行时间，始终是正确的无论最近点对是否是split closest pair，具体求解过程如下CloestSplitPair($P_x，P_y，\delta​$)：</p><ol><li><p>过滤，修剪掉部分不需要的点，只考虑部分点集，而这部分点集位于一条位于整体点集中部的垂直的宽带中(令$\bar{x}=$原始点集左半部分的最大x坐标，这个操作是O(1)的，因为在Preprocessing中已经对左半点集按照x坐标进行了排序)</p></li><li><p>利用$\delta$来决定垂直宽带的宽度：$2\times \delta$，即以$\bar{x}$为中心先，左右两边各取$\delta$得宽度，如下图所示。这样就忽略到不在这个宽带中得点，接下来的操作只针对位于宽带中的部分点，这部分点的x坐标的上下界为[$\bar{x}-\delta，\bar{x}+\delta$]</p><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/strip.png" alt=""></p></li><li><p>对宽带中的点集按照y坐标排序得到点集$S_y$，可以直接从$P_y$中按照上一步的要求进行提取，因此这一步的操作是O(n)的</p></li><li><p>遍历$S_y$中的点，找出距离小于$\delta$的最短点对，具体过程如下图所示。首先是初始化$best$与$best_pair$，分为用来记录最短点对的距离与最短点对本身；接着是嵌套循环遍历$S_y$，由于内层嵌套的迭代次数是常量7，因此内层的运行时间是O(1)，外层的运行时间是O(n)，总体的运行时间依旧是O(n)。<strong>如果最终找出距离小于$\delta$的点对(p,q)，则p与q在$S_y$中至多相间7个点。</strong>以上的证明在下个视频课程给出。</p><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/iterate_sy.png" alt=""></p></li></ol><h2 id="Closest-pair-II-最近点对问题-II"><a href="#Closest-pair-II-最近点对问题-II" class="headerlink" title="Closest pair II / 最近点对问题 II"></a>Closest pair II / 最近点对问题 II</h2><p>这节视频主要是证明上一节求解ClosestSplitPair中的结论：令$p\in Q, q\in R$是一对split pair，且$d(p,q)&lt;\delta$，则有</p><ol><li>p和q是$S_y$中的两个点</li><li>p与q在$S_y$中的位置最多间隔7个点</li></ol><p>令p的坐标是$(x_1,y_1)$，q的坐标是$(x_2，y_2)$，p来自左半点集Q，q来自右半点集R，且$d(p,q)&lt;\delta$，则有$|x_1-x_2|\leq \delta$，且$|y_1-y_2|\leq \delta$。</p><p>证明第一个结论，就是要证明$x_1,x_2\in [\bar{x}-\delta，\bar{x}+\delta]$。由于p来自左半点集Q，则必有$x_1\leq\bar{x}$，同样q来自右半点集R，则有$x_2\geq\delta$。由于这里与y轴坐标无关，可以借助1-dimension的坐标轴来证明这个。如下图所示，由于$|x_1-x_2|\leq\delta$，所以如果$x_1&lt;\bar{x}-\delta$，则$x_2$肯定必须小于$\bar{x}$，这就矛盾了。同样，如果$x_2&gt;\bar{x}-\delta$，则$x_1$肯定必须大于$\bar{x}$。因此，$x_1$和$x_2$肯定介于$\bar{x}-\delta$与$\bar{x}+\delta$之间。</p><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/claim1.png" alt=""></p><p>证明第二个结论，关键是画出如下图所示的8个box，这些box的横坐标必定包含p和q两个点，介于$\bar{x}-\delta$与$\bar{x}+\delta$之间，box的bottom是p和q两个中较小的y坐标，$|y_1-y_2|\leq \delta$，因此单个盒子的高度是$\frac{1}{2}\delta$。在证明之前，先证明两个辅助定理。</p><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/box.png" alt=""></p><ul><li>辅助定理1：纵坐标位于p与q之间、且属于$S_y$的点必定存在于这8个box之中。首先关于$S_y$的定义，x坐标必须满足介于$\bar{x}-\delta$与$\bar{x}+\delta$之间；其次，p与q的y坐标之差绝对值是小于$\delta$的，这是upper bound。</li><li>辅助定理2：每个box中至多存在一个点。可以用反证法证明，假设a和b两个点存在于同一个盒子中，那个它们必定要么都来自Q，要么都来自R，且它们的距离$d(a,b)\leq \frac{\sqrt{2}}{2}\delta\leq\delta$，这就与原始条件(split pair分别来自Q与R且$\delta$本身已经是Q或者R中最短的距离)相矛盾。</li></ul><p>结合以上两个辅助定理，可以推出包含p和q在内，这8个box中总共至多包含8个点。因此p与q至多相隔7个点。</p>]]></content>
    
    <summary type="html">
    
      Coursera上学习“Algorithm专项课程”的第一课程，主要涉及渐近表示法(大O表示法)，排序与搜索算法，分治算法(主项定理、整数与矩阵乘法、最近点对问题)，以及随机算法(快速排序、最小割集收缩算法)。这是Course I中介绍三个分治算法的笔记。
    
    </summary>
    
      <category term="Techniques" scheme="http://tankcat2.com/categories/Techniques/"/>
    
    
      <category term="Algorithm Specialization" scheme="http://tankcat2.com/tags/Algorithm-Specialization/"/>
    
      <category term="Course I" scheme="http://tankcat2.com/tags/Course-I/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm专项课程—Problem Sets and Programming Assignments</title>
    <link href="http://tankcat2.com/2017/12/12/Assignment1/"/>
    <id>http://tankcat2.com/2017/12/12/Assignment1/</id>
    <published>2017-12-12T11:00:00.000Z</published>
    <updated>2017-12-18T09:09:02.594Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problems-set"><a href="#Problems-set" class="headerlink" title="Problems set"></a>Problems set</h2><ol><li><p>3-way-Merge Sort : Suppose that instead of dividing in half at each step of Merge Sort, you divide into thirds, sort each third, and finally combine all of them using a three-way merge subroutine. What is the overall asymptotic running time of this algorithm? (Hint: Note that the merge step can still be implemented in O(n) time.) </p><ul><li style="list-style: none"><input type="checkbox" checked> $n log (n)$</li><li style="list-style: none"><input type="checkbox"> $n(log(n))^2$</li><li style="list-style: none"><input type="checkbox"> $n^2log(n)$</li><li style="list-style: none"><input type="checkbox"> n</li></ul><p>这道题是问如果Merge sort每次是把一个数组划分成三个部分，那么运行时间复杂度是多少。尽管是每个大问题划分成三个小问题，但是反映到recursion tree上，树的深度依旧是logarithmic，且每一层的merge操作的运行时间依旧是线性的，所以最终的复杂度仍然是$O(nlog(n))$。</p></li><li><p>You are given functions f and g such that $f(n)=O(g(n))$. Is $f(n)\cdot log_2(f(n)^c)=O(g(n)\cdot log_2(g(n))) $? (Here c is some positive constant.) You should assume that f and g are nondecreasing and always bigger than 1.</p><ul><li style="list-style: none"><input type="checkbox" checked> True</li><li style="list-style: none"><input type="checkbox"> False</li><li style="list-style: none"><input type="checkbox"> Sometimes yes, sometimes no, depending on the constant $c$</li><li style="list-style: none"><input type="checkbox"> Sometimes yes, sometimes no, depending on the function $f$ and $g$</li></ul><p>这道题是问如果函数$f$与$g$满足$f(n)=O(g(n))$，那么$f(n)\cdot log_2(f(n)^c)=O(g(n)\cdot log_2(g(n))) $是否成立。根据条件可知，存在$c_1，n_0$使得当$n\geq n_0$时有$f(n)\leq c_1\cdot g(n)$。假设所问结论成立，则存在$c_2，n_0$使得当$n\geq n_0$时有$f(n)\cdot log_2(f(n)^c)=O(g(n)\cdot log_2(g(n)))$，即$f(n)\cdot log_2(f(n)^c)=c_2\cdot g(n)\cdot log_2(g(n))$，化简规约一下，$c\cdot f(n)\cdot log_2(f(n))=c_2\cdot g(n)\cdot log_2(g(n))$，将$f(n)\leq c_1\cdot g(n)$代入，显然是可以成立的</p></li><li><p>Assume again two (positive) nondecreasing functions f and gsuch that $f(n)=O(g(n))$. Is $2^{f(n)}=O(2^{g(n)})$ ? (Multiple answers may be correct, you should check all of those that apply.)</p><ul><li style="list-style: none"><input type="checkbox"> Always</li><li style="list-style: none"><input type="checkbox"> Never</li><li style="list-style: none"><input type="checkbox" checked> Sometimes yes, sometimes no (depending on $f$ and $g$)</li><li style="list-style: none"><input type="checkbox" checked> Yes if $f(n)\leq g(n)$ for all sufficiently large $n$</li></ul><p>这道题是问如果函数$f$与$g$满足$f(n)=O(g(n))$，那么 $2^{f(n)}=O(2^{g(n)})$ 是否成立。我们可以通过一些特殊的例子来解答。</p><ul><li>假设$f(n)=g(n)=n$，这种情况下，$2^n=O(2^n)$是显然成立的</li><li>假设$f(n)=10n，g(n)=n$，这种情况下，显然有$2^{10n}\neq O(2^n)$，这个在Course2课程的案例中介绍过证明</li></ul><p>综上所述，这个结论不总是对的，也不总是错的。</p></li><li><p>k-way-Merge Sort. Suppose you are given $k$ sorted arrays, each with $n$ elements, and you want to combine them into a single array of $kn$ elements. Consider the following approach. Using the merge subroutine taught in lecture, you merge the first 2 arrays, then merge the $3^{rd}$ given array with this merged version of the first two arrays, then merge the  $4^{th}$  given array with the merged version of the first three arrays, and so on until you merge in the final ($k^{th}$) input array. What is the running time taken by this successive merging algorithm, as a function of $k$ and $n$? (Optional: can you think of a faster way to do the k-way merge procedure ?)</p><ul><li style="list-style: none"><input type="checkbox"> $\Theta(nlog(k))$</li><li style="list-style: none"><input type="checkbox" checked> $\Theta(nk^2)$</li><li style="list-style: none"><input type="checkbox"> $\Theta(n^2k)$</li><li style="list-style: none"><input type="checkbox"> $\Theta(nk)$</li></ul><p>这道题是问在k-way归并排序中，如果给定k个有序数组，每个数组有n个元素，现在要将它们合并成一个包含$kn$个元素的大数组，归并操作如下：首先归并前两个数组，得到的新数组继续和第三个数组合并，依此类推。问这个连续的归并操作的运行时间复杂度是多少。每次归并操作都是线性时间$O(kn)$的，且有k次归并，因此上界的时间复杂度是$O(k^2n)$。对于下界，每次至少有$\frac{1}{2}k$个元素参与合并，因此下界运行时间是$\Omega(nk^2)$。综上所述，运行时间满足$\Theta(nk^2)$</p></li><li><p>Arrange the following functions in increasing order of growth rate (with g(n) following $f(n)$ in your list if and only if $f(n)=O(g(n)))$.</p><p>a) $\sqrt n$</p><p>b)10n</p><p>c) $n^{1.5}$</p><p>d)$2^{\sqrt log(n)}$</p><p>e)$n^{\frac{5}{3}}$</p><p>这道题是要求把以下五个函数按照增长率由小到大排序。答案是$2^{\sqrt log(n)} \leq \sqrt n \leq n^{1.5} \leq n^{\frac{5}{3}} \leq 10^n$。前面两个的证明可以是左右两边同时去对数。后面几个显然成立。</p></li></ol><a id="more"></a><h2 id="Programming-assignment"><a href="#Programming-assignment" class="headerlink" title="Programming assignment"></a>Programming assignment</h2><p>In this programming assignment you will implement one or more of the integer multiplication algorithms described in lecture.</p><p>To get the most out of this assignment, your program should restrict itself to multiplying only pairs of single-digit numbers. You can implement the grade-school algorithm if you want, but to get the most out of the assignment you’ll want to implement recursive integer multiplication and/or Karatsuba’s algorithm.</p><p>So: what’s the product of the following two 64-digit numbers?</p><p>3141592653589793238462643383279502884197169399375105820974944592</p><p>2718281828459045235360287471352662497757247093699959574966967627</p><p>这道题是要求利用前面课程所讲的分治法<code>Karatsuba整数求乘积</code>来求解，具体的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Karatsuba</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigInteger <span class="title">karatsuba</span><span class="params">(BigInteger x, BigInteger y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = Math.max(x.bitLength(), y.bitLength());</span><br><span class="line">        <span class="keyword">if</span> (N &lt;= <span class="number">2000</span>) <span class="keyword">return</span> x.multiply(y);</span><br><span class="line">        N = (N / <span class="number">2</span>) + (N % <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        BigInteger b = x.shiftRight(N);</span><br><span class="line">        BigInteger a = x.subtract(b.shiftLeft(N));</span><br><span class="line">        BigInteger d = y.shiftRight(N);</span><br><span class="line">        BigInteger c = y.subtract(d.shiftLeft(N));</span><br><span class="line"></span><br><span class="line">        BigInteger ac    = karatsuba(a, c);</span><br><span class="line">        BigInteger bd    = karatsuba(b, d);</span><br><span class="line">        BigInteger abcd  = karatsuba(a.add(b), c.add(d));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ac.add(abcd.subtract(ac).subtract(bd).shiftLeft(N)).add(bd.shiftLeft(<span class="number">2</span>*N));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BigInteger a = <span class="keyword">new</span> BigInteger(<span class="string">"3141592653589793238462643383279502884197169399375105820974944592"</span>);</span><br><span class="line">        BigInteger b = <span class="keyword">new</span> BigInteger(<span class="string">"2718281828459045235360287471352662497757247093699959574966967627"</span>);</span><br><span class="line">        BigInteger c = karatsuba(a, b);</span><br><span class="line">        System.out.println(c.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Coursera上学习“Algorithm专项课程”的第一课程，主要涉及渐近表示法(大O表示法)，排序与搜索算法，分治算法(主项定理、整数与矩阵乘法、最近点对问题)，以及随机算法(快速排序、最小割集收缩算法)。这一篇是I与II(第一周)作业的题目与解答。
    
    </summary>
    
      <category term="Techniques" scheme="http://tankcat2.com/categories/Techniques/"/>
    
    
      <category term="Algorithm Specialization" scheme="http://tankcat2.com/tags/Algorithm-Specialization/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm Specialization I-II  Asymptotic Analysis</title>
    <link href="http://tankcat2.com/2017/12/12/Course1-II/"/>
    <id>http://tankcat2.com/2017/12/12/Course1-II/</id>
    <published>2017-12-12T10:55:00.000Z</published>
    <updated>2017-12-23T04:36:07.302Z</updated>
    
    <content type="html"><![CDATA[<h2 id="The-gist-要旨"><a href="#The-gist-要旨" class="headerlink" title="The gist / 要旨"></a>The gist / 要旨</h2><p>Asymptotic analysis是设计和分析算法的vocabulary，比如大O表示法：</p><ul><li>从较高的层次分析算法的sweet spot</li><li>足够coarse来压缩依赖于系统/编程语言/编译器的细节</li><li>足够sharp来进行不同算法之间的有效对比，尤其是针对大规模输入集</li></ul><p>High-level Idea：比如$6\cdot n\cdot log_2n$== $n\cdot log n$，也就是说运行时间是$O(n\cdot log n)$</p><ol><li>压缩常数因子：依赖于系统/编程语言/编译器等</li><li>压缩低阶因子：与输入规模的增大无关</li></ol><p>举了四个例子：</p><ol><li>判断数组A中是否包含给定的整数t，$O(n)$</li><li>判断数组A或者B中是否包含给定的整数t，$2\cdot n = O(n)​$</li><li>判断数组A和B中是否包含相同的整数，$O(n^2)$</li><li>判断数组A中是否包含重复的整数，$\frac{1}{2}n\cdot (n+1) = O(n^2)$</li></ol><h2 id="Big-Oh-notation-大O表示法"><a href="#Big-Oh-notation-大O表示法" class="headerlink" title="Big-Oh notation / 大O表示法"></a>Big-Oh notation / 大O表示法</h2><p>这一节课讲解大O表示法的定义。令T(n)是n的函数f(n)，通常表示一个算法的worst case运行时间，那么问题是：什么时候$T(n)=O(f(n))$？答案是，当n足够大，最终T(n)的上限是一个常数与f(n)的乘积。下图所示，给出形式化定义：</p><p>当存在常数c和$n_0$，对于所有的$n\geq n_0$，有$T(n)\leq c\cdot f(n)$，则称$T(n) = O(f(n))$。其中，常数c和$n_0$与n无关。<br><a id="more"></a></p><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/bigoh.png" alt=""></p><h2 id="Basic-examples-基础示例"><a href="#Basic-examples-基础示例" class="headerlink" title="Basic examples / 基础示例"></a>Basic examples / 基础示例</h2><p>这节课的视频给出两个有关大O表示法的示例证明。</p><ol><li><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/bigoh_example1.png" alt=""></p></li><li><p>利用反证法证明</p><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/bigoh_example2.png" alt=""></p></li></ol><h2 id="Big-omega-and-theta-大-Omega-和大-Theta"><a href="#Big-omega-and-theta-大-Omega-和大-Theta" class="headerlink" title="Big omega and theta / 大$\Omega$ 和大$\Theta$"></a>Big omega and theta / 大$\Omega$ 和大$\Theta$</h2><p>前面两节课已经讲了$O()$表示法的形式化定义与基础示例证明，这节课视频再介绍三个相关的表示法。</p><ol><li><p>$\Omega()$表示法：关注的对象是运行时间的下界，形式化定义是如果存在常数$c，n_0$使得对于任意$n\geq n_0$都有$T(n)\geq c\cdot f(n)$，则$T(n)=\Omega(f(n))$。示意图如下图所示。</p><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/bigoh_omega.png" alt=""></p></li><li><p>$\Theta()$表示法：关注的对象是同时满足$O()$和$\Omega()$，形式化定义是存在常数$c_1，c_2，n_0$使得对于任意$n\geq n_0$都有$c_1 \cdot f(n)\leq T(n)\leq c_2\cdot f(n)$。</p></li><li><p>$o()$表示法：和$O()$有所区别，形式化定义是对于所有的常数$c$，存在常数$n_0$使得对于任意$n\geq n_0$都有$T(n)\leq c\cdot f(n)$。</p></li></ol><p>大多数情况下，还算关注$O()$表示法，因为设计者最关心的还是运行时间的上界。</p><p>最后需要说明的是，这些表示法并不是算法设计者或者计算机科学家发明的，早在19世纪就出现了，但是作为描述增长速率的标准语言，却是D.E. Knuth在1976年提出的$O，\Omega，\Theta$。</p>]]></content>
    
    <summary type="html">
    
      Coursera上学习“Algorithm专项课程”的第一课程，主要涉及渐近表示法(大O表示法)，排序与搜索算法，分治算法(主项定理、整数与矩阵乘法、最近点对问题)，以及随机算法(快速排序、最小割集收缩算法)。这是Course I中Asymptotic Analysis的笔记。
    
    </summary>
    
      <category term="Techniques" scheme="http://tankcat2.com/categories/Techniques/"/>
    
    
      <category term="Algorithm Specialization" scheme="http://tankcat2.com/tags/Algorithm-Specialization/"/>
    
      <category term="Course I" scheme="http://tankcat2.com/tags/Course-I/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm Specialization I-I Introduction</title>
    <link href="http://tankcat2.com/2017/12/11/Course1-I/"/>
    <id>http://tankcat2.com/2017/12/11/Course1-I/</id>
    <published>2017-12-11T07:11:00.000Z</published>
    <updated>2017-12-23T04:38:14.479Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction-简介"><a href="#Introduction-简介" class="headerlink" title="Introduction / 简介"></a>Introduction / 简介</h1><p>求解：两个n位整数相乘</p><p>输入：两个n位的整数x与y</p><p>输出：两者的乘积</p><p>解决方案：</p><ol><li><p>Naive方法：确定基本运算，即y的每一位都要与x中的n位相乘，就是n次基本运算了，乘积十位上的数字还要进上去，这就涉及一些额外的加法运算，但是总之在任何情况下，基本运算的总量最多是2n。同理，得到每一部分乘积最多都需要2n步运算，而部分乘积的总次数为n，即要做$2n^2$次基本运算。然而还没有结束，还要把这些部分乘积累加起来，才能得到最终结果，这一步的求和运算量最多也是$2n^2$次，因此计算两个n位整数的乘积的基本运算操作量为$4n^2$，是输入长度n的二次函数。</p></li><li><p>Karatsuba方法：利用分治的思想，把x表示为ab，y表示成cd，即a=56，b=78，c=12，d=34。通过以下前三个递归步骤，利用$x\cdot y = 10000\cdot a\cdot c + 100\cdot a\cdot d + 100\cdot b\cdot c + b\cdot d$这一思想来求得最终的结果。可以发现，第三步化简之后就是ad+bc，但是在具体操作时不是分别计算ad和bc的乘积再求和，而是使用化简之前的表示，先各自求得a与b之和、c与d之和，然后求积，最后减去已知的ac与bd。这样是为了减少一次递归次数，毕竟加减法才是最基本的运算。</p><p>形式化的方式来归纳以下，就是：</p><ul><li>$x = 10^{\frac{1}{2}}\cdot a + b$，$y= 10^{\frac{1}{2}}\cdot c + d$</li><li>$x\cdot y=10^{n}a\cdot c + 10^{\frac{1}{2}}(a\cdot d+ b\cdot c) + b\cdot d$，$n=4$ ($\star$)</li><li>递归计算ac，ad，bc，bd，然后代入上面的星式求得最终乘积</li><li>为了减少一次递归运算，不需要单独计算ad与bc的乘积</li></ul><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/karatsuba.jpg" alt=""></p></li></ol><blockquote><p>对于一个优秀的算法设计者而言，最重要的原则就是拒绝满足。</p><p>Perhaps the most important principle for the good algorithm designer is to refuse to be content.</p><p>The algorithm design space is surprisingly rich!</p><p>算法的设计空间，比我们想象中的要广阔得多！</p></blockquote><p>讲解模式：</p><ol><li>确定输入与输出</li><li>给出解决方案，即算法，使得输入转化为输出</li></ol><h1 id="About-the-course-关于这门课程"><a href="#About-the-course-关于这门课程" class="headerlink" title="About the course /关于这门课程"></a>About the course /关于这门课程</h1><p>课程涵盖了5个话题：</p><ol><li>设计与<strong>分析算法性能</strong>所需要的基本知识，比如大O表示法</li><li><strong>分治算法</strong>的设计与分析，使用场景很多，比如上一节课提到的Karatsuba算法，还有其他的比如排序、矩阵乘法等，需要分析类似递归算法的运行之间</li><li><strong>随机化算法</strong>的设计与分析，涉及到快速排序、图分解、哈希等</li><li><strong>图论分析</strong>的基本知识，涉及计算连通信息量、最短路径、社交网络的结构等</li><li>基本<strong>数据结构</strong>的实现与运用，涉及堆、平衡二叉搜索树、哈希表及其变种，比如布隆过滤器等</li></ol><p>后续课程可能会涵盖的话题：</p><ol><li><strong>贪心</strong>算法，涉及最小生成树、调度问题和信息编码理论</li><li><strong>动态规划</strong>算法，涉及基因序列和社交网络中的最短路径</li><li><strong>NP完全</strong>问题，涉及是什么以及解法<ul><li>能够解决特殊问题的快速算法</li><li>高效的有可证效率的回溯算法</li><li>具有指数时间复杂度的算法，本质上会比暴力搜索优化</li></ul></li></ol><p>从这门课学到什么：视频里说了不少，我挑我最感兴趣且觉得最重要的几点说说</p><ol><li>Become a better programmer.虽说读博对代码技巧要求未必很高，但还是希望自己除了学术分析、写作之上，有扎实的代码功底。毕竟还是希望自己毕业之后能去工业界待一段时间的。</li><li>Shapen mathematica analytical skills.这是实实在在我需要提神的一项技能！不仅老板指出来了，我自己也深有感触，写paper时构造不出定理与证明，实在是一大败笔！</li><li>Explain why things are the way the are, why we analyze the algorithms in the way that we do. 除了设计一个高效的算法，更重要的是你需要能够给别人讲懂，为什么是这样设计，为什么用这种方法来分析。这就回到上一点，良好的算法思路需要扎实功底的数学分析，这样才能充分理解！</li></ol><a id="more"></a><h1 id="Divide-and-Conquer-分治"><a href="#Divide-and-Conquer-分治" class="headerlink" title="Divide and Conquer / 分治"></a>Divide and Conquer / 分治</h1><h2 id="Merge-Sort-：Example-归并排序：示例"><a href="#Merge-Sort-：Example-归并排序：示例" class="headerlink" title="Merge Sort ：Example/ 归并排序：示例"></a>Merge Sort ：Example/ 归并排序：示例</h2><p>为什么在这里要讲解Merge Sort？有以下五点原因。</p><ol><li>Merge sort是一个著名的、古老但是很有用的排序算法，现在已经被列入许多标准库中了</li><li>Merge sort完美体现了分治的思想：把一个大问题分解为多个小问题，然后递归地解决小问题，最后合并小问题的求解结果，比Selection / Insetion / Bubble sort算法更直观更有优势</li><li>Merge sort可以为学生的未来课程做更好的定位，即calibrate your preparation，后续的算法讲解会越来越复杂，所以这是一个很好的热身，来帮助我们判断是否适合这个课程</li><li>Merge sort帮助看清，分析算法与分析其他事物有所不同，需要在分析之前做假设性前提，分析worst-case，然后采用asymptotic analytics渐近分析法来观察算法效率的增长</li><li>Merge sort是利用Recusive-tree递归树来分析的，这是一个Master method</li></ol><p>然后简要讲解了Merge sort是解决什么问题的？当然是解决乱序数组的排序问题啦。</p><p>输入：n个无序数字，假设没有重复数</p><p>输出：n个有序排列的数字</p><p>处理：把输入的数分成两半，先递归地解决左半部分，再解决右半部分，最后整合出结果，如下图所示，第一步可以想象成在递归调用之前先把左右两部分各自拷贝到新的数组中。</p><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/merge_sort.png" alt=""></p><h2 id="Merge-sort：pseudocode-归并排序：伪代码"><a href="#Merge-sort：pseudocode-归并排序：伪代码" class="headerlink" title="Merge sort：pseudocode / 归并排序：伪代码"></a>Merge sort：pseudocode / 归并排序：伪代码</h2><p>伪代码：不管归并排序的子程序具体是如何实现的，假设子程序已经存在了，那就直接合并。所以Merge sort的伪代码就比较明了，如下三步。</p><ol><li>递归地对输入数组第一半子数组进行排序</li><li>递归地对输入数组第二半子数组进行排序</li><li>将两个排好序的子数组进行合并</li></ol><p>递归算法需要一个基准，就是当输入为什么的时候，算法就得停止了，返回一个结果。那么在排序中，这个基准就是子数组中只剩下0或者1个数字的时候，不需要再进行计算，直接返回这个数字就可以了。算法实现的细节视频直接忽略了，比如如果数组长度为奇数钙怎么没办？也不会给出递归排序的具体细节，比如在递归调用中，如何把子数组的值返回给函数？这个视频要讨论的是抽象出来的有关算法的概念！</p><p>比较hard的部分：归并部分。下面给出归并部分的伪代码。</p><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/merge_preudocode.png" alt=""></p><p>分析归并排序的运行时间：从直观上看，应该从一个调试者的角度来考虑算法的运行，也就是说算法运行的时间就是所执行操作的数量，可以理解为实际执行代码的行数。虽然这是一个复杂的问题，但是这次视频忽略了递归相关的操作数量，只考虑归并操作。初始化有2步，进入for循环，每一次迭代有3步，然后还有循环本身的递增，即每一次迭代有4步。把这些加到一起，就得到归并操作的运行时间。给定一个有M数字的数组，最多执行$4\cdot M+2$步操作。这个上界可以放宽到$6\cdot M$，因为可能你要考虑循环递增数与总长度的比较，这类小细节操作。但这不是重点。分析Merge sort的主程序会更复杂，因为它在不断调用自身，所以需要分析递归调用的次数，这个次数是呈<strong>指数级</strong>增长的。_现在还有一个矛盾_，那就是进行递归调用时，输入数组会不断的减小，每次都是之前的一半大小。一方面是子问题的分裂造成的膨胀， 而另一面又是子问题会越来越小，二者之间形成了牵制 ，要解决这二者之间的矛盾就要取决于是什么在驱动Merge sort。后续视频会给出证明，这里先给出一个结论，就是算法的总步骤不超过$6\cdot N\cdot log N + 6\cdot N$。其他类似冒泡排序算法的总步骤是$N^2$，这两个的比较可以看下图，N越大，优势就越明显。</p><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/runtime.png" alt=""></p><h2 id="Merge-sort：analysis-归并排序：运行时间分析"><a href="#Merge-sort：analysis-归并排序：运行时间分析" class="headerlink" title="Merge sort：analysis / 归并排序：运行时间分析"></a>Merge sort：analysis / 归并排序：运行时间分析</h2><p>这节课的视频是分析Merge sort的运行时间，用数学方式证明：递归Merge sort算法对给定的包含n个数字的数组进行排序，输出有序数组总共需要$6\cdot n\cdot log_{2}n + 6\cdot n$次操作。</p><p>证明方法是使用recursion tree递归树，在树结构中写下Merge sort所做的全部工作，一个节点每次递归调用就创建两个孩子节点，如下图所示。根节点root是首次对Merge sort的调用，这一层称作level-0。level-1对应root接下来的两次递归调用，输入是原数组的一半。以此类推，直到最后子数组里面数字的个数为0或者1。显然，叶子节点所在的层是level-$log_{2}n+1$。</p><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/recursion_tree.png" alt=""></p><p>确定好树的深度，需要计算每层的操作数量。首先回答两个问题：</p><ol><li>对于给定的第j层，有多个sub problem？</li><li>对于第j层的每个sub problem，输入子数组的size是多少？</li></ol><p>答案也显然，第j层有$2^j$个sub problem，每个sub problem的输入size是$\frac{n}{2^j}$。整个递归树的总操作数量是每层的操作数量之和。由于递归调用本身可以忽略不计，因此只考虑merge操作里的操作数量。分析如下图，第j层的merge次数是$2^{j}\cdot 6\cdot \frac{n}{2^j}$，其中$6$在上一节课的视频中分析过。最后，总共有$log_{2}n+1$层，所以最终结果是$6\cdot (log_2n+1)$，证明结束。</p><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/operation_time.png" alt=""></p><h2 id="Guiding-principles-for-analysis-of-algorithms"><a href="#Guiding-principles-for-analysis-of-algorithms" class="headerlink" title="Guiding principles for analysis of algorithms"></a>Guiding principles for analysis of algorithms</h2><p>这一节课的视频是回过头来，介绍算法分析的三项指导原则，也可以说是三项假设，从而帮助我们分析推到算法，并给出”fast”算法的定义。</p><ol><li>只考虑worst-case。和avarage-case和benchmark analytics相反，最坏情况的分析对输入没有要求，不需要domain knowledge。</li><li>忽略小的常数因子。原因比较简单，第一，简化分析；第二，就这个课程而言，纠结于常数因子对算法的影响没有意义，毕竟常数因子对算法的影响很大程度上还取决于硬件结构、编译器、使用的编程语言、程序员编码习惯等。</li><li>关注大规模输入asymptotic analytics。当输入规模逐渐增大至无限，分析算法的性能。关注小规模输入没有意思，以排序为例，也许只对100个数字排序，Merge sort的对数级运行时间会高于其他平方级算法。但是某个临界点过后，对数级的运行时间优势就越来越明显。</li></ol>]]></content>
    
    <summary type="html">
    
      Coursera上学习“Algorithm专项课程”中的第一课程，主要涉及渐近表示法(大O表示法)，排序与搜索算法，分治算法(主项定理、整数与矩阵乘法、最近点对问题)，以及随机算法(快速排序、最小割集收缩算法)。这是Course I中介绍Introduction的笔记。
    
    </summary>
    
      <category term="Techniques" scheme="http://tankcat2.com/categories/Techniques/"/>
    
    
      <category term="Algorithm Specialization" scheme="http://tankcat2.com/tags/Algorithm-Specialization/"/>
    
      <category term="Course I" scheme="http://tankcat2.com/tags/Course-I/"/>
    
  </entry>
  
  <entry>
    <title>十二月的第二周</title>
    <link href="http://tankcat2.com/2017/12/10/diary1210/"/>
    <id>http://tankcat2.com/2017/12/10/diary1210/</id>
    <published>2017-12-10T14:51:00.000Z</published>
    <updated>2017-12-12T11:18:20.329Z</updated>
    
    <content type="html"><![CDATA[<h3 id="被各种杂事扰乱的工作日"><a href="#被各种杂事扰乱的工作日" class="headerlink" title="被各种杂事扰乱的工作日"></a>被各种杂事扰乱的工作日</h3><p>结束了上周五组会上的简陋survey，这周的工作日就不打算继续读新的paper了，给自己定了下面几个需要完成的目标：</p><ul><li style="list-style: none"><input type="checkbox" checked> 明珠这周讨论班要将讨论班，再读08年的CRB，把checkpoint的过程梳理一遍；</li><li style="list-style: none"><input type="checkbox" checked> Demo文章初稿，和蒋程交涉好前端需要做的；</li><li style="list-style: none"><input type="checkbox" checked> 关注NVMe；</li><li style="list-style: none"><input type="checkbox" checked> 思考并设计survey的维度；</li><li style="list-style: none"><input type="checkbox" checked> 开始学习Algorithm Specialization课程的学习</li></ul><p>周一一早来老板便交代了要开始准备1月初的Demo投稿，因为这个工作的后端实现是和房叔一起做的，已经出了两篇paper了，前端明珠之前实现了一个相对简单的版本，所以论文写起来应该不费事，所以上午先搞了注册的事情。今年有点懵逼啊，按照Demo track给的submission链接注册好个人信息了之后发现没有任何提交paper信息的按钮？？？最后只在Research track板块里给的链接找到了能投稿的地方，占了一个坑。paper的名字也是随意起的。正式写之前先找了几篇已经发表的demo paper看了看，页数限制，就简单安排了一下论文框架。然后抽出了之前工作的关键技术，简要介绍了一番。画系统架构图废了点时间，虽然以前的图也能用，但是太Low了，还是要好好设计一下，毕竟中了的话还能去土澳浪一波~下午三四点的时候在大众点评上选中了两家轰趴馆，晚上约了欢欢去“实地考察”了一番，第一家新开的，环境很不错但是价格不低；第二家环境一般价格也不是很低。回来之后和实验室的小伙伴讨论了一下，大家觉得场地费平摊下来人均不低，所以当天晚上没有确定结果。</p><p>周二早上6点半就起床了，因为天气预报说有太阳，于是洗漱之前把床单被单拿到楼下洗衣房洗，洗漱收拾好把被子和洗好的床被单拿出去晒。上午就继续写demo。中午回去发现晒被子的地方没有阳光了，所以就转移场地，拿到宿舍西边楼道的窗台上晒了。下午抽空继续商讨轰趴馆的选择。由于现在是黄金档，就近的几家价格都不便宜，大家因为价格原因不太愿意去，有的同学甚至建议直接组织出去唱歌然后举个餐就算了事了。但是毕竟有的人不喜欢唱歌啊，这样他们参与不进来，所以迟迟出不了结果。最后学姐让步了，她说她和小龙愿意承担1000块，算作是她毕业请吃饭。我把情况和大家说明了一下，可能是觉得学姐都让步到这个程度了，所以最终确定了还去轰趴。几个学弟还是很好说话的，他们本来也建议去轰趴，也不是很在乎钱的问题。轰趴馆就选的第一家，和店家确定之后交了五百押金，这事就算是安定了。晚饭期间去操场跑了三公里，快走了一公里。</p><p>周三是最忙的一天了。早上化了妆出门，以为下午颁奖典礼需要上台。上午本来打算把CRB好好再看一遍的，老板一个消息发过来要帮她买一桶羽毛球。一开始以为大活那边有得卖，哪知道体育器材店没有开门。遇到一个保安大叔，他说校门那边的体育馆有得卖，我就急匆匆地跑过去，发现就剩几只了，没有成桶卖的。然后又跑到校外的联华超市，被告知又没有！最后只能寄希望于教育超市了，如果在没有只能让老板自己淘宝了。万幸，教超有得卖。买到手的时候内心mmp，为啥一开始不先去教超呢，明明离得最近……买完已经10点半了，迅速回宿舍补了妆，然后去河东食堂吃了午饭，就去停车场等校车去闵行路。颁奖典礼一直开到下午三点多，根本用不着我们上台，事先确定好了学生代表上台领奖。返程路上看完了行尸走肉这周新更，全程高度紧张，片尾又留悬念，看完更饿了。到了学校之后赶紧去全家买了一个鸡肉卷饼。晚饭之前迅速浏览了一遍CRB，弄清楚了一些基本概念，比如COW、WAL。晚上我们FToS小分队三人继续了这周的小讨论班，帮明珠解答了论文中看不懂的疑惑，我自己也顺带加深一遍理解。</p><a id="more"></a><p>周四也是不消停的一天。这天的原计划是把CRB没看完的看完，再关注一下NVMe，顺带复习一下存储技术的基础知识，于是把去年翁老师的课件翻出来又刷了一遍。中途想起来还没问教务老师，转博要提交的材料到底有哪些，邮件上也没说明。跑过去问清楚了，缺的材料不少，专家推荐信还缺一份，于是加了老金的微信，老金当天去北京出差了，晚上还抽时间帮我填好了材料，感动。这天上午男票还犯傻，想骗我说521，被我识破，这个小插曲我写在前一篇日记里了。晚上去参加了三位同学的转预备党员小会。</p><p>周五上午继续学习NVMe。这天没什么特别的事情，下午讨论班也顺利进行了。除了将论文，李学长和老师还一起帮我梳理了后面利用NVMe可以考虑的研究点，跟李学长要了几篇文章，下周看看。晚上整理轰趴需要准备的食材、娱乐项目清单整理出来，在实验室群里说明了一下各项事宜。</p><p>PS：每天早上来实验室刷完单词之后花四十分钟左右的时间学习算法课程，并整理笔记，笔记以及相关的学习资料我挂在github上了<a href="https://github.com/tankcat/algorithm-specialization-notes" target="_blank" rel="noopener">algorithm-specialization-notes</a>，看视频的时候也想锻炼自己的英语，所以放的是英文字幕，希望自己以后能脱离字幕看视频吧。除了这个，这周把饮食健身打卡也从豆瓣小组的帖子转移到github上了<a href="https://github.com/tankcat/diet-record" target="_blank" rel="noopener">diet-record</a>，因为这样本地编辑起来更加方便。</p><h3 id="日程满满的周六周日"><a href="#日程满满的周六周日" class="headerlink" title="日程满满的周六周日"></a>日程满满的周六周日</h3><p>这次周六周日日程安排得满满当当：周六中午和原来313的两个学姐、一个学弟(欢欢、妍虹和高竹)一起去避风塘吃饭，周六晚上约了小慧去吃上周抽中的一家霸王餐；周日要组织实验室的小伙伴们一起去轰趴。</p><p>周六早上晚起了一会儿，发现牛油果再放就要坏了，于是打奶昔的时候顺便给早来实验室的一个学弟也做了一杯。学习好算法视频，写好周报，收拾了一下就出门去环球港的避风塘占座了。记得三四年前和本科室友们第一次在南京马群吃避风塘的时候，觉得超级好吃，今天发现质量严重下降，点心太甜菜太咸，连云吞面的汤也是，烧鹅肉质一点也不新鲜。席间学弟学姐们讲了不少工作上的事情。饭后他们三人去Coco各自买了奶茶，后来转战到宝珠奶酪，我又买了一杯牛油果雪酿，这次喝得比较慢，看着它慢慢融化，喝到最后越来越美味~在宝珠奶酪待了很久，听学弟说互联网的加班很辛苦，最近这段时间他经常加班到晚上十一二点才回家，说工作了之后才发现，真的比在学校辛苦太多，在学校就算老师给了deadline，其实没有按时交出结果也不是大问题，但是工作上很不一样，没有人会设身处地地为你想，没有结果就等于没做。想想自己决定转博，也不乏逃避找工作这一因素。聊完之后就在环球港逛了逛衣服，中午让老妈资助了五百，去买了上周相中的那件粉色卫衣。因为中午吃得太饱，下午又喝了一大杯雪酿，晚饭就没吃，回宿舍锻炼了半小时的HIIT。洗完澡回到实验室把临时不去轰趴吃午饭的人记录一下，确定了周日早上去菜市场采购的人员和时间点。安排好所有事情之后又看了会算法视频。</p><p>周日早上6点30起来，洗漱完撸了一个简易妆，然后就和采购小分队去买菜了。从枣阳路门出去，到光复西路左转，穿过强家角桥，发现了好多家崇明蔬菜市场，按照周五晚上定的食材清单采购完，就骑了单车去轰趴馆。由于时间还早，交接的人还没到，我们五个人就先在新客来大食堂坐了一会儿，给大家买了大肉包当早饭吃，后来直接在店里买了一些打包饭盒和一次性筷子。进了轰趴馆后，分配好洗菜任务，就继续和其中一个学弟去环球港买了点零食、主食和酱料。还买了一瓶牛奶，因为今天带了自己的电炖锅，给大家做了奶茶喝~陆陆续续人到了，中午就涮起火锅吃，16个人围着一个小吧台、两口锅还是有点挤的，不过吃得还算开心，口味还不错，嘿嘿，自夸一下。吃完大家就开始游戏了：有玩狼人杀的，有打桌球的，有打麻将的，有玩街机的，还有唱K的。这家KTV效果还是不错的，今天唱得很尽兴，哲神和韩易唱歌都超级厉害，周杰伦、陈奕迅的每首歌都唱的很6~很开心今天和哲神合唱了青峰和Ella的《你被写在我的歌里》，也很开心他们俩唱双截棍，我、小慧还有卷积在旁边附和，真心嗨爆了，可爱又迷人~再有就是后来祝翔加入，一起唱霍元甲~唱到一半累了，出去和鹏鑫打了两局桌球，平手~只要不让我设计那种可以反弹折射的角度打法，我还是可以的哈哈。晚上就把中午没吃掉的饺子煮了，由于锅不大，两大袋饺子足足分了四次才煮完。怕不够吃，还点了三个达美乐披萨，土豆味的一如既往地好吃~吃完饭又继续进去唱K，一直到最后，大家合影留念。这是我第一次主动组织大家聚会，我这个人吧喜欢简单，所以安排事情的时候就可能没有考虑很全面，反思一下，以后说话态度也要和善一点~总之，大家玩得还算尽兴，也辛苦起早陪我一起买菜得小慧、杨康、蒋程和汤路明，辛苦可人给大家拍照，也辛苦参与和支持的每一位小伙伴~</p>]]></content>
    
    <summary type="html">
    
      一周的流水线，只是记录，文笔很差。
    
    </summary>
    
      <category term="Jottings" scheme="http://tankcat2.com/categories/Jottings/"/>
    
    
      <category term="周记" scheme="http://tankcat2.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="自省" scheme="http://tankcat2.com/tags/%E8%87%AA%E7%9C%81/"/>
    
  </entry>
  
  <entry>
    <title>十二月的第一周</title>
    <link href="http://tankcat2.com/2017/12/03/diary1203/"/>
    <id>http://tankcat2.com/2017/12/03/diary1203/</id>
    <published>2017-12-03T12:44:00.000Z</published>
    <updated>2017-12-12T10:51:48.919Z</updated>
    
    <content type="html"><![CDATA[<p>十一月就这么静悄悄地溜走了，回头一看，这一个月好像正经事没做成，但是仔细数数又似乎达成了不少目标。</p><ol><li>拿到了研究生国国家奖学金、校优秀学生、全国研究生数学建模二等奖</li><li>给爸爸换了手机，买了种草许久的Mate 9</li><li>体重下百了</li><li>订制了心仪的中古包、买了一整套Martiderm的平衡和臻活安瓶、买了性价比高的牛角梳</li></ol><h3 id="工作日的日常"><a href="#工作日的日常" class="headerlink" title="工作日的日常"></a>工作日的日常</h3><p>这周周五的讨论班轮到我讲，因为十一月的主要工作就是读paper，于是就准备做个简短的survey。算下来看了有二十多篇，由于没找到读paper的技巧，为了赶进度导致很多篇都没有真正理解，做起survey的时候才发现很多东西自己也讲不清楚。</p><p>一开始给自己这周的规划是，新论文就不读了，专心整理已经读过的。然而，周一又把时间花在自己的个人博客上了。无意间发现有人利用Github Issue改写了一个评论系统，我觉得还不错就想着借鉴一下，替换现有的disqus。一些配置问题占用了我一整个下午。晚上参加数模的三个团队，其实也就是实验室的小伙伴，说拿了奖一起约顿饭，于是就去秋林阁三楼点了一桌子菜。每次都必点青椒炒蛋和冬瓜排骨汤。吃完洗了澡，回到实验室继续看paper。但是又被一个妹纸的个人博客吸引住了，她的首页是 一张cv，而博客是二级域名。她把cv的制作公开在github上了，由于一些域名设置问题，我捣鼓了不少时间，最终还是放弃，十点半的时候回寝室睡觉了。</p><p>周二早上醒来觉得还是不甘心，cv我肯定是也要做一张的，但是不换域名了，直接利用HTML按照她的样式做了一个一模一样的，简单粗暴，替换成了博客的首页。博客的改造终于完成了，就继续做起了survey。原本打算先把上周没看完的一篇02年的survey看完，可是越看越觉得不理解，心情很烦躁。不巧中午来了大姨妈，肚子很疼，就荒废了一下午躺在床上休息。</p><p>周三算是真正开始写survey的presentation了。 没有跳出前人整理的框架，我继续沿用，只是合并了一些小分类，在整理具体系统的容错实现时发现自己还是无从下手，不知道怎么才能讲的清楚，又陷入了烦躁的情绪，没忍住还和男票哭诉了一番。晚上洗完澡发现自己感冒了，真是祸不单行。</p><p>周四继续写presentation，但是不巧，遇到老板开始帮我改老早之前的期刊文章。仍旧是定理证明的那块儿写的不好。这一块儿反反复复修改了不知道多少遍了，我早已厌烦。我承认，想要投稿期刊论文，又或者说以后想投稿顶会论文，没有两三个定理与证明是真说不过去的，这一块技能我确实欠缺了。下午老板把我叫过去，讲完问题所在之后我主动和她交流了一下这一个月来读论文的感受，说明了自己的矛盾所在，其实烦躁的根源在于自己平日偷懒、效率低下导致论文没有理解透彻，后来回了实验室，老板在微信了给我打了一剂鸡血。</p><a id="more"></a><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/jixue.jpg" alt=""></p><p>男票跟我说，做presentation的时候就尽力止损吧，把自己理解的讲清楚，不理解的说明一下情况。没想到，presentation竟然顺利进行了，主要也有李学长的助攻。李学长真的是个神童，经常就是我们自己讲presentation的人还没有他听的人理解得透彻。这大概就是知识储备的差距吧。讨论班结束之后，学弟还反映说这次连他也听懂了，嘿嘿。</p><p>这一周的工作日也就这些了，主要就是对看过的文章做了整理，但是层次还很浅显；这一周锻炼和背单词也搁置了没进行。接下来又重新制定工作计划，把没有理解的概念、技术重新弄懂，paper也要继续读，设计分类的维度，整理好每一维度上各个系统、技术的实现、优缺点等等。</p><p>ps：看到一段鸡血，或者说拖延症的治疗技巧。</p><blockquote><p>朋友们，我的一点切身经验，如果你觉得某个任务让你特别焦虑，压得你喘不过气来，那么最好的排解方法就是直接去做这事，什么都别管，就是使劲做，努力地推进其进度，这棘手的事情在进度上每发展一点，你的焦虑就会少一分，同时你的焦虑越少，推进的速度也就越快，只要咬紧牙关，不停地推进，总会有解脱的那一天，而且你每完成一个棘手的任务，你或多或少都会比之前牛逼强大那么一点，这件苦差事总是会改变你一些。<br>真的，诸位，有什么难事千万别耗着，别等着，那只会让人在无尽的焦虑中煎熬，你就先大吼一句：“去你妈的。” 然后两眼血丝地去推进，去做事，做着做着就有出路了。 </p></blockquote><h3 id="短暂的周末相聚"><a href="#短暂的周末相聚" class="headerlink" title="短暂的周末相聚"></a>短暂的周末相聚</h3><p>原本周五晚上讨论班结束就要去无锡的，老早就跟男票定好这周末去无锡玩，正好两人折中路程。然后计划赶不上变化，今天他公司有年会，再加上我感冒了，于是去无锡的计划就推迟了。一个月没见面了，甚是想念，最后决定这周他来上海找我。这次来上海就不打算去较远的地方拔草了，就带带他去我我比较喜欢的黄焖鸡、汤包店还有甜品店吃吃喝喝，顺便去商场逛逛，买点衣服，还要带他去枣阳路的那家星巴克，我实在是太喜欢这家店了。</p><p>周五晚上关掉了闹钟，早早爬床，周六早上睡到自然醒，睡前用了臻活安瓶，洗脸的时候发现毛孔又小了欸~早饭去全家买了一个黑胡椒鸡排三明治，里面有鱼子蛋沙拉，木有喜士多的好吃~买完回实验室，在Coursera上找了一门Standford的算法课，打算以后每周周末抽出半天时间恶补一下薄弱的算法基础。中午去河东食堂吃了一碗冒菜，十二点了人还是很多，这次没吃全素，加了一根里脊肉和两块午餐肉，可能是人多煮得比较急吧，番茄汤底又油又咸……吃完回实验室继续啃算法，中途微信上不断骚扰男票，问他酒宴吃得怎么样了。原来说好坐四点的高铁过来的，可以他们吃完酒宴还要聊天，他就改签了五点。想到他周一上午要开例会，所以周日下午就得回去，这次相聚的时间本来就比较短，他还改签推迟了！于是当然要生气啦！反正后面他给我发微信我都没鸟他，自己一个人收拾好洗漱用品，去宾馆办了入住，然后就静静地看起了电视。。。他将近七点多才到，我自己饿得受不了了就点了一份老乡家香酥鸡柳和炸里脊，里脊还是小时候在文峰大世界妈妈买给我吃的味道~接到他之后，两人就去环球港觅食啦~去宝珠奶酪家发现没有牛油果奶昔了T^T，想吃点菜的但是想到我们是贫穷夫妻俩，就决定去大时代随便吃吃，买了一笼富春苏式汤包，还点了三个蒸菜，都很难吃！后悔了，还不如去吃点菜呢！敲生气！吃完就在环球港随便逛了逛，发现了一家新开的衣服店叫MM麦檬，衣服都挺不错了，试了一件白色的韩系羽绒服，穿着像披了一条棉被哈哈，不过店里的镜子都是显瘦的，虽然臃肿，但是时尚感不减~由于价格原因，又因为上周刚在网上预定了一件羽绒服，没买就回去了~上楼之前又去林间小屋买了一个巧克力杯子蛋糕，一如既往的好吃~</p><p>周日早上也是早早起床，因为想带他去吃很多我觉得好吃的小吃。他昨晚没怎么吃，蔡师傅汤包店又有点远，就先去林间小屋买了一个巧克力麻薯填填肚子~意外得好吃呀，难怪大众点评上不少人推荐。穿过了金沙江路，到与枣阳路的交汇处就是蔡师傅汤包店了。早上人还是挺多的，中老年人居多，大概都是周围的居民，点了两碗小馄饨、一笼汤包还有一个小小的甜口烧饼。小馄饨的汤里估计是放了猪油，很好喝，汤包有点酸，不知道怎么回事。我吃了两个汤包和几颗小馄饨就饱了，他估计是真饿了，把我剩下的小馄饨也都吃光光了，哈哈哈~吃完带他去买了老香斋的蝴蝶酥和榴莲酥，然后步行回宿舍放下书包，两人就又去环球港逛吃逛吃了。主要原因是前一天晚上决定还是去把那件羽绒服买下来，网上预定的那一件可以退了。先带他去吃说了好几次的Godiva的冰淇淋，今天没有优惠券，50块买了一只全巧克力味的，好甜好甜，我自己是不太喜欢吃啦。吃完就去买衣服了，为了下周的奖学金颁奖典礼，还特地买了一条正式一点的半身裙。买完在店里休息了一会儿，顺便又试了一件粉色的卫衣，外加N件大衣~哎，要是有钱就全拿下啦，都很喜欢~时间还早，两人就去宝珠奶酪坐了会儿，买了一杯新出的酒酿酸奶。上上周在店里有店员拿给我试吃，当时觉得好不错，今天吃感觉一言难尽……午饭就带他去吃很喜欢的一家黄焖鸡，点了两碗小份，我的另加了一份土豆和金针菇，他不喜欢吃金针菇，就给换成了青菜。中途还遇到了室友，哈哈，这也是她第一次和男票打招呼。吃完在学校里逛了逛，坐在河边看看风景，落叶、小河还有垂钓的老爷爷，好不休闲~因为感冒还没好，原本买的六点的车票，让他提前改签到三点了。这次没送他去车站，看着他进地铁的时候实在是太难过了，忍不住又哭了起来。现在相聚的次数越来越少，每次相聚的时间也很短暂。原来刚在一起的时候不觉得异地恋有啥，现在感情越来越深，对他越来越依赖，就感觉异地恋真的很辛苦。送他走后，我实在是太累了，回去一觉睡到五点。</p><p>洗完澡回到实验室，更新了这篇日记。这一周就要过去啦，明天迎来新的一周，继续奋斗吧，为了美好的将来~</p>]]></content>
    
    <summary type="html">
    
      一周的流水线，只是记录，文笔很差。
    
    </summary>
    
      <category term="Jottings" scheme="http://tankcat2.com/categories/Jottings/"/>
    
    
      <category term="周记" scheme="http://tankcat2.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="自省" scheme="http://tankcat2.com/tags/%E8%87%AA%E7%9C%81/"/>
    
  </entry>
  
  <entry>
    <title>十一月的第四周</title>
    <link href="http://tankcat2.com/2017/11/26/diary1126/"/>
    <id>http://tankcat2.com/2017/11/26/diary1126/</id>
    <published>2017-11-26T10:29:45.000Z</published>
    <updated>2017-12-12T10:51:30.695Z</updated>
    
    <content type="html"><![CDATA[<h3 id="工作日的survey"><a href="#工作日的survey" class="headerlink" title="工作日的survey"></a>工作日的survey</h3><p>这个月进行survey的第四周，工作日的五天细读了两篇微软的流处理系统paper，一篇Naiad和一篇Falkirk Wheel；一篇很经典的Dynamo，十年前就发表的这篇今年喜获SIGOPS名人堂奖，重点关注了它的高可用是如何实现的；一篇综述，其中一个作者和Naiad、Falkirk Wheel联系密切，这篇综述关注的点很基础。</p><p>算下来从开始做survey，看过的文章也有二十多篇了，关于容错，心中确实有了一点感觉，但觉得还不够，有的时候回头想想看过的文章，竟然不能一句话讲出它做了什么，看过就忘成了很大的问题。男票告诉我，这是因为我没有理解透彻。所以，现在就有点迷茫，到底什么文章该精读，精读到什么程度是够的，要想真正理解一篇文章的proposal，耗时不短，这当中该怎么做权衡呢？</p><p>还有一点需要反省，就是效率问题，一周只看了四篇文章，很大一部分时间还是被我浪费了，经常看文章看到一半就去找人聊天、逛豆瓣微博，没有完整、高效率的学习时间，这应该也是导致文章理解不透彻的原因之一吧。</p><p>不过，有进步的是，开始定制周计划了，也切实进行了，希望在次基础上提高效率并继续保持。</p><a id="more"></a><h3 id="周六周日的吃吃玩玩"><a href="#周六周日的吃吃玩玩" class="headerlink" title="周六周日的吃吃玩玩"></a>周六周日的吃吃玩玩</h3><p>周六中午出门，骑单车去武康路的一家星巴克臻选店买工业风的杯子，哪里知道好不容易找到这家店却被告之没有存货，感觉委屈的不行。直接返程肯定是不行的，不然就白出来了，于是就在武昌路和湖南路附近逛逛，后来又去一家网红面店吃了一碗辣肉面。然而，十个网红店九个是垃圾，这家面店很荣幸也是垃圾，38块一碗的面还不如河西食堂3块一碗的阳春面。返程的时候选择步行，正好记一记路线。从武康路-兴国路-华山路-江苏路-愚园路-长宁路-凯旋路-万航渡路-光复西路-枣阳路，短短五公里串联了这么多道路，有些路很小资、适合拍照，有些路就普普通通、大众化。走到长宁路上的兆丰广场，看到有Bose专柜就想顺便试试音质，试玩就心动了，比我的大法轻多了。走之前顺便又去nitori买了一口雪平锅，想着宿舍厨房里有电磁炉，以后可以熬奶茶、煮泡面吃，可是买的时候没看清楚，今天早上发现这锅只能用煤气加热。晚上懒得回实验室了，和男票商量了一下要讨论微信小程序的需求问题，于是又背着包出门，选择在枣阳路的这家星巴克讨论。环境还是不错的，有无线，周六晚上人很少，买了一杯太妃榛果，店员还给了一些蛋糕试吃。讨论完肚子又饿了，就去蔡师傅汤包店点了一碗小馄饨和一块素鸡，美味又划算。最后，回寝室洗漱。哦对了，昨天是老爸生日，舅舅一家去家里，燕子姐姐又给爸爸买了礼物。听老妈说，爸爸这次很感动，不仅燕子姐姐送了礼物，我又送了手机，好像老爸都哭了。</p><p>周日赖了床，早上8点半才醒，准备用雪平锅煮奶茶的时候发现电磁炉不能加热，没办法只能换成电炖锅来做了。牛奶是在盒马鲜生上买的明治鲜奶，加了两包立顿红茶包，这次冰糖又放多了，不过口感还是很醇厚的，虽然比较甜，和外面比起来还是健康很多的。给实验室的小伙伴带了一点，评价都不错。中午去了实验室，忙着把Hexo个人博客需要的环境在新笔记本上重新搭建了一下，遇到了不少问题，但是都解决了。搞完已经三点了，在大众点评上选择了一家中江路那边的日料店，骑了单车过去，由于不是饭点，店里除了我没其他顾客，点了三文鱼刺身、炸土豆饼、煎饺和炸鸡肉串，很快就消灭了~</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>这一周过得还是挺充实了，周一早上体重还下百了，激动得我发了一条朋友圈。可是下百就一天，接着几天就无所顾忌地吃，周一把剩余的牛油果继续做了奶昔喝，周二吃了冒菜，周三又跑去吃了煲宫，周五还吃了麻辣香锅和芝麻糊小圆子，周六周日前面已经说了。减肥我还是会继续的，只是不会再像一开始那么严格了，该吃吃还是要吃，该锻炼也还是会锻炼，健康的前提下保持身材。技能上，</p><p>就这样吧，明天又是新的一周，下周五轮到我讲survey，还有四天半的时间好好准备，加油吧二筒子~</p>]]></content>
    
    <summary type="html">
    
      一周的流水线，只是记录，文笔很差。
    
    </summary>
    
      <category term="Jottings" scheme="http://tankcat2.com/categories/Jottings/"/>
    
    
      <category term="周记" scheme="http://tankcat2.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="自省" scheme="http://tankcat2.com/tags/%E8%87%AA%E7%9C%81/"/>
    
  </entry>
  
  <entry>
    <title>冬日就该来杯热乎的焦糖奶茶~</title>
    <link href="http://tankcat2.com/2017/11/25/milktea/"/>
    <id>http://tankcat2.com/2017/11/25/milktea/</id>
    <published>2017-11-25T01:22:47.000Z</published>
    <updated>2017-11-27T13:43:01.445Z</updated>
    
    <content type="html"><![CDATA[<p>关注的好几个美食博主都各自分享了自制奶茶的教程，我选择了大胃爱丽丝的焦糖奶茶，因为最简单，除了原材料就只需要一个微博里就可以了，我这么懒，怎么会还专门买个奶锅回来呢~买了奶锅回来可能就只煮方便面了吧hahaha…</p><p>下面是我交的作业，我的材料和微波炉和教程里有出入，所以每个步骤耗时也会有所不同。</p><p><strong>首先是原材料：</strong></p><ol><li><p>安佳全脂牛奶一瓶 250ml。这里大家可以自行选择牛奶的品牌，我是喝惯了安佳，觉得奶香很足。</p></li><li><p>冰糖 6颗。我没用白砂糖的原因是宿舍里只有冰糖，我懒，不想出去买，哈哈哈。</p></li><li><p>立顿红茶包 2袋。</p></li><li><p>玻璃杯，可微波炉加热。</p></li><li><p>微波炉。宿舍厨房的微波炉功率感觉不行，每个加热步骤我都比原教程里的长。</p></li></ol><p><strong>其次是具体加热步骤：</strong></p><ol><li>冰糖加一点儿水，放进微波炉叮4分半钟。因为冰糖不容易化，加上微波炉功率不行，原教程只要叮1分半钟就能熬出焦糖色，我足足叮了三次。</li><li>取出杯子，加入全脂牛奶和茶包，放进微波炉里叮2分钟。</li><li>再次取出杯子，用勺子轻轻挤压茶包，轻轻搅拌杯底的焦糖，放进微波炉里叮2分钟。这里一定要注意！立顿的茶包好容易挤破，我就是挤破了QAQ茶叶碎都溢出来了，最后只能等到沉淀了才能喝。</li><li>开喝。</li></ol><p>PS: 个人觉得冰糖放得还是有点儿多，因为喝的时候觉得好甜啊，连室友也说太甜了…下次我要试试不放冰糖，看看是不是真的很影响口感~</p><p>以上，谢谢观看~</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关注的好几个美食博主都各自分享了自制奶茶的教程，我选择了大胃爱丽丝的焦糖奶茶，因为最简单，除了原材料就只需要一个微博里就可以了，我这么懒，怎么会还专门买个奶锅回来呢~买了奶锅回来可能就只煮方便面了吧hahaha…&lt;/p&gt;
&lt;p&gt;下面是我交的作业，我的材料和微波炉和教程里有出入，所以每个步骤耗时也会有所不同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先是原材料：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安佳全脂牛奶一瓶 250ml。这里大家可以自行选择牛奶的品牌，我是喝惯了安佳，觉得奶香很足。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;冰糖 6颗。我没用白砂糖的原因是宿舍里只有冰糖，我懒，不想出去买，哈哈哈。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;立顿红茶包 2袋。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;玻璃杯，可微波炉加热。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;微波炉。宿舍厨房的微波炉功率感觉不行，每个加热步骤我都比原教程里的长。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;其次是具体加热步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;冰糖加一点儿水，放进微波炉叮4分半钟。因为冰糖不容易化，加上微波炉功率不行，原教程只要叮1分半钟就能熬出焦糖色，我足足叮了三次。&lt;/li&gt;
&lt;li&gt;取出杯子，加入全脂牛奶和茶包，放进微波炉里叮2分钟。&lt;/li&gt;
&lt;li&gt;再次取出杯子，用勺子轻轻挤压茶包，轻轻搅拌杯底的焦糖，放进微波炉里叮2分钟。这里一定要注意！立顿的茶包好容易挤破，我就是挤破了QAQ茶叶碎都溢出来了，最后只能等到沉淀了才能喝。&lt;/li&gt;
&lt;li&gt;开喝。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;PS: 个人觉得冰糖放得还是有点儿多，因为喝的时候觉得好甜啊，连室友也说太甜了…下次我要试试不放冰糖，看看是不是真的很影响口感~&lt;/p&gt;
&lt;p&gt;以上，谢谢观看~&lt;/p&gt;
    
    </summary>
    
      <category term="Skills" scheme="http://tankcat2.com/categories/Skills/"/>
    
    
      <category term="焦糖奶茶" scheme="http://tankcat2.com/tags/%E7%84%A6%E7%B3%96%E5%A5%B6%E8%8C%B6/"/>
    
  </entry>
  
  <entry>
    <title>Martiderm安瓶使用感</title>
    <link href="http://tankcat2.com/2017/11/24/Martiderm/"/>
    <id>http://tankcat2.com/2017/11/24/Martiderm/</id>
    <published>2017-11-24T01:28:31.000Z</published>
    <updated>2017-11-27T13:18:12.937Z</updated>
    
    <content type="html"><![CDATA[<p>这又是一记安利~</p><p>先交代一下本人的肤质吧：</p><ol><li>初中开始长青春痘</li><li>高中不懂事，乱扣红肿痘痘，导致右脸比较深的痘印</li><li>前两年断断续续吃过维安脂和泰尔斯，现在出油不严重，冬天甚至会有点干</li><li>目前下巴仍然会长痘痘，以红肿为主，闭口很少；下巴以上部位不怎么长</li></ol><p>总结一句话，就是<strong>混油痘肌</strong>。</p><p>半个月前左右我抱着尝试的心理买了Martiderm家的安瓶，<strong>臻活</strong>和<strong>平衡</strong>系列各五只，我的目的很明确，祛痘印+提亮肤色。</p><p>臻活系列貌似是价格最高的，浓度和粘稠度也是，这个我是睡前用；平衡系列是早上用，没有臻活那么黏。这两个我都是两天之内用完一瓶，一开始我是先用<strong>伊索的绿茶水和无油保湿精华</strong>打个底，后来嫌麻烦，就直接把安瓶和无油保湿精华混在一起抹了，吸收挺快的。</p><p>可能是刚开始用的时候不耐受，加上我没控制好量，涂的有点多，导致不论是睡醒还是白天一天下来，都觉得自己脸色暗沉，毛孔更大….但是！从前天早上开始，我发现脸上干净了好多，下巴上的痘痘痘印(除红肿外)淡了不少，关键是毛孔小了！看来这个安瓶在微博上风很大是有道理的！现在快用完了，打算入手一个全套装~价格好像更划算~</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这又是一记安利~&lt;/p&gt;
&lt;p&gt;先交代一下本人的肤质吧：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初中开始长青春痘&lt;/li&gt;
&lt;li&gt;高中不懂事，乱扣红肿痘痘，导致右脸比较深的痘印&lt;/li&gt;
&lt;li&gt;前两年断断续续吃过维安脂和泰尔斯，现在出油不严重，冬天甚至会有点干&lt;/li&gt;
&lt;li&gt;目前下巴仍然会长痘痘，以红肿为主，闭口很少；下巴以上部位不怎么长&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总结一句话，就是&lt;strong&gt;混油痘肌&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;半个月前左右我抱着尝试的心理买了Martiderm家的安瓶，&lt;strong&gt;臻活&lt;/strong&gt;和&lt;strong&gt;平衡&lt;/strong&gt;系列各五只，我的目的很明确，祛痘印+提亮肤色。&lt;/p&gt;
&lt;p&gt;臻活系列貌似是价格最高的，浓度和粘稠度也是，这个我是睡前用；平衡系列是早上用，没有臻活那么黏。这两个我都是两天之内用完一瓶，一开始我是先用&lt;strong&gt;伊索的绿茶水和无油保湿精华&lt;/strong&gt;打个底，后来嫌麻烦，就直接把安瓶和无油保湿精华混在一起抹了，吸收挺快的。&lt;/p&gt;
&lt;p&gt;可能是刚开始用的时候不耐受，加上我没控制好量，涂的有点多，导致不论是睡醒还是白天一天下来，都觉得自己脸色暗沉，毛孔更大….但是！从前天早上开始，我发现脸上干净了好多，下巴上的痘痘痘印(除红肿外)淡了不少，关键是毛孔小了！看来这个安瓶在微博上风很大是有道理的！现在快用完了，打算入手一个全套装~价格好像更划算~&lt;/p&gt;
    
    </summary>
    
      <category term="Jottings" scheme="http://tankcat2.com/categories/Jottings/"/>
    
    
      <category term="护肤" scheme="http://tankcat2.com/tags/%E6%8A%A4%E8%82%A4/"/>
    
      <category term="安瓶" scheme="http://tankcat2.com/tags/%E5%AE%89%E7%93%B6/"/>
    
      <category term="Martiderm" scheme="http://tankcat2.com/tags/Martiderm/"/>
    
  </entry>
  
  <entry>
    <title>视频导出音频小技能</title>
    <link href="http://tankcat2.com/2017/11/22/ffmped/"/>
    <id>http://tankcat2.com/2017/11/22/ffmped/</id>
    <published>2017-11-22T02:44:51.000Z</published>
    <updated>2017-11-27T13:24:11.915Z</updated>
    
    <content type="html"><![CDATA[<p>早上看到青峰发的新作品小视频，就想把它down下来，于是找到了一个很实用的chrome插件——video download helper。</p><p>视频下载下来了，又想提取音频，这样上传到我的网易云网盘就能随时听啦。一开始不太想装国产的转换软件，发现了一个在线的转换平台——<a href="http://audio-extractor.net/cn/" target="_blank" rel="noopener">http://audio-extractor.net/cn/</a>，需要先上传视频，再点击转换，最后再下载音频。</p><p>视频上传实在是太慢了！于是乎我又去知乎上搜搜看有没有大神提供一些轻量级的软件~果不其然，让我发现了FFmpeg的存在！<a href="http://ffmpeg.org/" target="_blank" rel="noopener">http://ffmpeg.org/ </a>这个是homepage，支持Linux/Windows/OS X。下载好压缩包后解压，然后把bin目录添加到环境变量中去就能愉快地使用啦~</p><p>我是把MP4转换成MP3，在别人的博客里找到了下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i video.mp4 -vn-acodec libmp3lame -ac 2 -qscale:a 4 -ar 48000audio.mp3</span><br></pre></td></tr></table></figure><p>以上，谢谢阅读。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;早上看到青峰发的新作品小视频，就想把它down下来，于是找到了一个很实用的chrome插件——video download helper。&lt;/p&gt;
&lt;p&gt;视频下载下来了，又想提取音频，这样上传到我的网易云网盘就能随时听啦。一开始不太想装国产的转换软件，发现了一个在线的转换平台——&lt;a href=&quot;http://audio-extractor.net/cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://audio-extractor.net/cn/&lt;/a&gt;，需要先上传视频，再点击转换，最后再下载音频。&lt;/p&gt;
&lt;p&gt;视频上传实在是太慢了！于是乎我又去知乎上搜搜看有没有大神提供一些轻量级的软件~果不其然，让我发现了FFmpeg的存在！&lt;a href=&quot;http://ffmpeg.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://ffmpeg.org/ &lt;/a&gt;这个是homepage，支持Linux/Windows/OS X。下载好压缩包后解压，然后把bin目录添加到环境变量中去就能愉快地使用啦~&lt;/p&gt;
&lt;p&gt;我是把MP4转换成MP3，在别人的博客里找到了下面的命令：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ffmpeg -i video.mp4 -vn-acodec libmp3lame -ac 2 -qscale:a 4 -ar 48000audio.mp3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上，谢谢阅读。&lt;/p&gt;
    
    </summary>
    
      <category term="Skills" scheme="http://tankcat2.com/categories/Skills/"/>
    
    
      <category term="ffmpeg" scheme="http://tankcat2.com/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>鼓楼半日记</title>
    <link href="http://tankcat2.com/2017/08/15/gulou/"/>
    <id>http://tankcat2.com/2017/08/15/gulou/</id>
    <published>2017-08-15T12:11:31.000Z</published>
    <updated>2017-11-27T13:23:57.620Z</updated>
    
    <content type="html"><![CDATA[<p>今天跟着zf去鼓楼的办公室，发现大门口右手边就是云南路地铁站口，右拐过去就是上海路。想到小厨娘就在附近，决定扔下zf一个人去买蛋糕。不知道怎么想的，可能天不热，没骑车步行过去的。以前步行只知道跟着导航急匆匆地赶到目的地，不在意沿途的风景。今天边走变看，走着走着就看到了最喜欢吃的朱师傅梅花糕。以前领过很多人来吃，都是跟着导航走，今天无意间走到，感觉很奇妙。上海路起起伏伏，回来骑车的时候感觉更明显。从上海路拐进广州路，人越来越多，后来发现是到了儿童医院。最后终于找到小厨娘，被告知想吃的抹茶盒子下午两点才有，说好的要芒果班戟，回来一吃发现拿的是榴莲。</p><p>快到办公室的时候开始下雷阵雨，快去跑回去，没过一会儿雨就停了。两个人中午商量着吃什么，其实这个商圈好吃的很多，韩料啦，串串啦，西餐啦，大众点评上好多评分高的店铺。但是雨停了之后太阳出来了，有点热，两个人都不太想吃辣的，于是就索性吃了鸡鸣汤包。上次去还是清明节。去的路上无意间看到一家小咖啡店，发现店家品味跟我一样哈，竟然想起来用伊索的瓶子插花。<br><a id="more"></a><br><img src="http://7xwggp.com1.z0.glb.clouddn.com/yisuo.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天跟着zf去鼓楼的办公室，发现大门口右手边就是云南路地铁站口，右拐过去就是上海路。想到小厨娘就在附近，决定扔下zf一个人去买蛋糕。不知道怎么想的，可能天不热，没骑车步行过去的。以前步行只知道跟着导航急匆匆地赶到目的地，不在意沿途的风景。今天边走变看，走着走着就看到了最喜欢吃的朱师傅梅花糕。以前领过很多人来吃，都是跟着导航走，今天无意间走到，感觉很奇妙。上海路起起伏伏，回来骑车的时候感觉更明显。从上海路拐进广州路，人越来越多，后来发现是到了儿童医院。最后终于找到小厨娘，被告知想吃的抹茶盒子下午两点才有，说好的要芒果班戟，回来一吃发现拿的是榴莲。&lt;/p&gt;
&lt;p&gt;快到办公室的时候开始下雷阵雨，快去跑回去，没过一会儿雨就停了。两个人中午商量着吃什么，其实这个商圈好吃的很多，韩料啦，串串啦，西餐啦，大众点评上好多评分高的店铺。但是雨停了之后太阳出来了，有点热，两个人都不太想吃辣的，于是就索性吃了鸡鸣汤包。上次去还是清明节。去的路上无意间看到一家小咖啡店，发现店家品味跟我一样哈，竟然想起来用伊索的瓶子插花。&lt;br&gt;
    
    </summary>
    
      <category term="Jottings" scheme="http://tankcat2.com/categories/Jottings/"/>
    
    
  </entry>
  
  <entry>
    <title>Tragic Ending or Peace Ending ?</title>
    <link href="http://tankcat2.com/2017/07/21/my%20chester/"/>
    <id>http://tankcat2.com/2017/07/21/my chester/</id>
    <published>2017-07-20T16:00:00.000Z</published>
    <updated>2017-11-27T13:17:58.461Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>那个一直嘶吼的他走了，在很多人的青春中躁动的声音消失了，这个世界总是留不住想要留住的人….</p></blockquote><p>收拾好准备出宿舍门的时候，打开朋友圈，看到有好友转发西菇自杀了，晴天霹雳。</p><p>各大媒体、社交平台都开始报道这个消息，朋友圈也开始各种转发，大家明明都还沉浸在新收到的新单mv的推送中，可他就这么离开了。</p><p>有的人可能只知道lol登陆界面上的numb，有的人可能是变形金刚的bgm what i’ve done，new divide和iridescent而知道linkin park，有的人可能是因为今天的朋友圈被告知有个乐队的主场自杀了。高三一次月考作文我就以西菇为题材，写了他从悲惨的童年到获得如今的成就，写了他的纹身，他的耳洞，他的嗓音转变，他的专辑，他的这条路到底是有多心酸、坚强与挣扎。他的作品获得了无数粉丝的喜爱，无疑他的作品来源于悲惨的童年经历，但这段经历如今又带走了他的生命，这些因果到底是矛盾的。</p><p>西菇的自杀让我想到台湾女作家林奕含，一样是童年被x侵，一样是在作品中透露出自己的无奈和无助，他们感受到的痛苦是真真切切的。可能在挣扎中想要积极向上，也确实创造了许多作品激励并拯救了许多同样饱受苦痛折磨的人，但喧嚣与欢乐始终都是别人的，音乐只是病痛的舒缓剂，不是所有的经历都能云淡风轻地过去，有些事每每回想，总是锥心地痛一次。时间不是万能的，抑郁的人自杀也不是矫情。</p><p>他的死对至亲和粉丝来说无疑是悲惨的结局，但他的前半生可能一直在寻找somewhere i belong，而今日凌晨，他找到了。</p><p>I wanna let go of the pain I’ve felt so long…</p><p>somewhere i belong…</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;那个一直嘶吼的他走了，在很多人的青春中躁动的声音消失了，这个世界总是留不住想要留住的人….&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;收拾好准备出宿舍门的时候，打开朋友圈，看到有好友转发西菇自杀了，晴天霹雳。&lt;/p&gt;
&lt;p&gt;各大媒体、社交平台都开始报道这个消息，朋友圈也开始各种转发，大家明明都还沉浸在新收到的新单mv的推送中，可他就这么离开了。&lt;/p&gt;
&lt;p&gt;有的人可能只知道lol登陆界面上的numb，有的人可能是变形金刚的bgm what i’ve done，new divide和iridescent而知道linkin park，有的人可能是因为今天的朋友圈被告知有个乐队的主场自杀了。高三一次月考作文我就以西菇为题材，写了他从悲惨的童年到获得如今的成就，写了他的纹身，他的耳洞，他的嗓音转变，他的专辑，他的这条路到底是有多心酸、坚强与挣扎。他的作品获得了无数粉丝的喜爱，无疑他的作品来源于悲惨的童年经历，但这段经历如今又带走了他的生命，这些因果到底是矛盾的。&lt;/p&gt;
&lt;p&gt;西菇的自杀让我想到台湾女作家林奕含，一样是童年被x侵，一样是在作品中透露出自己的无奈和无助，他们感受到的痛苦是真真切切的。可能在挣扎中想要积极向上，也确实创造了许多作品激励并拯救了许多同样饱受苦痛折磨的人，但喧嚣与欢乐始终都是别人的，音乐只是病痛的舒缓剂，不是所有的经历都能云淡风轻地过去，有些事每每回想，总是锥心地痛一次。时间不是万能的，抑郁的人自杀也不是矫情。&lt;/p&gt;
&lt;p&gt;他的死对至亲和粉丝来说无疑是悲惨的结局，但他的前半生可能一直在寻找somewhere i belong，而今日凌晨，他找到了。&lt;/p&gt;
&lt;p&gt;I wanna let go of the pain I’ve felt so long…&lt;/p&gt;
&lt;p&gt;somewhere i belong…&lt;/p&gt;
    
    </summary>
    
      <category term="Jottings" scheme="http://tankcat2.com/categories/Jottings/"/>
    
    
      <category term="Linkin Park" scheme="http://tankcat2.com/tags/Linkin-Park/"/>
    
      <category term="Chester Bennington" scheme="http://tankcat2.com/tags/Chester-Bennington/"/>
    
  </entry>
  
  <entry>
    <title>Storm UI详解</title>
    <link href="http://tankcat2.com/2017/05/22/storm_ui/"/>
    <id>http://tankcat2.com/2017/05/22/storm_ui/</id>
    <published>2017-05-22T08:32:31.000Z</published>
    <updated>2017-11-27T13:08:44.357Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xwggp.com1.z0.glb.clouddn.com/storm_ui_config_summary.png" alt=""></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xwggp.com1.z0.glb.clouddn.com/storm_ui_config_summary.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Techniques" scheme="http://tankcat2.com/categories/Techniques/"/>
    
    
      <category term="Storm" scheme="http://tankcat2.com/tags/Storm/"/>
    
  </entry>
  
  <entry>
    <title>Storm Kafka之KafkaSpout</title>
    <link href="http://tankcat2.com/2017/05/18/KafkaSpout/"/>
    <id>http://tankcat2.com/2017/05/18/KafkaSpout/</id>
    <published>2017-05-18T12:11:31.000Z</published>
    <updated>2017-11-27T13:20:19.551Z</updated>
    
    <content type="html"><![CDATA[<p><code>storm-kafka-XXX.jar</code>提供了核心Storm与Trident的组件Spout的代码实现，用于消费Kafka中存储的数据(0.8.x之后的版本)。本文只介绍核心Storm的KafkaSpout。</p><p>对于核心Storm与Trident两个版本的Spout实现，提供了<code>BrokerHost</code>接口，跟踪Kafka broker host$\rightarrow$partition的映射，并提供<code>KafkaConfig</code>接口来控制Kafka相关的参数。下面就这以上两点进行讲解。</p><h3 id="BrokerHost"><a href="#BrokerHost" class="headerlink" title="BrokerHost"></a>BrokerHost</h3><p>为了对Kafka spout进行初始化，我们需要创建一个<code>BrokerHost</code>的实例，Storm共提供了两种实现方式：</p><ol><li><p>ZkHosts。ZkHosts使用Zookeeper的实体对象，可动态地追踪Kafka broker$\rightarrow$partition之间的映射，通过调用下面两种函数创建ZkHosts:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZkHosts</span><span class="params">(String brokerZkStr,String brokerZkPath)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZkHosts</span><span class="params">(String brokerZkStr)</span></span></span><br></pre></td></tr></table></figure><p>其中，<code>brokerZkStr</code>是<code>ip:host</code>(主机:端口)，<code>brokerZkPath</code>是存放所有topic和partition信息的根目录，默认值为<code>\broker</code>。默认地，Zookepper每60秒刷新一次broker$\rightarrow$partition，通过<code>host:refreshFreqSecs</code>可以改变这个时间。</p></li><li><p>StaticHosts。这是另一个选择，不过broker$\rightarrow$partition之间的映射关系是静态的，创建这个类的实例之前，需要首选创建<code>GlobalPartitionInformation</code>类的实例，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Broker brokerForPartition0 = <span class="keyword">new</span> Broker(<span class="string">"localhost"</span>);<span class="comment">//localhost:9092,端口号默认为9092</span></span><br><span class="line">Broker brokerForPartition1 = <span class="keyword">new</span> Broker(<span class="string">"localhost"</span>,<span class="number">9092</span>);<span class="comment">//localhost:9092,显示地指定端口号</span></span><br><span class="line">Broker brokerForPartition2 = <span class="keyword">new</span> Broker(<span class="string">"localhost:9092"</span>);</span><br><span class="line">GlobalPartitionInformation partitionInfo = <span class="keyword">new</span> GlobalPartitionInformation();</span><br><span class="line">partitionInfo.addPartition(<span class="number">0</span>, brokerFroPartition0);<span class="comment">// partition0 到 brokerForPartition0的映射</span></span><br><span class="line">partitionInfo.addPartition(<span class="number">1</span>, brokerFroPartition1);</span><br><span class="line">partitionInfo.addPartition(<span class="number">2</span>, brokerFroPartition2);</span><br><span class="line">StaticHosts hosts = <span class="keyword">new</span> StaticHosts(partitionInfo);</span><br></pre></td></tr></table></figure></li></ol><h3 id="KafkaConfig"><a href="#KafkaConfig" class="headerlink" title="KafkaConfig"></a>KafkaConfig</h3><p>创建KafkaSpout需要的另一个参数是<code>KafaConfig</code>，通过调用以下两个函数进行对象创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">KafkaConfig</span><span class="params">(BrokerHosts host,String topic)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">KafkaConfig</span><span class="params">(BrokerHosts host,String topic,String clientId)</span></span></span><br></pre></td></tr></table></figure><p>其中，<code>host</code>可以为BrokerHost的任何一种实现，<code>topic</code>是一个topic的名称，<code>clientId</code>是一个可选择的参数，作为Zookeeper路径的一部分，存储spout当前数据读取的offset。</p><p>目前，KafkaConfig有两种扩展形式，<code>SpoutcConfig</code>提供额外的Zookeeper连接的字段信息，用于控制KafkaSpout特定的行为。<code>zkRoot</code>用于存储consumer的offset，<code>id</code>用于唯一标识当前的spout。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpoutConfig</span><span class="params">(BrokerHosts hosts,String topic,String zkRoot,String id)</span></span></span><br></pre></td></tr></table></figure><p>除了以上参数，SpoutConfig包括如下的字段值，用来控制KafkaSpout：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将当前的offset保存到Zookeeper的频率</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">long</span> stateUpdateIntervals = <span class="number">2000</span>;</span><br><span class="line"><span class="comment">//用于失效消息的重试策略</span></span><br><span class="line"><span class="keyword">public</span> String failedMsgRetryManagerClass = ExponentialBackofMsgRetryManager.class.getName();</span><br><span class="line"><span class="comment">//指数级别的back-off重试设置。在一个bolt调用OutputCollector.fail()后，用于重新设置的ExponentialBackoffMsgRetryManager。只有在ExponentialBackoffMsgRetryManager被使用时，才有效果。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">long</span> retryInitialDetails = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">double</span> retryDelayMultiplier = <span class="number">1.0</span>;</span><br><span class="line"><span class="comment">//连续重试之间的最大延时</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">long</span> retryDelayMaxMs = <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line"><span class="comment">//当retryLimit低于0时，不停地重新发送失效的消息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> retryLimit = -<span class="number">1</span>;</span><br></pre></td></tr></table></figure><a id="more"></a><p>KafkaSpout只接收一个SpoutConfig的实例作为参数。</p><p>下面给出一个实例：</p><ol><li><p>首先创建一个名为<code>couple</code>的topic，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --create --zookeeper localhost:3030 --partitions 4 --replication-factor 1 --topic couple</span><br></pre></td></tr></table></figure></li><li><p>写一个简单的Producer，将文件<code>string_data.txt</code>的记录发送到<code>couple</code>中，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">kafkaFileProducer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String topic_name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String file_name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> KafkaProducer&lt;String,String&gt; producer;</span><br><span class="line">    <span class="keyword">private</span> Boolean isAsync;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">kafkaFileProducer</span><span class="params">(String topic_name,String file_name,Boolean isAsync)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.file_name=file_name;</span><br><span class="line">        <span class="keyword">this</span>.topic_name=topic_name;</span><br><span class="line">        Properties properties=<span class="keyword">new</span> Properties();</span><br><span class="line">        properties.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</span><br><span class="line">        properties.put(<span class="string">"client.id"</span>,<span class="string">"CoupleProducer"</span>);</span><br><span class="line">        properties.put(<span class="string">"key.serializer"</span>,<span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">        properties.put(<span class="string">"value.serializer"</span>,<span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">        producer=<span class="keyword">new</span> KafkaProducer&lt;String, String&gt;(properties);</span><br><span class="line">        <span class="keyword">this</span>.isAsync=isAsync;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String key,String value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start_time=System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">if</span>(isAsync)&#123;</span><br><span class="line">            producer.send(<span class="keyword">new</span> ProducerRecord&lt;String, String&gt;(topic_name,key),<span class="keyword">new</span> CoupleCallBack(start_time,key,value));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                producer.send(<span class="keyword">new</span> ProducerRecord&lt;String, String&gt;(topic_name,key,value)).get();</span><br><span class="line">                System.out.println(<span class="string">"Sent message : ( "</span>+key+<span class="string">" , "</span>+value+<span class="string">" )"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String file_name=<span class="string">"DataSource/Data/string_data.txt"</span>;</span><br><span class="line">        String topic_name=<span class="string">"couple"</span>;</span><br><span class="line">        kafkaFileProducer producer=<span class="keyword">new</span> kafkaFileProducer(topic_name,file_name,<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> lineCount=<span class="number">0</span>;</span><br><span class="line">        FileInputStream fis=<span class="keyword">null</span>;</span><br><span class="line">        BufferedReader br=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis=<span class="keyword">new</span> FileInputStream(file_name);</span><br><span class="line">            br=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(fis));</span><br><span class="line">            String line=<span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span>((line=br.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                lineCount++;</span><br><span class="line">                producer.sendMessage(lineCount+<span class="string">""</span>,line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CoupleCallBack</span> <span class="keyword">implements</span> <span class="title">Callback</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> start_time;</span><br><span class="line">        <span class="keyword">private</span> String key;</span><br><span class="line">        <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CoupleCallBack</span><span class="params">(<span class="keyword">long</span> start_time, String key, String message)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.start_time = start_time;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.message = message;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            A callback method</span></span><br><span class="line"><span class="comment">            The user can implement to provide asynchronous handling of request completion.</span></span><br><span class="line"><span class="comment">            The method will be called when the record sent to the server has been acknowledged.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompletion</span><span class="params">(RecordMetadata recordMetadata, Exception e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> elapsed_time=System.currentTimeMillis()-start_time;</span><br><span class="line">            <span class="keyword">if</span>(recordMetadata!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"Message( "</span>+key+<span class="string">" , "</span>+ message+<span class="string">" ) sent to partition("</span>+recordMetadata.partition()+<span class="string">" ) , offset("</span> +recordMetadata.offset()+<span class="string">" ) in "</span>+elapsed_time+<span class="string">" ms"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写一个简单的Storm Topology，利用KafkaSpout读取couple中的数据(一条条的句子)，并分割成一个个的单词，统计单词个数，如下：</p><ul><li><p>SplitSentenceBolt</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SplitSentenceBolt</span> <span class="keyword">extends</span> <span class="title">BaseBasicBolt</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple tuple, BasicOutputCollector basicOutputCollector)</span> </span>&#123;</span><br><span class="line">        String sentence=tuple.getStringByField(<span class="string">"msg"</span>);</span><br><span class="line">        System.out.println(tuple.getSourceTask()+<span class="string">":"</span>+sentence);</span><br><span class="line">        String[] words=sentence.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span>(String word:words)&#123;</span><br><span class="line">            basicOutputCollector.emit(<span class="keyword">new</span> Values(word));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer outputFieldsDeclarer)</span> </span>&#123;</span><br><span class="line">        outputFieldsDeclarer.declare(<span class="keyword">new</span> Fields(<span class="string">"word"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>WordCountBolt</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountBolt</span> <span class="keyword">extends</span> <span class="title">BaseBasicBolt</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Long&gt; counts=<span class="keyword">null</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(Map conf,TopologyContext context)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.counts=<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">super</span>.prepare(conf,context);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple tuple, BasicOutputCollector basicOutputCollector)</span> </span>&#123;</span><br><span class="line">        String word=tuple.getStringByField(<span class="string">"word"</span>);</span><br><span class="line">        Long count=<span class="keyword">this</span>.counts.get(word);</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="keyword">null</span>)</span><br><span class="line">            count=<span class="number">0L</span>;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">this</span>.counts.put(word,count);</span><br><span class="line">        basicOutputCollector.emit(<span class="keyword">new</span> Values(word,count));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer outputFieldsDeclarer)</span> </span>&#123;</span><br><span class="line">        outputFieldsDeclarer.declare(<span class="keyword">new</span> Fields(<span class="string">"word"</span>,<span class="string">"count"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ReportBolt</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReportBolt</span> <span class="keyword">extends</span> <span class="title">BaseBasicBolt</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple tuple, BasicOutputCollector basicOutputCollector)</span> </span>&#123;</span><br><span class="line">        String word=tuple.getStringByField(<span class="string">"word"</span>);</span><br><span class="line">        Long count=tuple.getLongByField(<span class="string">"count"</span>);</span><br><span class="line">        String reportMsg=<span class="string">"&#123; word : "</span>+word+<span class="string">" , count : "</span>+count+<span class="string">" &#125;"</span>;</span><br><span class="line">        basicOutputCollector.emit(<span class="keyword">new</span> Values(reportMsg));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer outputFieldsDeclarer)</span> </span>&#123;</span><br><span class="line">        outputFieldsDeclarer.declare(<span class="keyword">new</span> Fields(<span class="string">"message"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>KafkaWordCountTopology</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountKafkaTopology</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KAFKA_SPOUT_ID=<span class="string">"kafka-spout"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SPLIT_BOLT_ID=<span class="string">"split-bolt"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String WORD_COUNT_BOLT_ID=<span class="string">"word-count-bolt"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REPORT_BOLT_ID=<span class="string">"report-bolt"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONSUME_TOPIC=<span class="string">"couple"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PRODUCT_TOPIC=<span class="string">"test"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ZK_ROOT=<span class="string">"/couple"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ZK_ID=<span class="string">"wordcount"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOPOLOGY_NAME=<span class="string">"word-count-topology"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        BrokerHosts brokerHosts=<span class="keyword">new</span> ZkHosts(<span class="string">"192.168.1.118:3030"</span>);</span><br><span class="line">        SpoutConfig spoutConfig=<span class="keyword">new</span> SpoutConfig(brokerHosts,CONSUME_TOPIC,ZK_ROOT,ZK_ID);</span><br><span class="line"></span><br><span class="line">        spoutConfig.scheme = <span class="keyword">new</span> SchemeAsMultiScheme(<span class="keyword">new</span> MessageScheme());</span><br><span class="line"></span><br><span class="line">        TopologyBuilder builder=<span class="keyword">new</span> TopologyBuilder();</span><br><span class="line">        builder.setSpout(KAFKA_SPOUT_ID,<span class="keyword">new</span> KafkaSpout(spoutConfig),<span class="number">3</span>);<span class="comment">//需要注意的是，spout的并行度不能超过topic的partition个数！</span></span><br><span class="line">        builder.setBolt(SPLIT_BOLT_ID,<span class="keyword">new</span> SplitSentenceBolt(),<span class="number">1</span>).shuffleGrouping(KAFKA_SPOUT_ID);</span><br><span class="line">        builder.setBolt(WORD_COUNT_BOLT_ID,<span class="keyword">new</span> WordCountBolt()).fieldsGrouping(SPLIT_BOLT_ID,<span class="keyword">new</span> Fields(<span class="string">"word"</span>));</span><br><span class="line">        builder.setBolt(REPORT_BOLT_ID,<span class="keyword">new</span> ReportBolt()).shuffleGrouping(WORD_COUNT_BOLT_ID);</span><br><span class="line">        <span class="comment">//builder.setBolt(KAFKA_BOLT_ID,new KafkaBolt&lt;String,Long&gt;()).shuffleGrouping(REPORT_BOLT_ID);</span></span><br><span class="line"></span><br><span class="line">        Config config=<span class="keyword">new</span> Config();</span><br><span class="line">        Map&lt;String,String&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//map.put("metadata.broker.list", "localhost:9092");</span></span><br><span class="line">        map.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</span><br><span class="line">    map.put(<span class="string">"serializer.class"</span>,<span class="string">"kafka.serializer.StringEncoder"</span>);</span><br><span class="line">        config.put(<span class="string">"kafka.broker.properties"</span>,map);</span><br><span class="line">        config.setNumWorkers(<span class="number">3</span>);</span><br><span class="line">      </span><br><span class="line">        LocalCluster cluster=<span class="keyword">new</span> LocalCluster();</span><br><span class="line"> cluster.submitTopology(TOPOLOGY_NAME,config,builder.createTopology());</span><br><span class="line">        Utils.sleep(<span class="number">10000</span>);</span><br><span class="line">        cluster.killTopology(TOPOLOGY_NAME);</span><br><span class="line">        cluster.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;storm-kafka-XXX.jar&lt;/code&gt;提供了核心Storm与Trident的组件Spout的代码实现，用于消费Kafka中存储的数据(0.8.x之后的版本)。本文只介绍核心Storm的KafkaSpout。&lt;/p&gt;
&lt;p&gt;对于核心Storm与Trident两个版本的Spout实现，提供了&lt;code&gt;BrokerHost&lt;/code&gt;接口，跟踪Kafka broker host$\rightarrow$partition的映射，并提供&lt;code&gt;KafkaConfig&lt;/code&gt;接口来控制Kafka相关的参数。下面就这以上两点进行讲解。&lt;/p&gt;
&lt;h3 id=&quot;BrokerHost&quot;&gt;&lt;a href=&quot;#BrokerHost&quot; class=&quot;headerlink&quot; title=&quot;BrokerHost&quot;&gt;&lt;/a&gt;BrokerHost&lt;/h3&gt;&lt;p&gt;为了对Kafka spout进行初始化，我们需要创建一个&lt;code&gt;BrokerHost&lt;/code&gt;的实例，Storm共提供了两种实现方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;ZkHosts。ZkHosts使用Zookeeper的实体对象，可动态地追踪Kafka broker$\rightarrow$partition之间的映射，通过调用下面两种函数创建ZkHosts:&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ZkHosts&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String brokerZkStr,String brokerZkPath)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ZkHosts&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String brokerZkStr)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中，&lt;code&gt;brokerZkStr&lt;/code&gt;是&lt;code&gt;ip:host&lt;/code&gt;(主机:端口)，&lt;code&gt;brokerZkPath&lt;/code&gt;是存放所有topic和partition信息的根目录，默认值为&lt;code&gt;\broker&lt;/code&gt;。默认地，Zookepper每60秒刷新一次broker$\rightarrow$partition，通过&lt;code&gt;host:refreshFreqSecs&lt;/code&gt;可以改变这个时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;StaticHosts。这是另一个选择，不过broker$\rightarrow$partition之间的映射关系是静态的，创建这个类的实例之前，需要首选创建&lt;code&gt;GlobalPartitionInformation&lt;/code&gt;类的实例，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Broker brokerForPartition0 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Broker(&lt;span class=&quot;string&quot;&gt;&quot;localhost&quot;&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//localhost:9092,端口号默认为9092&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Broker brokerForPartition1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Broker(&lt;span class=&quot;string&quot;&gt;&quot;localhost&quot;&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;9092&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//localhost:9092,显示地指定端口号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Broker brokerForPartition2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Broker(&lt;span class=&quot;string&quot;&gt;&quot;localhost:9092&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;GlobalPartitionInformation partitionInfo = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; GlobalPartitionInformation();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;partitionInfo.addPartition(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, brokerFroPartition0);&lt;span class=&quot;comment&quot;&gt;// partition0 到 brokerForPartition0的映射&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;partitionInfo.addPartition(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, brokerFroPartition1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;partitionInfo.addPartition(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, brokerFroPartition2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;StaticHosts hosts = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; StaticHosts(partitionInfo);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;KafkaConfig&quot;&gt;&lt;a href=&quot;#KafkaConfig&quot; class=&quot;headerlink&quot; title=&quot;KafkaConfig&quot;&gt;&lt;/a&gt;KafkaConfig&lt;/h3&gt;&lt;p&gt;创建KafkaSpout需要的另一个参数是&lt;code&gt;KafaConfig&lt;/code&gt;，通过调用以下两个函数进行对象创建：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;KafkaConfig&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(BrokerHosts host,String topic)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;KafkaConfig&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(BrokerHosts host,String topic,String clientId)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中，&lt;code&gt;host&lt;/code&gt;可以为BrokerHost的任何一种实现，&lt;code&gt;topic&lt;/code&gt;是一个topic的名称，&lt;code&gt;clientId&lt;/code&gt;是一个可选择的参数，作为Zookeeper路径的一部分，存储spout当前数据读取的offset。&lt;/p&gt;
&lt;p&gt;目前，KafkaConfig有两种扩展形式，&lt;code&gt;SpoutcConfig&lt;/code&gt;提供额外的Zookeeper连接的字段信息，用于控制KafkaSpout特定的行为。&lt;code&gt;zkRoot&lt;/code&gt;用于存储consumer的offset，&lt;code&gt;id&lt;/code&gt;用于唯一标识当前的spout。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SpoutConfig&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(BrokerHosts hosts,String topic,String zkRoot,String id)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;除了以上参数，SpoutConfig包括如下的字段值，用来控制KafkaSpout：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//将当前的offset保存到Zookeeper的频率&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; stateUpdateIntervals = &lt;span class=&quot;number&quot;&gt;2000&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//用于失效消息的重试策略&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; String failedMsgRetryManagerClass = ExponentialBackofMsgRetryManager.class.getName();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//指数级别的back-off重试设置。在一个bolt调用OutputCollector.fail()后，用于重新设置的ExponentialBackoffMsgRetryManager。只有在ExponentialBackoffMsgRetryManager被使用时，才有效果。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; retryInitialDetails = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; retryDelayMultiplier = &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//连续重试之间的最大延时&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; retryDelayMaxMs = &lt;span class=&quot;number&quot;&gt;60&lt;/span&gt; * &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//当retryLimit低于0时，不停地重新发送失效的消息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; retryLimit = -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Techniques" scheme="http://tankcat2.com/categories/Techniques/"/>
    
    
      <category term="Kafka" scheme="http://tankcat2.com/tags/Kafka/"/>
    
      <category term="Storm" scheme="http://tankcat2.com/tags/Storm/"/>
    
  </entry>
  
  <entry>
    <title>列存储中常见压缩技术</title>
    <link href="http://tankcat2.com/2017/05/11/compression/"/>
    <id>http://tankcat2.com/2017/05/11/compression/</id>
    <published>2017-05-11T05:40:00.000Z</published>
    <updated>2017-11-27T13:25:45.231Z</updated>
    
    <content type="html"><![CDATA[<p>在列数据库中，实用面向列的压缩算法进行数据压缩，并且在处理数据时保持压缩的形式，即不通过解压来处理数据，很大程度上提升了查询性能.凭直觉就能知道，以列为存储形式的数据比以行为存储形式的数据更容易压缩.当处理的数据信息熵较低，即数据的局部性较高，那么压缩算法的性能越好.举个列子来说吧，现在有一张顾客表，包含了[姓名，电话，邮箱，传真]等属性.列存储使得所有的姓名存储在一起，所有的电话号码存储在一起.有一点可以确定的是，电话号码各自之间是要比周围其他属性的数值来得更加相似的.</p><p><strong>压缩的优势具体是什么呢？</strong>总结起来呢有两点：</p><ol><li>减少I/O操作次数.如果数据被压缩了，那么其实一次I/O读取(磁盘到内存/CPU)实际对应的源数据是远远超过不使用压缩技术的读取.</li><li>提高查询性能.如果查询执行器可以直接在压缩后的数据上进行操作，在进行具体的操作时不需要进行解压，而这个操作一般开销较大.</li></ol><p>列存储的压缩技术一般有消零和空格符算法(Null Supression)、Lerrpel-Ziv算法、词典编码算法(Dictionary Encoding)、行程编码算法(Run-length Encoding)、位向量算法(Bit-Vector Encoding)，其中较为常见的是后三种，接下来也重点介绍这三种.</p><h3 id="行程编码-Run-length-Encoding"><a href="#行程编码-Run-length-Encoding" class="headerlink" title="行程编码 Run-length Encoding"></a>行程编码 Run-length Encoding</h3><p>行程编码的核心思想是将有序列中的相同元素转化成一个三元组&lt;属性值，该值第一次出现的位置，出现的次数&gt;,适用于有序的列或者可转为有序的列.下面给出一个具体的例子.下图给出一个身高的有序列，使用行程编码，可转化为两个三元组.为了便于管理，可以在三元组上构建索引.需要注意的是，该算法比较适合distinct值较少的列，因为如果列中不同的值较多，比如所有的值都不同，那么创建的三元组的数量就会很大，施展不出该算法的优势.</p><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/run_length.png" alt=""></p><h3 id="位向量-Bit-Vector"><a href="#位向量-Bit-Vector" class="headerlink" title="位向量 Bit-Vector"></a>位向量 Bit-Vector</h3><p>位向量的核心思想是，将一个列中相同的值转为一个二元组&lt;属性值，在列中出现的位置的位图&gt;.下面给出一个简单的例子，图中给出的列是无序的，其中160这个值出现在第0、3、4、6个位置，162出现在第1、2、5个位置，则其位图的表示分别是1001101和0110010.使用该算法，整个列只要用两个简单的二元组就能表示出来.若列中distinct的值较少，则位图还可以用行程编码进行二次压缩.</p><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/bit_vector.png" alt=""></p><h3 id="词典编码-Dictionary-Encoding"><a href="#词典编码-Dictionary-Encoding" class="headerlink" title="词典编码 Dictionary Encoding"></a>词典编码 Dictionary Encoding</h3><p>词典编码，顾名思义，主要针对的是字符串的压缩，核心思想是利用简短的编码代替列中某些重复出现的字符串，维护一个字符串与编码的映射，就可以快速确定编码所指代的字符串，这个映射也就是所谓的Dictionary.下面给出12年Google在VLDB论文<a href="http://dl.acm.org/citation.cfm?id=2350259&amp;CFID=761347277&amp;CFTOKEN=44019228" target="_blank" rel="noopener">Processing a trillion cells per mouse click</a>上有关这个算法的例子，将列search_string划分为三个块，每个块中都存在重复的字符串。首先创建一个全局的字典表global_dictionary，该表中包含了search_string中的所有distinct字符串，且每个字符串分配一个全局唯一的id.接着，为每个块也创建一个字典表chunk_dictionary，包含在该块中的所有distinct字符串，为每个字符串分配一个块范围内的id，并且将这个id与该字符串的全局id对应起来，通过这种二级字典表的方式，一个字符串就可以通过全局字典表映射到一个全局id，再通过块字典表映射到一个块id，这样快中就不用再存储真正的字符串了，而是字符串对应的块id，也就是图中的elements.例如要查找chunk 0中第4个element对应的字符串时，找到该element对应的块id是4，对应的全局id是12，再查找全局字典表可知，该element对应字符串”yellow pages”.同样该算法适用于列中distinct字符串较少的情况.</p><a id="more"></a><p><img src="http://7xwggp.com1.z0.glb.clouddn.com/dictionary_encoding.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在列数据库中，实用面向列的压缩算法进行数据压缩，并且在处理数据时保持压缩的形式，即不通过解压来处理数据，很大程度上提升了查询性能.凭直觉就能知道，以列为存储形式的数据比以行为存储形式的数据更容易压缩.当处理的数据信息熵较低，即数据的局部性较高，那么压缩算法的性能越好.举个列子来说吧，现在有一张顾客表，包含了[姓名，电话，邮箱，传真]等属性.列存储使得所有的姓名存储在一起，所有的电话号码存储在一起.有一点可以确定的是，电话号码各自之间是要比周围其他属性的数值来得更加相似的.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;压缩的优势具体是什么呢？&lt;/strong&gt;总结起来呢有两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;减少I/O操作次数.如果数据被压缩了，那么其实一次I/O读取(磁盘到内存/CPU)实际对应的源数据是远远超过不使用压缩技术的读取.&lt;/li&gt;
&lt;li&gt;提高查询性能.如果查询执行器可以直接在压缩后的数据上进行操作，在进行具体的操作时不需要进行解压，而这个操作一般开销较大.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;列存储的压缩技术一般有消零和空格符算法(Null Supression)、Lerrpel-Ziv算法、词典编码算法(Dictionary Encoding)、行程编码算法(Run-length Encoding)、位向量算法(Bit-Vector Encoding)，其中较为常见的是后三种，接下来也重点介绍这三种.&lt;/p&gt;
&lt;h3 id=&quot;行程编码-Run-length-Encoding&quot;&gt;&lt;a href=&quot;#行程编码-Run-length-Encoding&quot; class=&quot;headerlink&quot; title=&quot;行程编码 Run-length Encoding&quot;&gt;&lt;/a&gt;行程编码 Run-length Encoding&lt;/h3&gt;&lt;p&gt;行程编码的核心思想是将有序列中的相同元素转化成一个三元组&amp;lt;属性值，该值第一次出现的位置，出现的次数&amp;gt;,适用于有序的列或者可转为有序的列.下面给出一个具体的例子.下图给出一个身高的有序列，使用行程编码，可转化为两个三元组.为了便于管理，可以在三元组上构建索引.需要注意的是，该算法比较适合distinct值较少的列，因为如果列中不同的值较多，比如所有的值都不同，那么创建的三元组的数量就会很大，施展不出该算法的优势.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xwggp.com1.z0.glb.clouddn.com/run_length.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;位向量-Bit-Vector&quot;&gt;&lt;a href=&quot;#位向量-Bit-Vector&quot; class=&quot;headerlink&quot; title=&quot;位向量 Bit-Vector&quot;&gt;&lt;/a&gt;位向量 Bit-Vector&lt;/h3&gt;&lt;p&gt;位向量的核心思想是，将一个列中相同的值转为一个二元组&amp;lt;属性值，在列中出现的位置的位图&amp;gt;.下面给出一个简单的例子，图中给出的列是无序的，其中160这个值出现在第0、3、4、6个位置，162出现在第1、2、5个位置，则其位图的表示分别是1001101和0110010.使用该算法，整个列只要用两个简单的二元组就能表示出来.若列中distinct的值较少，则位图还可以用行程编码进行二次压缩.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xwggp.com1.z0.glb.clouddn.com/bit_vector.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;词典编码-Dictionary-Encoding&quot;&gt;&lt;a href=&quot;#词典编码-Dictionary-Encoding&quot; class=&quot;headerlink&quot; title=&quot;词典编码 Dictionary Encoding&quot;&gt;&lt;/a&gt;词典编码 Dictionary Encoding&lt;/h3&gt;&lt;p&gt;词典编码，顾名思义，主要针对的是字符串的压缩，核心思想是利用简短的编码代替列中某些重复出现的字符串，维护一个字符串与编码的映射，就可以快速确定编码所指代的字符串，这个映射也就是所谓的Dictionary.下面给出12年Google在VLDB论文&lt;a href=&quot;http://dl.acm.org/citation.cfm?id=2350259&amp;amp;CFID=761347277&amp;amp;CFTOKEN=44019228&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Processing a trillion cells per mouse click&lt;/a&gt;上有关这个算法的例子，将列search_string划分为三个块，每个块中都存在重复的字符串。首先创建一个全局的字典表global_dictionary，该表中包含了search_string中的所有distinct字符串，且每个字符串分配一个全局唯一的id.接着，为每个块也创建一个字典表chunk_dictionary，包含在该块中的所有distinct字符串，为每个字符串分配一个块范围内的id，并且将这个id与该字符串的全局id对应起来，通过这种二级字典表的方式，一个字符串就可以通过全局字典表映射到一个全局id，再通过块字典表映射到一个块id，这样快中就不用再存储真正的字符串了，而是字符串对应的块id，也就是图中的elements.例如要查找chunk 0中第4个element对应的字符串时，找到该element对应的块id是4，对应的全局id是12，再查找全局字典表可知，该element对应字符串”yellow pages”.同样该算法适用于列中distinct字符串较少的情况.&lt;/p&gt;
    
    </summary>
    
      <category term="Techniques" scheme="http://tankcat2.com/categories/Techniques/"/>
    
    
      <category term="压缩" scheme="http://tankcat2.com/tags/%E5%8E%8B%E7%BC%A9/"/>
    
      <category term="行程编码" scheme="http://tankcat2.com/tags/%E8%A1%8C%E7%A8%8B%E7%BC%96%E7%A0%81/"/>
    
      <category term="词典编码" scheme="http://tankcat2.com/tags/%E8%AF%8D%E5%85%B8%E7%BC%96%E7%A0%81/"/>
    
      <category term="位向量" scheme="http://tankcat2.com/tags/%E4%BD%8D%E5%90%91%E9%87%8F/"/>
    
  </entry>
  
</feed>
