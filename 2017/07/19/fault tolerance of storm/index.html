<!DOCTYPE html>
<html lang=en>
<head>
	<link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css">
	<link rel="stylesheet" type="text/css" href="css/comment.css">    
    <meta charset="utf-8">
    
    <title>Storm的容错 | Tankcat</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    

    

    
        <link rel="shortcut icon" href="/css/images/favicon.ico" />
    
	
    <link rel="stylesheet" href="/vendor/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/vendor/open-sans/styles.css">
    <link rel="stylesheet" href="/vendor/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">
	<link rel="stylesheet" href="/css/tagclouds.css">
	<link rel="stylesheet" href="/css/font-awesome.css">
    <script src="/vendor/jquery/2.1.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/vendor/lightgallery/css/lightgallery.min.css">
    
    
    
    
    


	<script src="//cdn.bootcss.com/jquery/2.1.0/jquery.min.js" type="text/javascript"></script>
</head>

<body>
    <div id="container">
        
    <header id="header">
    <div id="header-main" class="header-inner">
			 <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/index.html">Home</a>
                
                    <a class="main-nav-link" href="/archives">Archive</a>
                
                    <a class="main-nav-link" href="/categories">Category</a>
                
                    <a class="main-nav-link" href="/tags">Tag</a>
                
                    <a class="main-nav-link" href="/about">About</a>
                
                    <a class="main-nav-link" href="/favorite">Photos</a>
                
            </nav>
            
    </div> 
	</div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/index.html">Home</a></td>
                
                    <td><a class="main-nav-link" href="/archives">Archive</a></td>
                
                    <td><a class="main-nav-link" href="/categories">Category</a></td>
                
                    <td><a class="main-nav-link" href="/tags">Tag</a></td>
                
                    <td><a class="main-nav-link" href="/about">About</a></td>
                
                    <td><a class="main-nav-link" href="/favorite">Photos</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search" />
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>




			
        <div class="outer">
			<aside id="profile">
					<div class="profile-inner">
					</div>
			</aside>
			
					<section id="main"><article id="post-fault tolerance of storm" class="article article-type-post" itemscope itemprop="blogPost">
    
	<div class="article-inner" style="border-radius:1.5px; box-shadow: 10px 10px 5px #ccc;">
        
        
            <header class="article-header">
				
					<center>
    
        <h1 class="article-title" itemprop="name">
            Storm的容错
        </h1>
    

					 
						<div class="article-meta">
							
    <div class="article-date">    
        <a href="/2017/07/19/fault tolerance of storm/">
            <time datetime="2017-07-18T16:00:00.000Z" itemprop="datePublished">2017-07-19</time>
        </a>
    </div>

							<!--
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Storm学习之路/">Storm学习之路</a>
		&nbsp;&nbsp;
		
			<span class="article-tag">
				<i class="fa fa-tag"></i>
				<a class="tag-link" href="/tags/storm/">storm</a>, <a class="tag-link" href="/tags/容错/">容错</a>
			</span>
		
    </div>
-->
							<!--
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/storm/">storm</a>, <a class="tag-link" href="/tags/容错/">容错</a>
    </div>
-->
						</div>
					
					
					
						<span class="article-meta">
							
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Storm学习之路/">Storm学习之路</a>
		&nbsp;&nbsp;
		
			<span class="article-tag">
				<i class="fa fa-tag"></i>
				<a class="tag-link" href="/tags/storm/">storm</a>, <a class="tag-link" href="/tags/容错/">容错</a>
			</span>
		
    </div>

							
						</span>
						
					
					
					</center>
				
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
			
				<br/>
				 <blockquote style="font-size:120%;line-height:1.5em;color:#083a4e">
					这篇文章主要整理storm中的容错是如何实现的
				 </blockquote>
			  
            <h2 id="当某个worker失效时"><a href="#当某个worker失效时" class="headerlink" title="当某个worker失效时"></a>当某个worker失效时</h2><p>当某个worker失效时，Supervisor会将这个worker重启。如果在重启的过程中，这个worker不停地失效，并且不能向Nimbus汇报心跳，那么Nimbus会将这个worker重新分配到其他的机器。</p>
<h2 id="当某个node失效时"><a href="#当某个node失效时" class="headerlink" title="当某个node失效时"></a>当某个node失效时</h2><p>当某个node(物理节点)失效时，该node上的所有task都将超时，Nimbus会把这些task重新分配到其他的node上。</p>
<h2 id="当Nimbus或者Supervisor守护进程失效时"><a href="#当Nimbus或者Supervisor守护进程失效时" class="headerlink" title="当Nimbus或者Supervisor守护进程失效时"></a>当Nimbus或者Supervisor守护进程失效时</h2><p>Nimbus和Supervisor的守护进程都是快速失败和无状态的，无论何时当发生意想不到的情况时，进程会自行终止，所有的状态信息都是存储在Zookeeper或者磁盘上。Nimbus和Supervisor的守护进程必须在监视器或虚拟光驱的监督下允许，所以一旦守护进程失效，就会立刻被重启。</p>
<p>ps: 守护进程是指一直在后台运行，且不受任何终端控制的进程，用于执行特点的系统任务。</p>
<h2 id="Nimbus是否是单点失效"><a href="#Nimbus是否是单点失效" class="headerlink" title="Nimbus是否是单点失效"></a>Nimbus是否是单点失效</h2><p>如果Nimbus所在的node失效，worker进行将继续运行；若worker失效，Supervisor也会继续对它们进行重启。但是没有Nimbus，在必要的时候worker不能被重新分配到其他的node。</p>
<a id="more"></a>
<h2 id="Storm如何保证消息的可靠性处理"><a href="#Storm如何保证消息的可靠性处理" class="headerlink" title="Storm如何保证消息的可靠性处理"></a>Storm如何保证消息的可靠性处理</h2><p>Storm提供了某些机制来保证消息的可靠性处理，即使存在node失效或者信息丢失，包括“尽力服务best effort”、“至少处理一次at least once”和“只处理一次exactly once”。下面讲讲Storm是如何保证数据至少处理一次的。</p>
<h3 id="消息被“完全处理fully-processed”是什么意思"><a href="#消息被“完全处理fully-processed”是什么意思" class="headerlink" title="消息被“完全处理fully processed”是什么意思"></a>消息被“完全处理fully processed”是什么意思</h3><p>从spout发出的一个tuple可能会触发成千上万个tuple的创建。结合下面这个例子考虑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TopologyBuilder builder = <span class="keyword">new</span> TopologyBuilder();</span><br><span class="line">builder.setSpout(<span class="string">"sentences"</span>, <span class="keyword">new</span> KestrelSpout(<span class="string">"kestrel.backtype.com"</span>, <span class="number">22133</span>, <span class="string">"sentence_queue"</span>, <span class="keyword">new</span> StringScheme()));</span><br><span class="line">builder.setBolt(<span class="string">"split"</span>, <span class="keyword">new</span> SplitSentence(), <span class="number">10</span>).shuffleGrouping(<span class="string">"sentences"</span>);</span><br><span class="line">builder.setBolt(<span class="string">"count"</span>, <span class="keyword">new</span> WordCount(), <span class="number">20</span>).fieldGrouping(<span class="string">"split"</span>, <span class="keyword">new</span> Fields(<span class="string">"word"</span>));</span><br></pre></td></tr></table></figure>
<p>这个topology从一个Kestrel队列中读取sentence，将sentence划分成若干个word，接着将每个word和该word出现的次数发送给下一个bolt。这种情况下“从spout发出的一个tuple可能会触发成千上万个tuple的创建”：sentence中的每次word对应的tuple和携带有计数的word对应的tuple。构成的消息树如下所示：</p>
<p><img src="http://storm.apache.org/releases/current/images/tuple_tree.png" alt=""></p>
<p>如果这棵tuple树发送完成，并且树中的每一条消息都被正确地处理，那么就认为从spout发出的tuple被“完全处理”了。若某个tuple的消息树在给定的时间内没有被完全处理，那么就认为这个tuple失效了。这个超时的时间可以在构建topology时通过参数<code>Config.TOPOLOGY_MESSAGE_TIMEOUT_SECS</code>来配置，默认值为30秒。</p>
<h3 id="消息被完全处理或处理失败后会发生什么"><a href="#消息被完全处理或处理失败后会发生什么" class="headerlink" title="消息被完全处理或处理失败后会发生什么"></a>消息被完全处理或处理失败后会发生什么</h3><p>为了理解这个问题，我们先回顾一下从spout发出的tuple的生命周期。下面给出spout的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ISpout</span> <span class="keyword">extends</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">(Map conf, TopologyContext context, SpoutOutputCollector collector)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">nextTuple</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">ack</span><span class="params">(Object msgId)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fail</span><span class="params">(Object msgId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，通过调用Spout的<code>nextTuple()</code>方法，Storm向Spout请求一个tuple。Spout使用<code>open()</code>方法中的<code>SpoutOutputCollector</code>向它的一个输出流中发送一个tuple。在发送时，Spout会为每个tuple提供一个”消息id”，用来在后面的处理过程中识别tuple。例如，<code>KestrelSpout</code>从kestrel队列中读取一条消息，然后发送一条带有“消息id”的消息，这个消息id是由Kestrel提供的。使用<code>SpoutOutputCollector</code>发送消息一般是这样的形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_collector.emit(<span class="keyword">new</span> Values(<span class="string">"field1"</span>, <span class="string">"fields2"</span>, <span class="number">3</span>),msgId);</span><br></pre></td></tr></table></figure>
<p>接着，tuple会被发送到下游的消费bolt，Storm会追踪其创建的消息树。如果检测到某个tuple被完全处理了，根据消息id，Storm调用最初发送该tuple的Spout任务的<code>ack()</code>方法。类似地，若该tuple超时了，Storm会调用<code>fail()</code>方法。需要注意的是，对于每个tuple，响应ack和失败处理fail只会由最初创建这个tuple的Spout任务执行。换言之，在整个集群中，若Spout存在多个实例，但是tuple只会被创建它的那个Spout任务实例响应或者失效处理。</p>
<p>再以KestrelSpout为例来看看Spout需要进行哪些操作来保证消息的可靠性处理。当kestrelSpout从kestrel队列中读取一条消息时，可以看作是它“打开”了这条消息。这意味着，消息并没有真正从队列中取出，而是被标记为“挂起”的状态，等待消息被完全处理的信号。在挂起状态时，消息不会被发送到其他消费者。此外，若消费者断开了连接，所有挂起的消息会被放回队列中。消息在打开时，Kestrel会为每个消息提供一个唯一的id。当把tuple发送给<code>SpoutOutputCollector</code>时，KestrelSpout用“消息id”作为tuple的唯一标识。一段时间后，当KestrelSpout中的<code>ack()</code>或者<code>fail()</code>被调用时，KestrelSpout会根据消息id向Kestrel请求将消息从队列中移除(ack)，或者将消息重新放回队列中(fail)。</p>
<h3 id="Storm的可靠性API"><a href="#Storm的可靠性API" class="headerlink" title="Storm的可靠性API"></a>Storm的可靠性API</h3><p>使用Storm的可靠性机制时需要注意两点：第一，在tuple树上创建新的连接时需要通知Storm；第二，当处理完每个tuple时需要通知Storm。通过以上两点操作，Storm可以检测到tuple树何时被完全处理，并在适当的时候调用ack和fail。Storm API以一种非常精确的方式来实现这两个操作。</p>
<p>在tuple树上指定一个连接的操作称为<code>锚定anchoring</code>。当发送一个新的tuple时进行锚定。让我们用下面这个bolt为例，该bolt将包含sentence的tuple分割成若干包含word的tuple：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SplitSentence</span> <span class="keyword">extends</span> <span class="title">BaseRichBolt</span></span>&#123;</span><br><span class="line">  OutputCollector _collector;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(Map conf, TopologyContext context, OutputCollector collector)</span></span>&#123;</span><br><span class="line">    	_collector = collector;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple tuple)</span></span>&#123;</span><br><span class="line">    	String sentence = tuple.getString(<span class="number">0</span>);</span><br><span class="line">    	<span class="keyword">for</span>(String word : sentence.split(<span class="string">" "</span>))&#123;</span><br><span class="line">          	_collector.emit(tuple, <span class="keyword">new</span> Values(word));</span><br><span class="line">    	&#125;</span><br><span class="line">    	_collector.ack(tuple);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer declarer)</span></span>&#123;</span><br><span class="line">    	declarer.declare(<span class="keyword">new</span> Fields(<span class="string">"word"</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过将输入tuple指定为<code>emit()</code>的第一个参数对每个单词对应的tuple进行锚定。这样，在下游的后续处理中若该tuple处理失败了，位于tuple树根节点的spout tuple就会被重新处理。相应地，如果按照下面的方法发送tuple：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_collector.emit(<span class="keyword">new</span> Values(word));</span><br></pre></td></tr></table></figure>
<p>这种方式被称为“非锚定”。在这种情况下，下游的tuple处理失败不会触发根节点tuple的重新处理。但这种非锚定的发送在某些场合下也是合适的，这取决于我们对topology的容错要求。</p>
<p>一个输出的tuple可以被锚定到多个输入tuple。这在数据流连接或者聚合操作时很有用。一个失败的多锚定的tuple会导致spout中多个tuple被重新处理。多锚定是通过指定一个tuple列表，而不是单一的tuple，来实现的，示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Tuple&gt; anchors = <span class="keyword">new</span> ArrayList&lt;Tuple&gt;();</span><br><span class="line">anchors.add(tuple1);</span><br><span class="line">anchors.add(tuple2);</span><br><span class="line">_collector.emit(anchors, <span class="keyword">new</span> Values(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br></pre></td></tr></table></figure>
<p>多锚定把输出tuple加入到多个tuple树中。需要注意的是，多锚定可能会破坏tuple树的结构，并创建tuple的有向无环图，如下所示：</p>
<p><img src="http://storm.apache.org/releases/current/images/tuple-dag.png" alt=""></p>
<p>Storm的实现既支持对tuple树的处理，也支持有向无环图的处理。</p>
<p>锚定就是如何把一个消息加入到指定的tuple树中——Storm可靠性处理API的接下来部分将具体说明何时完全处理完tuple树中的一个tuple。这是通过调用<code>OutputCollector</code>中的<code>ack()</code>和<code>fail()</code>方法实现的。回顾<code>SplitSentence</code>的例子，可以发现输入tuple是在左右单词tuple被发送出去之后被ack的。</p>
<p>我们可以使用<code>OutputCollector</code>的<code>fail()</code>方法使得位于tuple树根节点的spout tuple立即失效。比如，某个应用可能选择补货来自数据库客户端的一个异常，使得输入tuple立刻失效。通过这种方式，重新处理spout tuple就会比等待tuple超时更快。</p>
<p>处理的每个tuple都必须被ack或fail。Storm使用内存来追踪每个tuple，所以，如果不对其进行ack或者fail，负责追踪的任务很会就会发生内存溢出。</p>
<p>Bolt处理tuple的通用模式是：读取输入tuple，发送基于该tuple而生成的tuple，在<code>execute()</code>方法执行结束时ack输入tuple。大多数bolt都采取这样的处理方式。这些bolt大多属于过滤器或者简单的函数一类。Storm提供了接口<code>BasicBolt</code>涵盖了以上操作。例如，若使用BasicBolt，SplitSentence可以是如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SplitSentence</span> <span class="keyword">extends</span> <span class="title">BaseBasicBolt</span></span>&#123;</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple tuple, BasicOutputCollector collector)</span></span>&#123;</span><br><span class="line">      	String sentence = tuple.getString(<span class="number">0</span>);</span><br><span class="line">      	<span class="keyword">for</span>(String word : sentence.split(<span class="string">" "</span>))&#123;</span><br><span class="line">          	collector.emit(<span class="keyword">new</span> Values(word));</span><br><span class="line">      	&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer declarer)</span></span>&#123;</span><br><span class="line">      	declarer.declare(<span class="keyword">new</span> Fields(<span class="string">"word"</span>));</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上这种实现方式比之前的方法要简单许多，并且在语义上可以达到相同的效果。发送给<code>BasicOutputCollector</code>的tuple被自动锚定到输入tuple，并且在<code>execute()</code>执行结束后会自动ack输入tuple。</p>
<p>相反，做连接或者聚合操作的bolt可能需要推迟ack，直到一批tuple完成了某种计算结果。聚合和连接操作一般也需要对输出tuple进行多锚定。这个操作超出了<code>IBasicBolt</code>的应用范围。</p>
<h3 id="在tuple被重新处理时如何使得应用正确运行"><a href="#在tuple被重新处理时如何使得应用正确运行" class="headerlink" title="在tuple被重新处理时如何使得应用正确运行"></a>在tuple被重新处理时如何使得应用正确运行</h3><p>按照软件设计的一般思路，答案是“取决于实际情况”。如果想要保证计算过程都能满足恰好一次的语义，可以使用Trident API。在某些情况下，比如数据分析任务中，丢弃一些数据是可以接受的，因此通过将参数<code>Config.TOPOLOGY_ACKERS</code>置为0，使得acker bolt的数量为0，从而取消应用的容错性。但是在其他情况下，需要保证每个计算过程满足至少处理一次的语义，并且不允许丢弃任何数据。如果所有的操作都是idenpotent，或者未来会发生重复删除的操作，那么这将十分有用。(an indemponent operation is one that has no additional effect if it is called more than once with the same input paramenters).</p>
<h3 id="Storm是如何以一种高效的方式实现可靠性的"><a href="#Storm是如何以一种高效的方式实现可靠性的" class="headerlink" title="Storm是如何以一种高效的方式实现可靠性的"></a>Storm是如何以一种高效的方式实现可靠性的</h3><p>一个topology拥有一组特殊的acker任务，用来追踪每个spout tuple发出tuple的DAG。当一个acker发现一个DAG完成时，它会向创建该spout tuple的spout任务实例发送消息，让这个任务来ack消息。我们可以通过参数<code>Config.TOPOLOGY_ACKERS</code>来配置acker的数量，Storm默认值为1。</p>
<p>理解Storm可靠性实现的最好的方法是了解tuple和tuple DAG的生命周期。当一个tuple被创建时，无论是在spout还是bolt中，它被分配一个64位的id。这个id将被acker用来追踪每个spout tuple的tuple DAG。</p>
<p>当在bolt中发送一个新的tuple时，输入tuple 锚定的所有spout tuple的id将会被复制到新的tuple中。tuple被ack时，它会向适合的acker任务发送消息，通知如何修改tuple树。实际上，它通知acker的是“在这个spout tuple所在的tuple树中，我已经被完全处理了，这些是被锚定到我的新的tuple，需要加到这个树中”。</p>
<p>以下图为例，如果tuple D和 E是基于tuple C创造出来的，当C被ack时，tuple树需要做如下修改：</p>
<p><img src="http://storm.apache.org/releases/current/images/ack_tree.png" alt=""></p>
<p>由于C被移除的同时D和E被加进来，所以tuple树不会过早地结束。</p>
<p>关于Storm是如何跟踪tuple树还有许多细节，正如前面所说的，在一个topology中我们可以设置任意数量的acker，但这带来一个新的问题：当某个tuple被ack，它如何知晓让哪个acker来发送消息？</p>
<p>Storm使用哈希算法将spout tuple匹配到acker上。由于每个tuple携带了它所在tuple树的spout tuple的id，因此它们知道需要和哪个acker通信。</p>
<p>另一个细节问题是acker是如何知道它们追踪的spout tuple是来自哪个spout 任务的。实际上spout task在发送一个新的tuple时，它会向适合的acker发送一个简单的消息，通知它这个spout tuple是和自己的任务id相关联的。当acker发现某个tuple 树被完全处理了，它就知道需要向哪个task发送完成消息。</p>
<p>acker 实际上不会直接追踪tuple树。对于拥有成千上万个节点的tuple树而言，追踪整个树会消耗完所有的内存。相反，acker采用一种特殊的策略，只要占用固定的内存空间来追踪每个spout tuple，大概20字节。这个追踪算法是Storm运行的关键，也是突破技术之一。</p>
<p>一个acker存储了spout tuple id到一组值得映射表。 第一个值是创建这个spout tuple的task id号，用于后面发送完成信号。第二个值是一个称为“ack val”的64位数字。这个值代表了整个tuple树的状态，与树的大小无关。因为这个值仅仅是这个tuple树中所有被创建或者被ack的tuple的tuple id进行异或运算得到的结果值。</p>
<p>当一个acker发现ack val的值变为0时，它就知道tuple树被完全处理了。由于tuple id是一个随机的64位数字，因此ack val碰巧为0是一种极小概率的事件。理论计算可得，在每秒ack一万次的情况下，需要5000万年才会发生一次错误。而且即使是这样，也只会在tuple碰巧失败的时候才会发生数据丢失的情况。</p>
<p>假设现在我们已经理解了这个可靠性算法，让我们再分析一下所有失败的情况，看看这些情况下Storm是如何避免数据丢失的：</p>
<ul>
<li>task失效时tuple没被ack：在这种情况下，位于根节点的spout tuple会在任务超时后重新处理。</li>
<li>Acker进程失效：在这种情况下，acker追踪的所有spout tuple都会由于超时而被重新处理。</li>
<li>Spout进程失效：在这种情况下，Spout任务的来源会重新处理这些消息。举个例子，Kestrel和RabbitMQ之类的队列会将所有挂起的消息重新放回队列中。</li>
</ul>
<p>综上，Storm的可靠性机制是完全分布式的，可扩展的，且支持容错的。</p>
<h3 id="调整可靠性"><a href="#调整可靠性" class="headerlink" title="调整可靠性"></a>调整可靠性</h3><p>由于acker进程是轻量级的，所以在topology中不需要很多的ack任务。我们可以通过Storm UI来监控它们的性能，它们的任务id为<code>_acker</code>。如果发现观察结果存在问题，就需要增加更多的acker任务。</p>
<p>如果不关心可靠性，也就是说，不担心在失败的情形下发生tuple的丢失，那么可以通过不跟踪tuple树来提升topology的性能。由于tuple树中的每个tuple都会携带一个ack消息，不追踪tuple树会使得传输的消息数量减半。同时，下游数据流中的id也会变少，降低网络带宽的消耗。</p>
<p>有三种方法可以移除Storm的可靠性机制。第一种方法是将<code>Config.TOPOLOGY_ACKERS</code>的值设置为0，在这种情况下，Storm会在spout发送tuple之后立即调用ack，这样tuple树就不会被追踪了。</p>
<p>第二种方法是基于消息本身移除可靠性。我们可以通过在<code>SpoutOutputCollector.emit()</code>方法中省略消息id来关闭spout tuple的追踪功能。</p>
<p>最后，如果不关系topology下游的tuple是否会失败，可以在发送tuple时选择发送发送非锚定unanchored的tuple。由于这些tuple不会被锚定到到任何一个spout tuple，因此如果它们没有被ack，也不会导致spout tuple的重新处理。</p>

			
			
		<br>
		
		
		
<div class="copyright">
  <p><span>Title:</span><a href="/2017/07/19/fault tolerance of storm/">Storm的容错</a></p>
  <p><span>Author:</span><a href="/" title="visit Tankcat 's personal blog">Tankcat</a></p>
  <p><span>Release Date:</span>2017-07-19  00:00</p>
  <p><span>Update Date:</span>2017-07-20  08:44</p>
  <p>
    <span>Original Link:</span><a href="/2017/07/19/fault tolerance of storm/" title="Storm的容错">http://tankcat2.com/2017/07/19/fault tolerance of storm/</a>
    <span class="btn" data-clipboard-text="Master Copy: http://tankcat2.com/2017/07/19/fault tolerance of storm/　　Author: Tankcat" title="copy the article link">
        <i class="fa fa-clipboard"></i>
    </span>
  </p>
 <p><span>License Agreement:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="Mainland China (CC BY-NC-SA 3.0 CN)">"Signature-Non Commercial-Share Alike 3.0"</a>.
 <br>
 <br>
 <span>Please retain the original link and author if reprinting.
 </span>
 </p>
  <script src="/js/clipboard.min.js"></script>
  <script> var clipboard = new Clipboard('.btn'); </script>
</div>
<style type="text/css">
  .copyright p .btn {
    margin-left: 1em;
  }
  .copyright:hover p .btn::after {
    content: "Copy"
  }
  .copyright p .btn:hover {
      color: gray;
      cursor: pointer;
    };
</style>

<br>
<br>
		<style type="text/css">
		  .center {
			  text-align: center;
		  }
		  .hidden {
			  display: none;
		  }
		.donate_bar a.btn_donate{
		  display: inline-block;
		  width: 82px;
		  height: 82px;
		  background: url("http://7xsl28.com1.z0.glb.clouddn.com/btn_reward.gif") no-repeat;
		  _background: url("http://7xsl28.com1.z0.glb.clouddn.com/btn_reward.gif") no-repeat;
		  -webkit-transition: background 0s;
		  -moz-transition: background 0s;
		  -o-transition: background 0s;
		  -ms-transition: background 0s;
		  transition: background 0s;
		}

		.donate_bar a.btn_donate:hover{ background-position: 0px -82px;}
		.donate_bar .donate_txt {
		  display: block;
		  color: #9d9d9d;
		  font: 14px/2 "Microsoft Yahei";
		}
		.bold{ font-weight: bold; }
	  </style>
	  
	  
	  
	  <div id="donate_module">
		<div id="donate_board" class="donate_bar center">
		打赏 | Buy me a coffee<br/><br/>
		<a id="btn_donate" class="btn_donate" target="_self" href="javascript:;" title="Donate 打赏" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}"></a>
		  
		
		</div>
		
		<div id="QR" style="display: none;">
			<br>
		  <br>
		
		<a href="http://7xwggp.com1.z0.glb.clouddn.com/webwxgetmsgimg.jpg" title="用微信扫一扫哦~" class="fancybox" rel="article0">
		  <img src="http://7xwggp.com1.z0.glb.clouddn.com/webwxgetmsgimg.jpg" title="微信打赏 Colin" height="250px" width="250px"/>
		</a>
		<br>
		<center>
		<span class="donate_txt">
		  If you enjoy the blog, please feel free to donate~Thx for your support.
		</span>
	</center>
	  </div>
	  <br>
	   
	  </div>
		
				
			
        </div>
		
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://tankcat2.com/2017/07/19/fault tolerance of storm/" data-id="cjagbq454000itkkxhmrr13cg" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=' + encodedUrl + '" class="fa fa-qq article-share-qzone" target="_blank" title="Qzone"></a>',
                            '<a href="http://service.weibo.com/share/share.php?url=' + encodedUrl + '" class="fa fa-weibo article-share-weibo" target="_blank" title="Weibo"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://tankcat2.com/2017/07/19/fault tolerance of storm/#comments" class="article-comment-link disqus-comment-count" data-disqus-url="http://tankcat2.com/2017/07/19/fault tolerance of storm/">Comments</a>
    

        </footer>
		
    </div>
    
        
<nav id="article-nav">
    
        <a href="/2017/07/21/my chester/" id="article-nav-newer" class="article-nav-link-wrap">
            <strong class="article-nav-caption">Newer</strong>
            <div class="article-nav-title">
                
                    Tragic Ending or Peace Ending ?
                
            </div>
        </a>
    
    
        <a href="/2017/05/22/storm_ui/" id="article-nav-older" class="article-nav-link-wrap">
            <strong class="article-nav-caption">Older</strong>
            <div class="article-nav-title">Storm UI详解</div>
        </a>
    
</nav>


    
</article>




	
    
    <section id="comments" style="border-radius:1.5px; box-shadow: 10px 10px 5px #ccc;">
    
        
    <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>

    
    </section>


</section>
			
			
			
        </div>

			<div style="height:10px;pistion:absolute;bottom:0"></div>
<footer id="footer" >
    <div class="outer">
		<div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
        <div id="footer-info" class="inner">
            &copy; 2017 <i class="fa fa-heart blink-slow"></i> Tankcat<br>
            Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme by <a href="http://github.com/ppoffice">PPOffice</a>
        </div>
		
    </div>
</footer>
			
    
    <script>
    var disqus_config = function () {
        
            this.page.url = 'http://tankcat2.com/2017/07/19/fault tolerance of storm/';
        
        this.page.identifier = 'fault tolerance of storm';
    };
    (function() { 
        var d = document, s = d.createElement('script');  
        s.src = '//' + 'tankcat2' + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>



    
        <script src="/vendor/lightgallery/js/lightgallery.min.js"></script>
        <script src="/vendor/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/vendor/lightgallery/js/lg-pager.min.js"></script>
        <script src="/vendor/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/vendor/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/vendor/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/vendor/lightgallery/js/lg-hash.min.js"></script>
        <script src="/vendor/lightgallery/js/lg-share.min.js"></script>
        <script src="/vendor/lightgallery/js/lg-video.min.js"></script>
    
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

	
    </div>
</body>

</html>